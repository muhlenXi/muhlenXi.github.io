[{"title":"iOS BLE 开发小记（3）","date":"2017-05-01T02:45:00.000Z","path":"2017/05/01/iOS-Bluetooth-Low-Energy-Develop-Chapter3/","text":"版权声明：本文为 muhlenXi 原创文章，欢迎转载，转载请注明来源: http://muhlenxi.com/2017/05/01/iOS-Bluetooth-Low-Energy-Develop-Chapter3 导语： 在这一节，你将会学到，如何通过 CoreBluetooth 框架来实现 Local Peripheral 方面的功能和代理方法。 在 iOS BLE 开发小记（2）中，你已经学到了如何在 Central 方面去调用 BLE 的常用方法。在这一节中，你将学习用 CoreBluetooth 框架来调用 Peripheral 方面 BLE 的常用方法。通过本文的示例代码，将会引导你开发一个将你的 Local 设备实现为 Local Peripheral。你将会从中学到： 如何创建一个 Peripheral Manager 对象 如何为你的 Local Peripheral 设置 Services 和 Characteristics 如何发布你的 Services 和 Characteristics 数据 如何广播你的设备 如何对连接的 Central 做读写请求响应 如何发送更新后的值给订阅的 Central 或许你发现示例代码过于简单和抽象，你需要在你的 App 中做些恰当的练习来掌握这些内容。更高级的技巧和最佳实践在后续的文章中将会讲解。 Peripheral 实现详情创建一个 Peripheral Manager 对象在 Local Device（当前设备）实现 Peripheral 规范的第一步是分配（allocate）和初始化（initialize）一个周边管理（Peripheral Manager），（用 CBPeripheralManager 对象表示），通过调用 CBPeripheralManager 的 initWithDelegate:queue:options: 方法来创建管理对象，如下所示 12myPeripheralManager = [[CBPeripheralManager alloc] initWithDelegate:self queue:nil options:nil]; 在示例代码中，设置 Delegate 为 self 是为了接收 Peripheral 的事件响应，将参数 dispatch queue 置为 nil。意味着 Peripheral Manager 将会在主队列中分发事件。 当你创建一个 Peripheral Manger 对象时，Peripheral Manager 会通过 peripheralManagerDidUpdateState: 方法来代理回调，你必须实现这个代理方法来确保当前设备是否支持 BLE 技术，关于代理方法的详情可以查阅 CBPeripheralManagerDelegate Protocol Reference. 设置你的 Services 和 Characteristics在第一节中，我们了解到，一个 Local Peripheral 采用树形结构来组织 Services 和 Characteristics 的数据。因此必须采用树形结构方式来设置 Local Peripheral 的 Services 和 Characteristics。你第一步要做的是搞清和理解 Service 和 Characteristic 是如何标识的。 通过 UUID 标识 Services 和 CharacteristicsPeripheral 的 Service 和 Characteristic 是通过 128 位的特定蓝牙 UUID（通用唯一识别码）来标识的，在 CoreBluetooth 中是用 CBUUID 对象来表示的。并不是所有的 UUID 都是通过 Bluetooth Special Interest Group （蓝牙特别兴趣小组）预定义的。为了方便起见，Bluetooth SIG 定义和发布了许多通用的 16位 UUID。举个例子，Bluetooth SIG 事先定义了一个16位的 UUID 用来标识一个心率 Service，该 UUID 是 128位 UUID 0000180D-0000-1000-8000-00805F9B34FB 进行缩减而来的，这是基于蓝牙 4.0 规范中，第 3 卷 F 部分第 3.2.1 节定义的蓝牙基础 UUID。 CBUUID 提供了一个处理比较长的 UUID 的工厂方法，举个例子，生成一个表示心率 Service 的 UUID，可以调用 UUIDWithString 方法来通过预定义的 16位 UUID来创建 CBUUID 对象。 1CBUUID *heartRateServiceUUID = [CBUUID UUIDWithString: @\"180D\"]; 当你通过预定义的 16位 UUID 来创建 CBUUID 对象时，CoreBluetooth 会基于128位Bluetooth Base UUID 填充剩下的的 UUID 位。 为你定制的 Services 和 Characteristics 生成 UUID你的 Service 和 Characteristic 的UUID也许可能没有被 Bluetooth UUIDs 预定义，如果没有被预定义，你需要手动生成你自己的 128位 UUID 来表示 Service 和 Characteristic。 通过命令行命令 uuidgen 可以生成 128位的 UUID，打开你的 Terminal（终端），通过这种方式依次为你的 Services 和 Characteristics 生成一个 UUID （用连字符连接起来的字符串）来标识。举例如下： 12$ uuidgen71DA3FD1-7E10-41C1-B16F-4430B506CDE7 你可以用上面方法生成的 UUID 调用 UUIDWithString 方法来创建一个 CBUUID 对象。 12CBUUID *myCustomServiceUUID = [CBUUID UUIDWithString:@\"71DA3FD1-7E10-41C1-B16F-4430B506CDE7\"]; 构建你的 服务特征树当你为每个 Service 和 Characteristic 创建 CBUUID 对象后，你可以创建 mutable Service（可变服务） 和 mutable Characteristic（可变特征），然后以树形的方式组织它们。举个例子，如果你现在有一个 Characteristic 的 UUID，你可以通过调用 CBMutableCharacteristic 类的 initWithType:properties:value:permissions: 方法生成一个 mutable Characteristic。 1234myCharacteristic = [[CBMutableCharacteristic alloc] initWithType:myCharacteristicUUID properties:CBCharacteristicPropertyRead value:myValue permissions:CBAttributePermissionsReadable]; 当你创建 mutable Characteristic 的时候，你可以指定它的 properties（属性）、value（值）和 permissions（权限许可），你指定的 properties 和 permissions 决定这个 Characteristic 的值是否可以读或者写，或者连接的 Central 能否订阅该 Characteristic 的值。下面的示例中，Characteristic 的值是被指定为可读的。关于 mutable Characteristic 的 properties 和 permissions 详情可以查阅 CBMutableCharacteristic Class Reference. 提示：如果你指定了 Characteristic 的值，那么该值将被缓存并且该 Characteristic 的 properties 和 permissions 将被设置为可读的。因此，如果你需要 Characteristic 的值是可写的，或者你希望在 Service 发布后，Characteristic 的值在 lifetime（生命周期）中依然可以更改，你必须将该 Characteristic 的值指定为 nil。通过这种方式可以确保 Characteristic 的值,在 Peripheral Manager 收到来自连接的 Central 的读或者写请求的时候，能够被动态处理。 既然你创建了一个 mutable Characteristic，你也能通过调用 CBMutableService 类的 initWithType:primary: 方法创建一个 mutable Service。如下所示： 1myService = [[CBMutableService alloc] initWithType:myServiceUUID primary:YES]; 在示例代码中，第二个参数被指定为 YES，用来表明该 Service 是 Primary（主要的），而不是 secondary（次要的）。一个 Primary Service 用来描述这个设备的主要功能，还可以用来引用其他的 Service。一个 Secondary Service 用来描述的是上下文中相关的或者被引用的 Service。举个例子，从心率传感器中获取心率的服务是 primary Service，而获取传感器电量的服务就可以被视为 secondary Service 。 当你创建完 Service 后。你需要设置 Service 的 Characteristic 数组属性，如下： \u00101myService.characteristics = @[myCharacteristic]; 发送你的 Services 和 Characteristics当你构建好服务特征树后，下一步就是按照 BLE 的规范发布到设备的服务特征库中，用 CoreBluetooth 可以很轻松的完成这一步，只需要调用 CBPeripheralManager类 的 addService: 方法就可以了。 示例代码如下： 1[myPeripheralManager addService:myService]; 当你调用该方法发布服务时，Peripheral Manager 会调用 peripheralManager:didAddService:error: 方法进行代理回调，实现这个代理方法可以获取到产生的错误，示例代码如下： 123456789- (void)peripheralManager:(CBPeripheralManager *)peripheral didAddService:(CBService *)service error:(NSError *)error &#123; if (error) &#123; NSLog(@\"Error publishing service: %@\", [error localizedDescription]); &#125; // ...&#125; 提示：当你发布 Service 和相关的 Characteristic 到 Peripheral 的数据库中后，设备已经将数据缓存，你不能再改变它了。 广播你的 Service当你发布你的 Service 和 Characteristic 到设备的服务特征库时，你可以广播一些服务给正在监听的 Central，你可以通过调用 CBPeripheralManager 类的 startAdvertising: 方法来开始广播，传入的字典是要广播的数据。 12[myPeripheralManager startAdvertising:@&#123; CBAdvertisementDataServiceUUIDsKey : @[myFirstService.UUID, mySecondService.UUID] &#125;]; 在示例代码中，传入的字典中唯一的 key 是 CBAdvertisementDataServiceUUIDsKey,用一个包含 CBUUID 对象的数组来表示你想要广播的服务的 UUID。你在字典中可以指定的其他 key 在 Advertisement Data Retrieval Keys 中有详细说明。也就是说，仅有 CBAdvertisementDataLocalNameKey 和 CBAdvertisementDataServiceUUIDsKey 这两个 key 支持 Peripheral Manager 对象。 当你在本地设备中广播一些数据时，Peripheral Manager 会通过 peripheralManagerDidStartAdvertising:error: 方法来代理回调。如果你的设备不能广播而发生错误时，实现这个代理方法可以获取产生的错误： \u001012345678- (void)peripheralManagerDidStartAdvertising:(CBPeripheralManager *)peripheral error:(NSError *)error &#123; if (error) &#123; NSLog(@\"Error advertising: %@\", [error localizedDescription]); &#125; // ...&#125; 提示：广播数据方法会被尽力执行，因为空间是有限的和多个 APP 可能同时需要广播数据，更多详情可以查阅关于 startAdvertising: 方法的讨论。 当你的 APP 在后台运行时也会影响广播的行为，这一内容将会在下一篇中进行讨论。 响应 Central 的读写请求当你连接一个或多个 Central 后，你可能会收到读或者写的请求，对这些请求作出响应需要采取恰当的方式，下面的示例代码将会描述如何处理这些请求。 当一个连接的 Central 发送读取某个 Characteristic 数据的请求时，Peripheral Manager 会调用 peripheralManager:didReceiveReadRequest: 方法进行代理回调。代理方法以 CBATTRequest 对象的方式来传递请求，它包含一些请求的属性。 比如，当你收到一个读取 Characteristic 值的简单请求时，可以通过代理方法回调的 CBATTRequest 对像来判断 Central 指定要读取的 Characteristic 是否和设备服务库中的 Characteristic 是否相匹配。你可以开始实现这个代理方法，示例代码如下： 1234567- (void)peripheralManager:(CBPeripheralManager *)peripheral didReceiveReadRequest:(CBATTRequest *)request &#123; if ([request.characteristic.UUID isEqual:myCharacteristic.UUID]) &#123; // ... &#125;&#125; 如果 Characteristic 的 UUID 能够匹配，下一步就是确保读取请求的位置没有超出 Characteristic 的值的边界。如下面代码所示，你可以通过使用 CBATTRequest 对象的 offset 属性来确保读取请求没有尝试读取范围之外的数据。 12345if (request.offset &gt; myCharacteristic.value.length) &#123; [myPeripheralManager respondToRequest:request withResult:CBATTErrorInvalidOffset]; return;&#125; 假如读取请求的 offset（偏移）已经确认，现在就可以设置请求的 Characteristic 的属性（默认值为 nil）为你设备中的 Characteristic 的值了，你应该重视读取请求的偏移： 123request.value = [myCharacteristic.value subdataWithRange:NSMakeRange(request.offset, myCharacteristic.value.length - request.offset)]; 设置完值后，通过调用 respondToRequest:withResult: 方法并传入 request（更新值后的）和 请求的结果参数来对 Remote Central 的请求作出响应表示请求已经被成功处理。示例代码如下： 12[myPeripheralManager respondToRequest:request withResult:CBATTErrorSuccess];// ... 只要代理方法 peripheralManager:didReceiveReadRequest: 方法被回调，就需要准确的调用 respondToRequest:withResult: 方法。 提示：如果 Characteristic 的 UUID 不匹配，或者因为某种原因不能完全读取，不必去填充请求，直接调用 respondToRequest:withResult: 方法并提供一个表示失败的结果即可。你可能指定的结果列表见 CBATTError Constants 常量枚举。 处理连接的 Central 写入请求也比较易懂。当 Central 发送一个写入请求给一个或多个你的 Characteristic 时，Peripheral Manager 会通过 peripheralManager:didReceiveWriteRequests: 方法来代理回调。这是，代理方法会传递一个包含一个或多个 CBATTRequest 对象的数组给你，数组中的每个对象都代表一个写入请求。当你确定写入请求能够处理时，你可以设置 Characteristic 的值，示例代码如下： \u00101myCharacteristic.value = request.value; 尽管示例代码没有说明，当你给 Characteristic 写数据的时候，你应该确保请求的 offset 属性的范围有效。 就像你响应读取请求一样，只要代理方法 peripheralManager:didReceiveWriteRequest: 方法被回调，就需要准确无误的调用 respondToRequest:withResult: 方法。也就是说，respondToRequest:withResult: 方法期望有一个 CBATTRequest 对象，即使你可能通过 peripheralManager:didReceiveWriteRequests: 代理方法接收到一个包含 CBATTRequest 对象的数组，你也应该传入数组中的第一个对象，示例代码如下： 12[myPeripheralManager respondToRequest:[requests objectAtIndex:0] withResult:CBATTErrorSuccess]; 提示：将多请求视为单一请求来对待，如果个别的请求不能被填充，你就不必填充其余的请求了，直接调用 respondToRequest:withResult: 方法并提供一个表示失败的结果即可。 发送更新 Characteristic 的通知给订阅的 Central连接的 Central 经常会订阅一个或多个 Characteristic 的值，当这些值发生变化时，你应该发送通知给订阅的 Central 。 当一个连接的 Central 订阅一个或多个你的 Characteristic 值时，Peripheral Manager 会通过 peripheralManager:central:didSubscribeToCharacteristic: 方法来代理回调。示例代码如下： 1234567- (void)peripheralManager:(CBPeripheralManager *)peripheral central:(CBCentral *)centraldidSubscribeToCharacteristic:(CBCharacteristic *)characteristic &#123; NSLog(@\"Central subscribed to characteristic %@\", characteristic); // ...&#125; 将上述的代理方法作为一个线索来开始给 Central 发送更新后的值。 接着，获取更新后的 Characteristic 的值，通过调用 CBPeripheralManager类的 updateValue:forCharacteristic:onSubscribedCentrals: 方法来给 Central 发送通知。示例代码如下： 123NSData *updatedValue = // fetch the characteristic's new valueBOOL didSendValue = [myPeripheralManager updateValue:updatedValue forCharacteristic:characteristic onSubscribedCentrals:nil]; 当你调用这个方法给订阅的 Central 发送通知时，你可以通过最后的那个参数来指定要发送的 Central，示例代码中的参数为 nil，表明将会发送通知给所有连接且订阅的 Central，没有订阅的 Central 则会被忽略。 updateValue:forCharacteristic:onSubscribedCentrals: 方法会返回一个 Boolean 类型的值来表示通知是否成功的发送给订阅的 Central 了，如果 base queue （基础队列）满载，该方法会返回 NO，当传输队列存在更多空间时，Peripheral Manager 则会调用 peripheralManagerIsReadyToUpdateSubscribers: 代理方法进行回调。你可以实现这个代理方法，在方法中再次调用 updateValue:forCharacteristic:onSubscribedCentrals: 方法发送通知给订阅的 Central。 提示：用通知发送单个数据包给订阅的 Central，就是说，一旦订阅的 Central 发行更新时，你就应该调用 updateValue:forCharacteristic:onSubscribedCentrals: 方法用单一通知发送全部的更新值。 并不是所有的数据都是通过通知来传输的，这主要取决于你的 Characteristic 的值的大小，只有当 Central 调用CBPeripheral类的 readValueForCharacteristic: 方法时，你可以检索全部的值。 参考文献1、Performing Common Peripheral Role Tasks 结束语欢迎在本文下面留言一起交流心得… 如果本文能给你带来一定的帮助，在自己有能力的情况下，不妨赞助一下，表示对博主辛勤耕作的支持！","tags":[{"name":"BLE","slug":"BLE","permalink":"http://yoursite.com/tags/BLE/"}]},{"title":"iOS BLE 开发小记（2）","date":"2017-04-29T02:45:00.000Z","path":"2017/04/29/iOS-Bluetooth-Low-Energy-Develop-Chapter2/","text":"版权声明：本文为 muhlenXi 原创文章，欢迎转载，转载请注明来源: http://muhlenxi.com/2017/04/29/iOS-Bluetooth-Low-Energy-Develop-Chapter2 导语： 在这一节，你将会学到，如何通过 CoreBluetooth 框架来实现 Local Central 方面的功能和代理方法。 在 BLE 通信中，实现了 Central 规范的设备，能够调用许多常用的方法，比如搜索和连接可用的 Peripheral，然后与 Peripheral 提供的数据进行交互。但是实现了 Peripheral 规范的设备同样能够调用许多常见的方法，但是也有一些不同。比如，发布和广播 Service，对 Central 的读写请求进行响应以及 响应Central 的订阅请求。 本文的示例代码将会引导你在当前设备的 APP 中如何实现 Central 的规范。除此之外，你还会学到： 如何创建一个 Central Manager 对象 如何搜索和连接一个正在广播信息的 Peripheral 成功连接后如何与 Peripheral 的数据进行交互 如何一个发送或写入请求给 Peripheral Service 的 Characteristic 如何订阅一个每当更新数据时就会发出通知的 Characteristic 也许你会发现本文的示例代码比较简单和抽象，但是不用担心，后续章节会有一个实战 APP 来演示如何在 APP 中实现 Central 功能。 Central 实现详情在本文中，你的 ViewController 需要遵循 CBCentralManagerDelegate 和 CBPeripheralDelegate 代理协议。 创建 Central Manager因为在 CoreBluetooth 中是通过面向对象的思想用一个 CBCentralManager（中心管理） 对象来表示一个 Local Central 设备，所以在调用该对象的方法之前需要先 allocate（分配）和 initialize（初始化）一个 Central Manager 实例。可以通过 initWithDelegate:queue:options: 方法来初始化一个 Central Manager 对象。 12myCentralManager = [[CBCentralManager alloc] initWithDelegate:self queue:nil options:nil]; 在示例代码中，设置 Central Manager 的 Delegate 为 Self，是为了接收 Central 的事件响应。 参数 dispatch queue（调度队列）设置为 nil，表示 Central Manager 是在 main queue（主队列）中分发响应事件。 当你创建一个 Central Manager 对象时，Central Manager 会调用 centralManagerDidUpdateState: 方法来代理回调。因此你必须实现这个代理方法来确保 Central 设备能够使用 BLE 技术,代理方法的详情见 CBCentralManagerDelegate Protocol Reference。 搜索正在广播数据的 Peripheral 设备初始化 Central Manger 对象后，第一个任务就是搜索周围的 Peripheral，上一篇曾提到过， Peripheral 通过广播数据的方式来显示它们的存在，你可以通过 scanForPeripheralsWithServices:options: 方法来搜索周围正在广播数据的 Peripheral 设备。 1[myCentralManager scanForPeripheralsWithServices:nil options:nil]; 关于参数说明：如果第一个参数置为 nil 时，Central Manager 会返回所有正在广播数据的 Peripheral 设备。在实际 APP 开发中，通过指定一个包含 CBUUID 对象的数组来获取指定的 Peripheral，其中用一个 UUID（通用唯一识别码）来表示 Peripheral 正在广播的一个服务。关于 CBUUID 对象的详情见 Services and Characteristics Are Identified by UUIDs. 每当 Central Manager 搜索到一个 Peripheral 设备时，就会通过 代理方法 centralManager:didDiscoverPeripheral:advertisementData:RSSI: 进行回调，新发现的 Peripheral 会以 CBPeripheral 对象的方式返回。如果你后面需要连接这个 Peripheral，需要用一个 CBPeripheral 类型的 Strong Reference（强引用）来指向这个对象，这样系统暂时就不会释放这个对象了。 123456789- (void)centralManager:(CBCentralManager *)central didDiscoverPeripheral:(CBPeripheral *)peripheral advertisementData:(NSDictionary *)advertisementData RSSI:(NSNumber *)RSSI &#123; NSLog(@\"Discovered %@\", peripheral.name); self.discoveredPeripheral = peripheral; // ...&#125; 当你需要连接多个 Peripheral 设备时，需要使用一个 NSArray 来保存这些搜索到的 Peripheral，不管怎样，为了减少电量损耗，增加续航时间，只要搜索到你需要连接的 Peripheral 时，就可以停止搜索了。通过下面的方法可以停止搜索了。 1[myCentralManager stopScan]; 连接刚发现的 Peripheral 设备可以调用 connectPeripheral:options: 方法来连接你想要连接的 Peripheral 设备。 1[myCentralManager connectPeripheral:peripheral options:nil]; 如果连接成功，Central 会通过 centralManager:didConnectPeripheral: 方法进行代理回调。在你与 Peripheral 进行交互时，你需要设置 Peripheral 的 Delegate 为 self 来确保能收到 Peripheral 的代理回调。 1234567- (void)centralManager:(CBCentralManager *)central didConnectPeripheral:(CBPeripheral *)peripheral &#123; NSLog(@\"Peripheral connected\"); peripheral.delegate = self; // ...&#125; 搜索刚连接 Peripheral 的 Service当与 Peripheral 成功建立连接后，你就可以获取 Peripheral 的 Service 数据了，第一步就是搜索 Peripheral 提供的可用 Service。因为 Peripheral 对广播的数据包大小有限制，所以你可能会搜索到除了广播的 Service 之外的 其他 Service，你可以通过 discoverServices: 方法搜索 Peripheral 提供的所有的 Service。 1[peripheral discoverServices:nil]; 提示：在实际开发中，传入的参数一般不为 nil，传入 nil 会返回全部的可用 Service，为了节省电量以及一些不必要的时间浪费，通过指定一个 Service Array（包含 UUID 对象）为参数，来获取你想要了解的 Service 的信息，详情见 Explore a Peripheral’s Data Wisely. 当搜索到指定的 Service 时，Peripheral 对象会通过 peripheral:didDiscoverServices: 方法进行代理回调。CoreBluetooth 会生成一个数组用来保存 CBService 对象，你指定的 Service 就被包含在这个数组中。你可以通过实现下面这个代理方法来获取 Service 数组。 123456789- (void)peripheral:(CBPeripheral *)peripheraldidDiscoverServices:(NSError *)error &#123; for (CBService *service in peripheral.services) &#123; NSLog(@\"Discovered service %@\", service); // ... &#125; // ...&#125; 搜索 Service 的 Characteristic当你找到指定的 Service 之后，你下一步要做的就是搜索这个 Service 中提供的所有的 Characteristic，通过调用 discoverCharacteristics:forService: 方法来搜索指定的 Service 的 Characteristic。 1[peripheral discoverCharacteristics:nil forService:interestingService]; 提示：在实际开发中，第一个参数一般不传入 nil，因为你需要的 Characteristic 也许是所有 Characteristic 的一部分，为了节省电量以及一些不必要的时间浪费，通常指定一个 Characteristic Array（包含 UUID 对象）为参数，来获取你想要了解的 Characteristic 的信息。 当搜索到指定的 Characteristic 后， Peripheral 会通过 peripheral:didDiscoverCharacteristicsForService:error: 方法进行代理回调，CoreBluetooth 会创建一个包含 CBCharacteristic 对象的数组用来保存指定的 Characteristic，通过实现下面这个代理方法来打印指定的 Characteristic。 12345678910- (void)peripheral:(CBPeripheral *)peripheraldidDiscoverCharacteristicsForService:(CBService *)service error:(NSError *)error &#123; for (CBCharacteristic *characteristic in service.characteristics) &#123; NSLog(@\"Discovered characteristic %@\", characteristic); // ... &#125; // ...&#125; 检索 Characteristic 的值读取某个 Characteristic 的值当你找到 Service 指定的 Characteristic，可以通过 readValueForCharacteristic: 方法来读取这个 Characteristic 的值。 12NSLog(@\"Reading value for characteristic %@\", interestingCharacteristic);[peripheral readValueForCharacteristic:interestingCharacteristic]; 当你尝试去读取一个 Characteristic 的值时， Peripheral 会通过 peripheral:didUpdateValueForCharacteristic:error: 代理回调来返回结果，你可以通过 Characteristic 的 value 属性来得到这个值。 12345678- (void)peripheral:(CBPeripheral *)peripheraldidUpdateValueForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error &#123; NSData *data = characteristic.value; // parse the data as needed // ...&#125; 提示：并不是所有的 Characteristic 的值都是可读的，决定一个 Characteristic 的值是否可读是通过检查 Characteristic 的 Properties 属性是否包含 CBCharacteristicPropertyRead 常量来判断的。当你尝试去读取一个值不可读的 Characteristic 时，Peripheral 会通过 peripheral:didUpdateValueForCharacteristic:error: 给你返回一个合适的错误。 订阅一个 Characteristic 的值通过 readValueForCharacteristic: 方法读取一个 Characteristic 的静态值是有效的，但是，对于动态的值，就不是一个有效的方法，因为 Characteristic 的值在实时改变，比如你的心率数据。只有通过订阅才能获取实时的改变值，当你订阅一个 Characteristic 的值时，每当这个值发生改变时，你就会收到一个通知。 通过 \u0010setNotifyValue:forCharacteristic: 方法可以订阅指定 Characteristic 的值，该方法的第一个参数需要指定为 YES。 1[peripheral setNotifyValue:YES forCharacteristic:interestingCharacteristic]; 当你订阅或取消订阅一个 Characteristic 的值时，Peripheral 会通过调用 peripheral:didUpdateNotificationStateForCharacteristic:error: 方法进行代理回调，如果订阅失败了，你可以通过这个方法获取到发生错误的原因。 12345678910- (void)peripheral:(CBPeripheral *)peripheraldidUpdateNotificationStateForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error &#123; if (error) &#123; NSLog(@\"Error changing notification state: %@\", [error localizedDescription]); &#125; // ...&#125; 提示：并不是所有的 Characteristic 都提供订阅功能，决定一个 Characteristic 是否能订阅是通过检查 Characteristic 的 properties 属性是否包含CBCharacteristicPropertyNotify 或者 CBCharacteristicPropertyIndicate 常量来判断的。 写数据到 Characteristic 中有时需要写入一个数据到 Characteristic 中，比如，如果你的 APP 与数字恒温器进行交互。你或许想要给数字恒温器提供一个值，使得房间的室温能保持在这个温度左右。如果一个 Characteristic 的值是可写的，你可以通过调用 writeValue:forCharacteristic:type: 方法将一个 data 类型（NSData 对象）的值写入到 Characteristic 中。 123NSLog(@\"Writing value for characteristic %@\", interestingCharacteristic);[peripheral writeValue:dataToWrite forCharacteristic:interestingCharacteristic type:CBCharacteristicWriteWithResponse]; 当你写一个数据到 Characteristic 中时，你可以指定写入类型，上面代码中的写入类型是 CBCharacteristicWriteWithResponse ，此类型时，Peripheral 会通过 peripheral:didWriteValueForCharacteristic:error: 方法来代理回调告知你是否写入数据成功，可以实现下面这个代理方法进行错误处理。 12345678910- (void)peripheral:(CBPeripheral *)peripheraldidWriteValueForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error &#123; if (error) &#123; NSLog(@\"Error writing characteristic value: %@\", [error localizedDescription]); &#125; // ...&#125; 如果你指定写入类型为 CBCharacteristicWriteWithoutResponse 时，不能保证写入操作是否有效的执行了。这时 Peripheral 不会调用任何代理方法，如果想了解 CoreBluetooth 提供的写入类型详情，可以查阅 CBCharacteristicWriteType. 提示：有的 Characteristic 的值可能仅仅是可写的，或者不是可写的。决定 Characteristic 的值是否可写，需要通过查看 Characteristic 的 properties 属性是否包含 CBCharacteristicPropertyWriteWithoutResponse 或者CBCharacteristicPropertyWrite 常量来判断的。 参考文献1、Performing Common Central Role Tasks 结束语欢迎在本文下面留言一起交流心得… 如果本文能给你带来一定的帮助，在自己有能力的情况下，不妨赞助一下，表示对博主辛勤耕作的支持！","tags":[{"name":"BLE","slug":"BLE","permalink":"http://yoursite.com/tags/BLE/"}]},{"title":"iOS BLE 开发小记（1）","date":"2017-04-27T07:45:00.000Z","path":"2017/04/27/iOS-Bluetooth-Low-Energy-Develop-Chapter1/","text":"版权声明：本文为 muhlenXi 原创文章，欢迎转载，转载请注明来源: http://muhlenxi.com/2017/04/27/iOS-Bluetooth-Low-Energy-Develop-Chapter1 导语： 不知不觉从事 iOS 低功耗蓝牙开发也很长一段时间了，一直没时间来的及把自己关于这方面的学习和收获写下来，最近项目迭代更新上线完，有点业余时间，抓紧时间总结一下，说这是与同阶段的小伙伴们之间的交流也好，是给后来的小伙伴的掉坑经验也好。毕竟时间是挤出来的！做技术的人一般都有一个很开放的心态！ 现在我们都知道，很多智能硬件设备都已经集成了低功耗蓝牙模块，这样我们就可以开发一个 iOS 或者 Mac APP 与它们进行交互。从 macOS 10.9 和 iOS 6 以后，Mac 和 iOS 设备就支持 低功耗蓝牙技术了，我们可以通过 CoreBluetooth 这个框架与底层的各种蓝牙协议栈进行交互，比如 GATT、ATT 和 L2CAP 等。 与底层交互的过程如下图所示： 开始下文之前，我们需要了解几个概念。对蓝牙不够了解的可以看一下维基百科关于蓝牙的简介。 Bluetooth 4.0: 蓝牙 4.0 是 Bluetooth SIG 于2010年7月7日推出的新的规范，其最重要的特性是功耗低，省电！ BLE: Bluetooth low energy wireless technology,也就是低功耗无线蓝牙技术。 简单了解 CoreBluetoothBLE 是什么？BLE 是关于蓝牙4.0 的详细说明，它定义了一套用于低功耗设备之间通信的协议。而CoreBluetooth 则是对 BLE 协议栈的抽象。也就是说，它隐藏了许多底层的详细实现细节，这样对我们开发者来说，开发一个 APP 与 BLE 设备进行交互将会很便捷。 两个核心角色 Central 和 PeripheralCoreBluetooth 中最关键的两个角色就是 Central(中心) 和 Peripheral（周边）, Peripheral 一般是提供数据的一方，而 Central 一般获取 Peripheral 提供的数据然后来完成特定的任务。举个例子，一个集成 BLE 的数字室温计可能提供房间中的实时温度，我们通过 APP 就可以读取、分析和显示房间中的温度。 Peripheral 通过向空中广播数据的方式来使我们能感知到它的存在。Central 通过扫描搜索来发现周围正在广播数据的 Peripheral, 找到指定的 Peripheral 后，发送连接请求进行连接，连接成功后则与 Peripheral 进行一些数据交互， Peripheral 则会通过合适的方式对 Central 进行响应。 CoreBluetooth 简化常见蓝牙任务CoreBluetooth 对通用的蓝牙任务进行了简化处理，你在 App 中通过 CoreBluetooth 来集成 BLE 功能将会变得简单，如果你开发的 APP 遵循了 Centrals 的开发规范，CoreBluetooth 将会帮你处理与 Peripheral 的扫描、连接以及数据交互的过程，除此之外，通过 CoreBluetooth 将你的设备设置为 本地 Peripheral 也会很便捷。 iOS APP 的状态影响蓝牙的行为iOS APP 的状态也会影响蓝牙的行为，当你的 APP 在后台运行或者处于暂停状态中，蓝牙的行为将会受到影响。默认情况下，当你的 APP 在后台运行时或者处于暂停状态中，你的 APP 是不能与 BLE 进行数据通信的，也就是说，当 APP 后台运行时，你需要与 BLE 进行数据通信，你需要声明你的 APP 支持蓝牙后台运行模式，即使你声明了支持后台运行模式，蓝牙在后台运行模式下的数据处理方式也会变得不同，当开发你的 BLE APP 时，你需要注意这些不同点。 即使 APP 在后台运行时，当系统内存过低时也会杀掉 APP 的后台进程，对于 iOS 7，CoreBluetooth 支持 Central 和 Peripheral 的状态信息的保存和恢复。可以通过这个功能来实现与 BLE 设备的长期交互。 通过恰当的方式提高用户体验CoreBluetooth 框架为你的 APP 与许多常见的 BLE 设备进行交互提供了交互接口，通过合理的利用和实践将会提高用户的体验。 举个例子，当你实现 Central 或 Peripheral 的功能时，会利用设备携带的无线电广播设备（Radio）向空中广播信号，这样就会影响到电池的续航时间，因此当你设计 APP 时，需要尽可能的减少 Radio 的使用频率。 深入 CoreBluetooth重要提醒： 在 iOS 10以后，通过 CoreBluetooth 与 BLE 设备进行数据通信时，必须在项目的Info.plist文件中包含关于NSBluetoothPerpheralUsageDescription的描述,否则会导致 APP 闪退，详情见NSBluetoothPerpheralUsageDescription。 Central 和 Peripheral 的通信方式在 BLE 通信中主要包含两种角色：Central（中心）和 Peripheral（周边），基于传统的客户-服务器架构，Peripheral 通常会提供其他设备需要的数据，Central 通常利用通过 Peripheral 获取的信息来完成特定的任务，如图所示，心率监视器 提供数据给 Mac 或 iOS APP，然后来显示用户的心率数据。 Central 搜索和连接正在广播数据的 PeripheralPeripheral 以广播数据包的形式广播服务中的数据，广播数据包指的是包含 Peripheral 有用信息的一个较小数据包，比如 Peripheral 的名字和主要功能数据。比如，一个数字室温计广播的数据中可能包括当前室温，对于 BLE，广播是显示它们存在的主要方式。 如图，对于一个 Central 来说，它能够搜索和获取到它想要的 Peripheral 的广播信息。 Peripheral 是如何组织数据的连接 Peripheral 的目的就是和 Peripheral 提供的数据进行交互，在你理解这一点后，可以更好的明白 Peripheral 的数据组成结构。 Peripheral 包含一个或多个 Service(服务)和连接信号强度的有用信息。Service 可以理解成是一个完成指定功能的数据集合。举个例子，一个心率监测服务的功能就是可能就是从心率传感器中读取心率数据。 Service 是由 Characteristic（特征） 组成的，Characteristic 为 Peripheral 的 Service 提供更详细的信息，举个例子，心率服务可能包含一个测量不同体位的心率数据的 Characteristic 和一个传输心率数据的 Characteristic，下图所示的是一个心率监测设备的数据组成结构。 Central 与 Peripheral 的数据交互当 Central 与 Peripheral 建立成功的连接后，Central 可以发现 Peripheral 提供的全系列的 Service 和 Characteristic，广播数据包中的数据仅仅是可用服务的一小部分而已。 Central 可以通过读取或写入 Service Characteristic 值的方式与 Service 进行交互。你的 APP 也许需要从数字室温计中获取当前室内的温度或者设置一个温度值到数字室温计中。 如何表示 Central、Peripheral和 Peripheral 数据BLE 通信过程中涉及到的主要角色和数据处理已经简单的集成到 CoreBluetooth 框架中了。 Central 方面的对象当你通过本地 Central 与周边 Peripheral 进行交互时，你只需要调用 Central 方面的方法就可以了，除非你设置一个本地 Peripheral，并用它来响应其他的 Central 的交互请求，实际运用中，你的蓝牙处理大部分会在 Central 方面。 Local（本地） Central 和 Remote（远程） Peripheral在 Central 方面，用 CBCentralManager 对象来表示一个Local Central 设备，这个对象被用来管理 Remote Peripheral 设备（用 CBPeripheral 对象来表示），包括搜索和连接正在广播数据的 Peripheral。如图所示的是 CoreBluetooth 框架中如何表示 Local Central 和 Remote Peripheral。 用 CBService 和 CBCharacteristic 对象来表示 Peripheral 中的服务数据当你与 Remote Peripheral 进行数据交互时，你将处理它的 Service 和 Characteristic，在 CoreBluetooth 框架中，用 CBService 对象来表示 Peripheral 中的服务，同样地，用 CBCharacteristic 对象来表示 Service 中的特征。下图所示的是 Remote Peripheral 的服务特征结构树。 Peripheral 方面的对象对于 macOS 10.9 和 iOS 6， Mac 和 iOS 设备可以实现 BLE Peripheral 的功能，如为其他设备（包括 Mac，iPhone，和 iPad）提供数据。当你遵循 Peripheral 的开发规范时，就可以调用 BLE 通信的 Peripheral 方面的方法。 Local（本地） Peripheral 和 Remote（远程） Central在 Peripheral 方面，一个 Local Peripheral 可以用 CBPeripheralManager 对象来表示，这个对象被用来管理发布包含的服务，包括组织构建 Peripheral 的数据结构以及向中心设备广播数据，Peripheral Manager 也对 Remote Central的读写交互请求做出响应。如图所示的是一个 Local Peripheral 和 Remote Central。 用 CBMutableService 和 CBMutableCharacteristic 对象表示 LocalPeripheral 的数据当你设置并与 Local Peripheral 进行数据交互时，你处理的是它的可变的 Service 和 Characteristic，在 CoreBluetooth 框架中，用 CBMutableService 对象来表示 Local Peripheral 中的服务，同样地，用 CBMutableCharacteristic 对象来表示Local Peripheral 服务中的特征。下图表示的是一个 Local Peripheral 中的服务特征结构树。 参考文献1、TP40013257-CH1-SW1 2、CoreBluetoothOverview 结束语欢迎在本文下面留言一起交流心得… 如果本文能给你带来一定的帮助，在自己有能力的情况下，不妨赞助一下，表示对博主辛勤耕作的支持！","tags":[{"name":"BLE","slug":"BLE","permalink":"http://yoursite.com/tags/BLE/"}]},{"title":"Mac 的使用技巧","date":"2017-03-24T09:27:21.000Z","path":"2017/03/24/Mac/","text":"版权声明：本文为 muhlenXi 原创文章，欢迎转载，转载请注明来源: http://muhlenxi.com/2017/03/24/Mac 详情简介： 本文记录的是一些关于 Mac 的使用技巧。如果我们能深入的了解 Mac，然后熟练的使用 Mac，将会为我们的生活带来很大便捷！ 学习贵在记录和总结！ Mac 组合键 修饰键许多应用程序菜单在某些菜单选项旁边显示组合键，如 ⌘N。组合键中的符号表示特殊的键盘按键，称为修饰键。 详情请看 修饰键 符号详情 传送门。 Mac 键盘快捷键常用快捷键如下图所示，详情请看 快捷键详情 传送门。","tags":[{"name":"Mac","slug":"Mac","permalink":"http://yoursite.com/tags/Mac/"}]},{"title":"Xcode skills","date":"2017-03-21T07:25:58.000Z","path":"2017/03/21/Xcode-skills/","text":"版权声明：本文为 muhlenXi 原创文章，欢迎转载，转载请注明来源: http://muhlenxi.com/2017/03/21/Xcode-skills 详情简介： 本文记录的是一些关于开发工具的使用技巧，包括 Xcode，AppCode等。 学习贵在记录和总结！ Xcode配置篇Provisioning Profiles 文件目录如图：/用户/yangxi/资源库/MobileDevice/Provisioning Profiles/ Xcode 代码块 文件目录如图：/用户/yangxi/资源库/Developer/Xcode/UserData/CodeSnippets/ 查找项目中的中文字符串如图所示：点击放大镜并切换到 Find &gt; Regular Expression 模式下，输入 `@”[^”][\\u4E00-\\u9FA5]+[^”\\n]?”`回车即可！Swift则要去掉@符号。 导出 本地化语言配置 xiff 文件如图所示：1、选中项目后，然后点击 Editor,选择 红色方框 中的选项，然后执行步骤2。 2、填入文件名和路径，勾选要导出的语言，保存就可以了。。 技巧篇Xcode 快捷键 详细说明： Command + 0 打开或关闭 左侧边栏 Command + Option + 0 打开或关闭 右侧边栏 Command + Option + / 给函数添加注释 Command + Option + Return 打开 Xib 相关联的 ViewController Command + Shift + O 根据文件名快速切换文件 AppCode快捷键： Command + O 根据类名跳转文件 Command + Option + O 根据文件名快速跳转 Shift 双击 全局搜索 Command + E 最近编辑的文件 Shift + esc 关闭下边调试窗口","tags":[{"name":"Xcode","slug":"Xcode","permalink":"http://yoursite.com/tags/Xcode/"}]},{"title":"iOS Add PCH File","date":"2017-03-09T08:23:38.000Z","path":"2017/03/09/iOS-Add-PCH-File/","text":"版权声明：本文为 muhlenXi 原创文章，欢迎转载，转载请注明来源: http://muhlenxi.com/2017/03/09/iOS-Add-PCH-File 导语： pch 文件是APP项目中的一个头文件，该文件中的内容能被项目中的其他源文件共享和访问，是一个预编译文件。 软件版本：Xcode 8.2.1 pch文件的作用 存放一些全局的宏定义。 import 整个项目常用的头文件。 pch文件的添加步骤按顺序执行下面的4个小步骤就可以了。 创建pch头文件步骤一：在项目中 选中 Supporting Files 分类然后 Command+N ，在打开的窗口中往下滚动，选择一个 PCH File 的文件，点 Next ，输入 文件名（建议用项目名）并确定。 配置pch头文件的路径步骤二：选择TARGETS -&gt; Build Settings ，在 查找框中输入 Prefix 回车进行查找。如图： 步骤三：查找结果如下图，将 Precompile Prefix Header 的值改为 Yes ，用以缓存编译后的pch文件，提高编译效率。然后在Prefix Header 中输入 $(SRCROOT)/项目名/项目名.pch,然后回车即可。 重新编译项目步骤四：在项目中，使用 Command+B 即可。 后记感谢阅读，有什么问题可以给我留言。","tags":[{"name":"PCH File","slug":"PCH-File","permalink":"http://yoursite.com/tags/PCH-File/"}]},{"title":"iOS 跳转系统设置和打开其他 APP","date":"2017-03-07T09:04:01.000Z","path":"2017/03/07/System-Settings/","text":"版权声明：本文为 muhlenXi 原创文章，欢迎转载，转载请注明来源: http://muhlenxi.com/2017/03/07/System-Settings 导语： 在项目中，有时需要跳转到系统设置的某一个界面让用户去设置相关属性。比如一个蓝牙的APP需要检测用户是否打开了蓝牙，否则需要提醒用户并跳转到蓝牙设置界面让用户去打开蓝牙。有时需要打开自带或第三方APP去操作。比如，打开微信、支付宝等。 本文 已更新到 Xcode8.0 Swift3.0 关于适配通过一张图，我们可以查看到 2017-2-20 号用户的系统版本的分布比例，所以我们只要是配到 9.0 和 9.0 以上就可以满足大部分用户了。最新系统版本分布图传送门 跳转到系统设置由于在iOS 10 以上 和 iOS 10 以下分别是通过不同的方法打开URL的，所以我们要对系统版本做判断操作！ 举例1：跳转到 系统蓝牙设置 界面 123456789let urlStr = \"App-Prefs:root=Bluetooth\"if let url = URL(string:urlStr) &#123; if #available(iOS 10.0, *) &#123; UIApplication.shared.open(url, options: Dictionary(), completionHandler: nil) &#125; else &#123; // Fallback on earlier versions UIApplication.shared.openURL(url) &#125;&#125; 打开其他APP举例2：打开 App Store 应用 123456789let urlStr = \"itms-apps://\"if let url = URL(string:urlStr) &#123; if #available(iOS 10.0, *) &#123; UIApplication.shared.open(url, options: Dictionary(), completionHandler: nil) &#125; else &#123; // Fallback on earlier versions UIApplication.shared.openURL(url) &#125;&#125; 常用的第三方应用都定义了不同的 URL Scheme，我们通过 UIApplication.shared.open() 方法打开相应的URL，即可跳转到对应的 App 中。iOS10 以下的系统则是使用 UIApplication.shared.openURL() 方法） 举例3：打开 微信 应用 123456789let urlStr = \"weixin://\"if let url = URL(string:urlStr) &#123; if #available(iOS 10.0, *) &#123; UIApplication.shared.open(url, options: Dictionary(), completionHandler: nil) &#125; else &#123; // Fallback on earlier versions UIApplication.shared.openURL(url) &#125;&#125; 了解更多详情，请下载本文 demo 研究！本文的 Demo 在 10.2.1 和 9.3.2 的真机上都测试过，相关操作均能正常执行！ 本文demoGitHub传送 亲测可以正常使用的 URL Scheme系统设置 要跳转的设置界面 URL String 备注 WIFI App-Prefs:root=WIFI Bluetooth App-Prefs:root=Bluetooth 蜂窝移动网络 App-Prefs:root=MOBILE_DATA_SETTINGS_ID 个人热点 App-Prefs:root=INTERNET_TETHERING VPN App-Prefs:root=VPN 运营商 App-Prefs:root=Carrier 通知 App-Prefs:root=NOTIFICATIONS_ID 定位服务 App-Prefs:root=Privacy&amp;path=LOCATION 通用 App-Prefs:root=General 关于本机 App-Prefs:root=General&amp;path=About 键盘 App-Prefs:root=General&amp;path=Keyboard 辅助功能 App-Prefs:root=General&amp;path=ACCESSIBILITY 语言与地区 App-Prefs:root=General&amp;path=INTERNATIONAL 还原 App-Prefs:root=General&amp;path=Reset 墙纸 App-Prefs:root=Wallpaper Siri App-Prefs:root=SIRI 隐私 App-Prefs:root=Privacy Safari App-Prefs:root=SAFARI 音乐 App-Prefs:root=MUSIC 照相与照相机 App-Prefs:root=Photos FaceTime App-Prefs:root=FACETIME 电池电量 App-Prefs:root=BATTERY_USAGE 存储空间 App-Prefs:root=General&amp;path=STORAGE_ICLOUD_USAGE/DEVICE_STORAGE 显示与亮度 App-Prefs:root=DISPLAY 声音设置 App-Prefs:root=Sounds App Store App-Prefs:root=STORE iCloud App-Prefs:root=CASTLE 语言设置 App-Prefs:root=General&amp;path=INTERNATIONAL 自带 App 和第三方 App 要打开的APP URL Scheme Bundle Identifier 打10086 tel://10086 App Store itms-apps:// Safari http://muhlenxi.com/ Maps maps:// 备忘录 mobilenotes:// SMS sms:// Mail mailto:// iBooks ibooks:// Music music:// Videos videos:// QQ mqq:// 微信 weixin:// 淘宝 taobao:// 支付宝 alipay:// 新浪微博 sinaweibo:// 知乎 zhihu:// 后记感谢阅读，有什么问题可以给我留言。如果觉得不错的话，可以点个 Star 支持一下作者！本文不阶段更新中…","tags":[{"name":"system setting","slug":"system-setting","permalink":"http://yoursite.com/tags/system-setting/"}]},{"title":"iOS interview questions","date":"2017-02-06T03:39:33.000Z","path":"2017/02/06/Interview-questions/","text":"版权声明：本文为 muhlenXi 原创文章，欢迎转载，转载请注明来源: http://muhlenxi.com/2017/02/06/Interview-questions 面试0、如何理解 @property、@synthesizer 和 @dynamic？property(属性),用于封装对象中的数据，通过 property 可以使编译器自动为我们生成变量的 setter 和 getter 方法，同时自动向类中添加 _属性名 的实例变量。 @synthesizer 用来指定生成的实例变量的名字。 @synthesize age = _age; // 指定生成的变量名为 _age,自己实现变量的 setter 和 getter 方法时需要指定，只实现其中的一个存取方法时不需要指定。 @dynamic 告诉编译器不要自动创建属性所用的实例变量和合成 setter 和 getter 方法。 Attribute of property： @property (原子性,读写权限,内存管理语义) NSString * name; atomic : 原子性，编译器合成的方法会通过锁定机制来确保其原子性。 nonatomic: 非原子性。 readwrite: 可读可写，编译器会自动合成 setter 和 getter 方法。 readonly: 只读，编译器只会自动合成 getter 方法。 assign: 设置方法 只会执行 scalar type 的简单赋值操作。 strong: 表明一种拥有关系，设置方法设置新值时，会先保留新值，并释放旧值，然后再将新值设置上去。 weak: 表明一种非拥有关系，设置方法设置新值时，既不保留新值也不释放旧值，当属性所指的对象被摧毁时，属性值将置为 nil。 unsafe_unretained : 和 assign 相同。只不过是针对 object type 的，表明一种非拥有关系，当对象被摧毁时，属性值 不会清空。 copy: 类似 strong，不过设置方法设置新值时，不保留新值，而是将其 copy。 getter=name: 指定 getter 的方法名。 setter= name: 指定 setter 的方法名。 1、什么情况使用 weak 关键字，相比 assign 有什么不同？什么情况使用 weak 关键字？ 1、在 ARC 中，在有可能循环引用的时候，往往要通过让其中一端使用 weak 来解决，比如 Delegate 属性。 2、自身已经对它进行一次强应用，没有必要再强引用一次，此时也会用 weak，自定义 IBOutlet 控件属性一般也使用 weak；当然也可以使用 strong。 不同点： 1、weak 表明该属性定义了一种“非拥有关系”。为这种属性设置新值时，设置方法既不保留新值，也不释放旧值。此特质和 assign 类似，然而当属性所指的对象遭受到摧毁时，属性值也会清空。而 assign 的设置方法只会执行针对纯量类型（如CGFloat、NSInteger）的简单赋值操作。 2、assign 可以用非 OC 对象，而 weak 必须用于 OC 对象。 2、如何理解 Objective-C 的消息派发机制？3、如何理解 Swift 中的方法派发机制？Swift 的方法派发机制主要有3种，第一种是 Direct Dispatch，第二种是 Table Dispatch，第三种是 Message Dispatch。 派发规则： 1-值类型永远使用 Direct Dispatch。 2-在 protocol 和 class 的定义中声明的方法使用 table dispatch。 3-在 protocol 和 class 的 extension 中定义的方法使用 direct dispatch。 修改方法派发规则的 modifiers: 如果你的方法需要被 Objective-C 运行时识别，需要用 dynamic 将方法的派发方式改为 message dispatch，此外还必须 import Foundation，它包含了 Objective-C 运行时的核心组件。 @objc仅仅可以让一个 Swift 方法被 Objective-C 运行时识别和访问，但不会修改该方法的派发方式。 final 用于把方法的派发方式改为 direct dispatch。 @nonobjc 仅仅让一个方法对 Objective-C 运行时不可见，但不会修改方法的派发方式。 详情传送门","tags":[{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/tags/面试题/"}]},{"title":"优雅 编程","date":"2017-02-06T03:14:27.000Z","path":"2017/02/06/Elegant-programming/","text":"版权声明：本文为 muhlenXi 原创文章，欢迎转载，转载请注明来源: http://muhlenxi.com/2017/02/06/Elegant-programming 前言 好的代码有一些共同的特性：简单、自我解释、优秀的组织、良好的文档、良好的命名、优秀的设计以及可以久经考验。 #### 命名规范【0】属性的参数应该按照下面的顺序排列：原子性，读写和内存管理。1@property (nonatomic, readwrite, copy) NSString *name; 【1】如果方法表示让对象执行一个动作，使用动词打头来命名。如用 logIn 表示登陆。 【2】方法中不要用 with 来连接两个参数。 1- (instancetype)initWithName:(NSString *)name age:(NSUInteger)age; 通常是使用 withA:andB: 这种命名，用来表示方法执行了两个相对独立的操作,但是尽量不要使用，应遵守单一原则，拆分为两个独立的方法。 1- (BOOL)openFile:(NSString *)fullPath withApplication:(NSString *)appName andDeactivate:(BOOL)flag;","tags":[{"name":"优雅编程","slug":"优雅编程","permalink":"http://yoursite.com/tags/优雅编程/"}]},{"title":"大话设计模式---读书笔记","date":"2017-01-10T06:44:53.000Z","path":"2017/01/10/Dahua-Design-Pattern/","text":"版权声明：本文为 muhlenXi 原创文章，欢迎转载，转载请注明来源: http://muhlenxi.com/2017/01/10/Dahua-Design-Pattern 前言： 大话设计模式-设计模式的趣味解读，面向对象的深入剖析。在诙谐与温馨中做一次面向对象编程思维的体操。 对于程序猿来讲，精彩的代码时如何想出来的，要比看到精彩的代码更加令人期待！ 笔记内容 如果想成为一名更优秀的软件设计师，了解优秀软件设计的演变过程比学习优秀设计本身更有价值，因为设计的演变过程中蕴藏着大智慧。 通过封装、继承、多态把程序的耦合度降低。 用设计模式使得程序更加灵活，容易修改，并且易于复用。 让业务逻辑和界面逻辑分开，让他们之间的耦合度下降。只有分离开，才可以达到容易维护或扩展。 简单工厂模式简单工厂模式，考虑用一个单独的类来做这个创造实例的过程。这就是工厂。 UML类图类图分三层，第一层显示类的名称，如果是抽象类，则就用斜体表示。第二层是类的特性，通常就是字段和属性。第三层是类的操作，通常是方法或行为。“+”表示public，“-”表示private，“#”表示protected。 接口图的顶端有《interface》显示。第一行是接口名称，第二行是接口方法。接口还有一种棒棒糖表示法。 继承关系用空心三角形+实线来表示。 实现接口用空心三角形+虚线来表示。 当一个类知道另一个类时，可以用关联。关联关系用实线箭头表示。 聚合表示一种弱的拥有关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分。比如雁群和大雁的关系。聚合关系用空心的菱形+实线箭头表示。 合成（Composition）是一种强的拥有关系，体现了严格的部分与整体的关系。部分和整体的生命周期一样。如鸟和翅膀。用实心的菱形+实线箭头表示。 依赖关系（Dependency）用虚线箭头表示。 面向对象的编程，并不是类越多越好，类的划分是为了封装，但分类的基础是抽象，具有相同属性和功能的对象的抽象集合才是类。 策略模式策略模式（Strategy）：它定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的客户。 单一职责原则（SRP）：就一个类而言，应该仅有一个引起它变化的原因。 如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭受意想不到的破坏！ 开放-封闭原则，是说软件实体（类、模块。函数等等）应该可以扩展，但是不可修改。 对于扩展是开放的（Open for extension），对于更改是封闭的（Closed for modification）。 在我们最初编写代码时，假设变化不会发生。当变化发生时，我们就创建抽象来隔离以后发生的同类变化。 面对需求，对程序的改动是通过增加新代码进行的，而不是更改现有的代码。 我们希望的是在开发工作展开不久就知道可能发生的变化。查明可能发生的变化所等待的时间越长，要创建正确的抽象就越困难。 开放-封闭原则是面向对象设计的核心所在。遵循这个原则可以带来面向对象技术所声称的巨大好处，也就是可维护、可扩展、可复用、灵活性好。开发人员应该仅对程序中呈现出频繁变化的那些部分做出抽象，然而，对于应用程序中的每个部分都刻意地进行抽象同样不是一个好主意。拒绝不成熟的抽象和抽象本身一样重要。 依赖倒转原则，抽象不应该依赖细节，细节应该依赖于抽象。也就是要针对接口编程，而不是对实现编程。 依赖倒转原则： A、高层模块不应该依赖低层模块。两个都应该依赖抽象。 B、抽象不应该依赖细节。细节应该依赖抽象。 里氏代换原则（LSP）:子类型必须能够替换掉它们的父类型。 依赖倒转其实可以说是面向对象设计的标志。用哪种语言来编写不重要，如果编写时考虑的都是如何针对抽象编程而不是针对细节编程，即程序中所有依赖关系都是终止于抽象类或者接口，那就是面向对象的设计，反之那就是过程化的设计了。 装饰模式装饰模式（Decorator），动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活。 Component是定义一个对象的接口，可以给这些对象动态地添加职责。ConcreteComponent是定义一个具体的对象，也可以给这个对象添加一些职责。Decorator，装饰抽象类，继承了Component，从外类来扩展Component类的功能，但对于Component来说，是无需知道Decorator的存在的，至于ConcreteDecorator就是具体的装饰对象，起到了给Component添加职责的功能。 装饰模式是利用SetComponent来对对象进行包装的，这样每个装饰对象的实现就和如何使用这个对象分开了，每个装饰对象只关心自己的功能，不需要关心如何被添加到对象链当中。 如果只有一个ConcreteComponent类而没有抽象的Component类，那么Decorator类可以是ConcreteComponent类的一个子类。同样道理，如果只有一个ConcreteDecorator类，那么就没有必要新建一个单独的Decorator类，而可以把Decorator和ConcreteDecorator的责任合并成一个类。 代理模式代理模式，为其他对象提供一种代理以控制对这个对象的访问。 远程代理，也就是为一个对象在不同的地址空间提供局部代表，这样可以隐藏一个对象存在于不同地址空间的事实。 虚拟代理，是根据需要创建开销很大的对象。通过它来存放实例化需要很长时间的真实对象。 安全代理，用来控制真实对象访问时的权限。 智能指引，是指当调用真实的对象时，代理处理另外一些事。 工厂方法模式简单工厂模式的最大优点在于工厂类中包含了必要的逻辑判断，根据客户端的选择条件动态实例化相关的类，对于客户端来说，去除了与具体产品的依赖。 工厂方法模式（Factory Method），定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。 原型模式原型模式（prototype）,用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象。 原型模式其实就是从一个对象再创建另外一个可定制的对象，而且不需要知道任何创建的额细节。 浅复制，被复制对象的所有变量都含有与原来对象相同的值，而所有的对其他对象的引用都仍然指向原来的对象。 深复制，把引用对象的变量指向复制过的新对象，而不是原有被引用的对象。 模板方法模式模板方法模式，定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些步骤。 当我们要完成在某一细节层次一致的一个过程或一系列步骤，但其个别步骤在更详细的层次上的实现可能不同时，我们通常考虑用模板方法模式来处理。 模板方法模式是通过把不变行为搬移到超类，去除子类中的重复代码来体现它的优势。模板方法模式就是提供了一个很好的代码复用平台。 迪米特法则也叫最少知识原则迪米特法则（LOD），如果两个类不必彼此通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。 迪米特法则其根本思想是强调了类之间的松耦合，类之间的耦合越弱，越利于复用，一个处于弱耦合的类被修改，不会对有关系的类造成波及。在类的结构设计上，每一个类都应当降低成员的访问权限。 外观模式外观模式（Facade），为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。 外观模式使用场景如下： 在设计初期阶段，应该有意识的将不同的两个层分离，层与层之前建立外观Facade，这样可以为复杂的子系统提供简单的接口，使得耦合大大降低。 在开发阶段，子系统往往因为不断的重构演化而变得越来越复杂，大多数的模式使用时也会产生很多很小的类，这本是好事，但也给外部调用它们的用户程序带来了使用上的困难，增加外观Facade可以提供一个简单的接口，减少它们之间的依赖。 在维护一个遗留的大型系统时，可能这个系统已经非常难以维护和扩展了。但因为它包含非常重要的功能，新的需求开发必须依赖它。此时可以为新系统开发一个外观Facade类，来提供设计比较清晰的接口（粗糙或高度复杂的遗留代码的），让新系统与Facade对象交互，Facade与遗留代码交互所有复杂工作。 建造者模式建造者模式（Build），将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 建造者模式是在当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时适用的模式。 观察者模式观察者模式又叫发布-订阅（Publish/Subscribe）模式。 观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己。 将一个系统分割成一系列相互协作的类有一个很不好的副作用，那就是需要维护相关对象间的一致性。我们不希望为了维持一致性而使各类紧密耦合、这样会给维护、扩展和重用都带来不便。 抽象工厂模式抽象工厂模式（Abstract Factory），提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。","tags":[{"name":"大话设计模式","slug":"大话设计模式","permalink":"http://yoursite.com/tags/大话设计模式/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/tags/读书笔记/"}]},{"title":"Git学习笔记","date":"2016-12-15T02:20:19.000Z","path":"2016/12/15/About-Git/","text":"版权声明：本文为 muhlenXi 原创文章，欢迎转载，转载请注明来源: http://muhlenxi.com/2016/12/15/About-Git 导语：Git 是目前世界上最先进的分布式版本控制系统。 要有这样的理念：活到老，学到老，不要停止，一直保持前进！ 常见 git 本地仓库操作创建版本库 (repository) 并初始化mkdir zhangsan //创建zhangsan文件夹 cd zhangsan pwd //打印当前路径 git init //初始化git仓库 ls -ah //查看隐藏文件 Unix 的哲学是“没有消息就是好消息”，没有消息说明操作成功。 添加文件到版本库touch readme.text //创建readme文件 git add readme.text //添加文件 git commit -m &quot;这是标记信息&quot; //提交文件 git status //查看工作区的状态 git diff //查看修改了哪些内容 git log //查看历史提交日志记录 版本回退git reset --hard HEAD^ //回退到上一版本 git reset --hard commit_id(版本号) //回退到某一版本 git reflog //查看命令历史 cat readme.text //查看文件内容 撤销修改【场景1】：当你改乱了工作区的某个文件的内容，想直接丢弃工作区的修改时，用命令 git checkout -- filename。 【场景2】：当你不但改乱了工作区某个文件的内容，还添加到了暂存区，想丢弃修改，分两步走，第一步用命令 git reset HEAD file ,就回到了【场景1】，第二步按【场景1】的操作。 【场景3】：已经提交了不合适的修改到版本库时，想要撤销本次修改，参考 版本回退，不过前提是还没有推送到远程库。 删除文件git rm readme.text //只删除工作区中的文件 git rm readme.text //从版本库中删除该文件 git commit -m &quot;remove readme.text&quot; //恢复误删的文件，前提是没有从版本库中删除该文件 git checkout -- readme.text git远程仓库操作 本地 Git 仓库和 GitHub 仓库之间的传输是通过 ssh 加密的，所以要设置 ssh。 【1】创建 SSHkey ssh-keygen -t rsa -C &quot;你注册的邮箱地址&quot; 提示：1、创建完成后，会在主目录中生成 .ssh 目录，里面有 id_rsa（秘钥）和id_rsa.pub（公钥）。 2、cd 到 .ssh 目录下，用命令 cat id_rsa.pub 查看公钥内容。 【2】登陆 GitHub，打开 Account setting , 在 SSH keys 界面 粘贴公钥里的内容。 关联远程仓库 在 GitHub 上创建一个新的仓库后，然后可以进行如下操作。 git remote add origin 仓库地址 //关联远程仓库 git push -u origin master //第一次推送Master分支的所有内容 git push origin master //以后推送最新修改 git clone 仓库地址 //克隆远程仓库到本地 git 分支管理分支操作git branch //查看分支 git branch 分支名 //创建分支 git checkout 分支名 //切换分支 git checkout -b 分支名 //创建并切换分支 git merge 分支名 //合并某分支到当前分支 git branch -d 分支名 //删除分支 注意：合并分支时，如有冲突，需要先解决冲突，然后再add和commit。 git log --graph //查看分支合并图 合并分支时，如果有可能，git会用 Fast forward 模式，在该模式下，删除分支后，会丢失分支信息。 强制禁用 Fast forward 模式，git会在merge时生成一个新的commit，这样从分支历史上就可以看出分支信息。 git merge --no-ff -m &quot;提示标记&quot; 分支名 分支策略 1、首先， master 分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活； 2、新建分支 dev，干活都是在 dev 分支上，也就是说 dev 分支是不稳定的，当发布新版本的时候，才把dev 分支合并到 master 上，在 master 上发布新版本。 3、不同的人干活，都新建 自己的分支，然后时不时往 dev 分支上合并就可以了。 通过 bug 分支来修复 buggit stash //保存当前工作现场 git stash list //查看工作现场保存记录 git stash apply //恢复工作现场 git stash drop //删除stash内容 git stash pop //恢复工作现场的同时删除stash内容 git stash apply stash@{0} //恢复指定的stash 每开发一个新功能的时候，最好新建一个功能分支！ git branch -D 分支名 //强行删除一个未合并的分支 标签的操作git tag v1.0 //给最新的commit版本打一个标签，v1.0为标签名 git tag //查看所有的标签 git log --pretty=oneline --abbrev-commit //查看历史提交的commit id git tag 标签名 commit_id //给指定的commit打标签 git show 标签名 //查看标签信息 git tag -a 标签名 -m “说明文字” commit_id //打带说明文字的标签 git tag -s 标签名 -m “说明文字” commit_id //打用PGP签名标签 git tag -d 标签名 //删除标签 git push origin 标签名 //推送某个标签到远程仓库 git push origin --tags //推送全部标签到远程仓库 git push origin :refs/tags/标签名 //删除远程标签，需先删除本地标签 多人协作工作模式 1、首先，试着用 git push origin 分支名 推送自己的修改； 2、如果推送失败，则因为远程分支比你的本地分支要新，需要先用 git pull 试图合并。 3、如果合并有冲突，则解决冲突，并在本地提交； 4、没有冲突或解决掉冲突后，再用 git push origin 分支名 推送，就能推送成功。 注意：如果 git pull 提示 “no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令 git branch --set-upstream 远程分支名 本地分支名 关于 GitHub 在 GitHub 上，可以任意 Fork 开源仓库； 自己拥有 Fork 后的仓库的读写权限 可以推送 pull request 给 开源项目 来贡献代码 配置别名【1】配置命令： git config --global alias.st status git config --global alias.co checkout git config --global alias.cm commit git config --global alias.br branch git config --global alias.last &apos;log -1&apos; //显示最近一次的提交 --global 参数是全局参数，也就是这些命令在这台电脑的所有 Git 仓库下都有用。 【2】配置文件的路径 每个仓库的Git配置文件都放在.git/config文件中： 用命令 cat .git/config 可以查看。 别名就在 [alias] 后面，要删除别名，直接把对应的行删掉即可。 当前用户的 Git 配置文件放在用户主目录下的一个隐藏文件 .gitconfig 中： 用命令 cat .gitconfig 可以查看。","tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"},{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"程序员修炼之道-读书笔记 ","date":"2016-11-17T01:53:15.000Z","path":"2016/11/17/The-Pragmatic-Programmer/","text":"版权声明：本文为 muhlenXi 原创文章，欢迎转载，转载请注明来源: http://muhlenxi.com/2016/11/17/The-Pragmatic-Programmer 前言： 程序员修炼之道-从小工到专家，是一本初学者、中高级开发人员或软件项目经理都可以读的书。本书涵盖的主题从个人责任、职业发展、直到用于使代码保持灵活、并且易于改编和复用的各种框架技术，利用许多富有娱乐性的奇闻轶事、有思想的例子及有趣的类比，全面阐述了软件开发的许多不同方面的最佳实践和重大陷阱。 学习贵在记录和总结收获！点击阅读全文了解更多！ 正文何为经典书或上品？ 经典书指的是选材精良、内容精炼、讲述生动、外延丰盛、表现手法体贴入微的读品，它们会成为读者的知识和经验库的重要组成部分，并且拥有从不断重读中汲取养分的空间。 注重实效的程序员应该不断学习！ 能不能让正确的原则指导正确的行动本身，其实就是区分是否是高手的一个显著标志。 注重实效不应该局限于任何特定的技术，而是应该拥有足够广博的背静和经验基础。 你的背景源于对计算机科学的基本原理的理解。你的经验来自广泛的实际项目。理论与实践的结合使你强大起来。 注重实效的程序员的特征 1、早期的采纳者/快速的改编者。 2、好奇。 3、批判的思考者。 4、有现实感。 5、多才多艺。 Notice 1: 关心你的技艺 Care About Your Craft 如果你不在乎能否漂亮地开发出软件，你又为何要耗费生命去开发软件呢？ Notice 2: 思考你的工作 Think!About Your Work 关掉自动驾驶仪，接管操作。不断地批评和评估你的工作。 1、我的源码让猫吃了Notice 3: 提供各种选择，而不是蹩脚的借口。 Provide Options,Don’t Make Lame Excuses 要提供各种选择，而不是找借口。不要说事情做不到；说明能够做什么。 2、软件的熵Notice 4: 不要容忍破窗户 Don’t Live with Broken Windows 当你看到糟糕的设计、错误的决策和糟糕的代码时，修正它们。 3、石头汤与煮青蛙Notice 5: 做变化的催化剂 Be a Catalyst for Change 你不能强迫人们改变。相反你可以向他们展示未来可能会怎么样，并帮助他们参与对未来的创造。 Notice 6: 记住大图景 Remember the Big Picture 不要太过专注细节，以致忘了查看你周围正在发生什么。 4、足够好的软件Notice 7: 使质量成为需求问题 Make Quality a Requirements Issue 让你的用户参与确定项目真正的质量需求。 5、你的知识财产Notice 8: 定期为你的知识资产投资 Invest Regularly in Your Knowledge Portfolio 让学习成为习惯。 Notice 9: 批判的分析你读到的和听到的 Critically Analyze What You Read and Hear 不要被供应商、媒体炒作、或教条左右。要按照你自己的看法和你的项目的情况去对信息进行分析。 经营资产的方法： 1、定期投资 2、多元化 3、管理风险。 4、低买高卖。 5、重新评估和平衡。 6、交流Notice 10: 你说什么和你怎么说同样重要 It‘s Both What You Say and the Way You Say It 如果你不能有效地向他人传达你了不起的想法，这些想法就毫无用处。 总结： 知道你想要说什么。 不断反问自己：“这是否讲清了我要说的所有内容？” 了解你的听众。 你想让他们学到什么？ 他们对你讲的什么感兴趣？ 他们有多富有经验？ 他们想要多少细节？ 你想让谁拥有这些信息？ 你如何促使他们听你说话？ 选择时机。 选择风格。 让文档美观。 让听众参与。 做倾听者。 回复他人。 7、重复的危害Notice 11: 不要重复你自己 DRY - Don’t Repeat Yourself 系统中的每一项知识都必须具有单一、无歧义、权威的表示。 Notice 12: 让复用变得容易。 Make It Easy to Reuse 如果复用很容易，人们就会去复用。创造一个支持复用的环境。 8、正交性Notice 13: 消除无关事物之间的影响。 Eliminate Effects Between Unrelated Things 设计自足、独立、并具有单一、良好定义的目的的组件。 注意事项: 让你的代码保持解耦 避免使用全局数据 避免编写相似的函数。 9、可撤销性Notice 14: 不存在最终决策。 There Are No Final Decisions 没有决策时浇筑在石头上的。相反，要把每项决策都视为写在沙滩上的，并为变化做好计划。 10、曳光弹Notice 15: 用曳光弹找到目标。 Use Tracer Bullets to Find the Target 曳光弹能通过试验各种事物并检查它们离目标有多远来让你追踪目标。 优点： 1、用户能够及早看到能工作的东西。 2、开发者构建了一个他们能在其中工作的结构。 3、你有了一个集成平台。 4、你有了可用于演示的东西。 5、你将更能够感觉到工作进展。 11、原型与便签Notice 16: 为了学习而制作模型。 Prototype to Learn 原型制作是一种学习经验。其价值并不在于所产生的代码，而在于所学到的经验教训。 应制作原型的事物：架构、已有系统中的新功能、外部数据的结构或内容、第三方工具或组件、性能问题、用户界面设计。 12、领域语言 语言的界限就是一个人的世界的界限。 — 维特根斯坦 Notice 17: 靠近问题领域编程 Program Close to the Problem domain 用你的用户的语言进行设计和编码。 13、估算Notice 18: 估算，以避免意外 Estimate to Avoid Surprises 在着手之前先进行估算。你将提前发现潜在的问题。 Notice 19: 通过代码对进度表进行迭代 Iterate the Schedule with the code 用你在进行实现时获得的经验提炼项目的时间标度。 14、纯文本的威力Notice 20: 用纯文本保存知识 Keep Knowledge in Plain Text 纯文本不会过时。它能够帮助你有效利用你的工作，并简化调试和测试。 15、shell游戏Notice 21: 利用命令shell的力量 Use the Power of Command Shells 当图形界面无能为力时使用shell。 16、强力编辑Notice 22: 用好一种编辑器 Use a Single Editor Well 编辑器应该是你的手的延伸；确保你的编辑器是可配置、可扩展和可编程的。 17、源码控制Notice 23: 总是使用源码控制 Always User Source Code Control 源码控制是你的工作的时间机器—你能够回到过去。 18、调试Notice 24: 要修正问题，而不是发出指责 Fix the Problem，Not the Blame 是你的过错还是别人的过错，并不是真的很有关系—它仍然是你的问题，它仍然需要修正。 Notice 25: 不要恐慌 Don’t Panic 做一次深呼吸，思考什么可能是bug的原因。 Notice 26: “Select”没有问题 “Select” Isn’t Broken 在OS或编译器、甚至是第三方产品或库中很少发现bug。bug很可能是在应用中。 Notice 27: 不要假定，要证明 Don’t Assume it - Prove It 在实际环境中—使用真正的数据和边界条件—证明你的假定。 19、文本操纵Notice 28: 学习一种文本操作语言 Learn a Text Manipulation Language 你用每天的很大一部分时间处理文本，为什么不让计算机替你完成部分工作呢？ 20、代码生成器Notice 29: 编写能编写代码的代码 Write Code That Writes Code 代码生成器能提高你的生产率，并有助于避免重复。 Notice 30: 你不可能写出完美的软件 You Can’t Write Perfect Software 软件不可能完美。保护你的代码和用户，使它（他）们免于能够遇见的错误。 21、按合约设计 （Design By Contract）Notice 31: 通过合约进行设计 Design with contracts 使用合约建立文档，并检验代码所做的事情正好是它声明要做的。 22、死程序不说谎Notice 32: 早崩溃 Crash Early 死程序造成的危害通常比有问题的程序要小的多。 23、断言式编程Notice 33: 用断言避免不可能发生的事情 If It Can’t Happen,Use Assertions to Ensure That It Won’t 断言验证你的各种假设。在一个不确定的世界里，用断言保护你的代码。 24、何时使用异常Notice 34: 将异常用于异常的问题 Use Exceptions for Exceptional Problems 异常可能会遭受经典的意大利面条式代码的所有可读性和可维护问题的折磨。将异常保留给异常的事物。 25、怎样配平资源Notice 35: 要有始有终 Finish What You Start 只要可能，分配某资源的例程或对象也应该负责解除其分配。 26、解耦与得墨忒耳法则Notice 36: 使模块之间的耦合减至最少 Minimize Coupling Between Modules 通过编写“羞怯的”代码并应用得墨忒尔法则来避免耦合。 27、元程序设计Notice 37: 要配置，不要集成 Configure,Don’t Integrate 要将应用的各种技术选择实现为配置选项，而不是通过集成或工程方法实现。 \u0010 Notice 38: 将抽象放进代码，细节放进元数据 Put Abstractions in Code,Details in Metadata 为一般情况编程，将细节放在被编译的代码库之外。 28、时间耦合Notice 39: 分析工作流，以改善并发性 Analyze Workflow to Improve Concurrency 利用你的用户的工作流中的并发性。 Notice 40: 用服务进行设计 Design Using Services 根据服务—独立的、在良好定义、一致的接口之后的并发对象—进行设计。 Notice 41: 总是为并发进行设计 Always Design for Concurrency 容许并发，你将会设计出更整洁、具有更少假定的接口。 29、它只是视图Notice 42: 使视图与模型分离 Separate Views from Models 要根据模型和视图设计你的应用，从而以低廉的代码获取灵活性。 30、黑板Notice 43: 用黑板协调工作流 Use Blackboards to Coordinate Workflow 用黑板协调完全不同的事实和因素，同时又使各参与方保持独立和隔离。 31、靠巧合编程Notice 44: 不要靠巧合编程 Don’t Program by Coincidence 只依靠可靠的事物。注意偶发的复杂性，不要把幸运的巧合与有目的的计划混为一谈。 32、算法速率Notice 45: 估算你的算法的阶 Estimate the Order of Your Algorithms 在你编写代码之前，先大致估算事情需要多长时间。 Notice 46: 测试你的估算 Test Your Estimates 对算法的数学分析并不会告诉你每一件事情。在你的代码的目标环境中测定它的速度。 33、重构重写、重做和重新架构代码合起来，称为重构（refactoring）。 Notice 47: 早重构，常重构 Refactor Early，Refactor often 就和你会在花园中除草、并重新布置一样，在需要时对代码进行重写、重做和重新架构。要铲除问题的根源。 34、易于测试的代码Notice 48: 为测试而设计 Design to Test 在你还没有编写代码时就开始思考测试问题。 Notice 49: 测试你的软件，否则你的用户就得测试 Test Your Software,or Your Users Will 无情的测试。不要让你的用户为你查找bug。 35、易于测试的代码Notice 50: 不要使用你不理解的向导代码 Don’t Use Wizard Code You Don’t Understand 向导可以生成大量代码。在你把他们合并进你的项目之前，确保你理解全部这些代码。 36、需求之坑Notice 51: 不要搜集需求—挖掘它们 Don’t Gather Requirements - Dig for Them 需求很少存在于表面上。他们深深地埋藏在层层假定、误解和政治手段的下面。 Notice 52: 与用户一同工作，以像用户一样思考 Work with a User to Think Like a User 要了解系统实际上将如何被使用，这是最好的方法。 Notice 53: 抽象比细节活的更长久 Abstractions Live Longer than Details “投资”于抽象，而不是实现。抽象能在来自不同的实现和新技术的变化的“攻击”之下存活下去。 Notice 54: 使用项目词汇表 Use a Project Glossary 创建并维护项目中使用的专用术语和词汇的单一信息源。 37、解开不可能解开的谜题Notice 55: 不要在盒子外面思考—要找到盒子 Don’t Think Outside the Box - Find the Box 在遇到不可能解决的问题时，要确定真正的约束。问问你自己：“它必须以这种方式完成么？它真的必须完成吗？” 38、等你准备好Notice 56: 倾听反复出现的疑虑—等你准备好再开始 Listen to Nagging Doubts - Start When You’re Ready 你的一生都在积累经验。不要忽视反复出现的疑虑。 39、规范陷阱Notice 57: 对有些事情“做”胜于“描述”。 Some Things Are Better Done than Described 不要掉进规范的螺旋—在某个时刻，你需要开始编码。 40、圆圈与箭头Notice 58: 不要做形式方法的奴隶 Don’t Be a Slave to Formal Methods 如果你没有把某项技术放进你的开发实践和能力的语境中，不要盲目地采用它。 Notice 59: 昂贵的工具不一定能制造出更好的设计 Expensive Tools Do Not Produce Better Designs 小心供应商的炒作，行业教条，以及价格标签的诱惑。要根据工具的价值判断它们。 41、注重实效的团队Notice 60: 围绕功能、而不是工作职务进行组织 Organize Around Functionality,Not Job Functions 不要把设计师和编码员分开，也不要把测试员与数据建模员分开。按照你构建代码的方式构建团队。 42、无处不在的自动化Notice 61: 不要使用手工流程 Don’t Use Manual Procedures shell脚本或批文件会一次次地以同一顺序执行同样的指令。 43、无情的测试Notice 62: 早测试，常测试，自动测试。 Test Early，Test More，Test Automatically 与呆在书架上的测试计划相比，每次构建时运行的测试要有效得多。 Notice 63: 要通过全部测试，编码才算完成。 Coding Ain’t Done Til All the Tests Run 就是这样 Notice 64: 通过蓄意破坏测试你的测试。 User Saboteurs to Test Your Testing 在单独的软件副本上故意引入bug，以检验测试能否抓住它们。 Notice 65: 测试状态覆盖。而不是代码覆盖。 Test State Coverage，Not Code Coverage 确定并测试重要的程序状态。只是测试代码行是不够的。 Notice 66: 一个bug只抓住一次。 Find Bugs Once 一旦测试员找到一个bug，这应该是测试员最后一次找到它。此后自动测试应该对其进行检查。 44、全都是写Notice 67: 把英语当作又一种编程语言。 Treat English as Just Another Programming Language 像你编写代码一样编写文档：遵守DRY原则、使用元数据、MVC、自动生成等等 。 Notice 68: 把文档建在里面，不要拴在外面。 Build Documentation In，Don’t Bolt It On 与代码分离的文档不太可能被修正和更新。 45、极大的期望Notice 69: 温和地超出用户的期望。 Gently Exceed Your Users’ Expectations 要理解你的用户的期望，然后给他们的东西要多那么一点。 46、傲慢与偏见Notice 70: 在你的作品上签名。 Sign Your Work 过去时代的手艺人在能为他们的作品上签名而自豪 。你也应该如此。 结束语读完一本书不难。难得就是在生活中去践行书中的方法论，去验证是否说的有道理，希望自己在以后的生活和学习中能够慢一些、收获多一些。2017！加油！","tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/tags/读书笔记/"},{"name":"程序员修炼之道","slug":"程序员修炼之道","permalink":"http://yoursite.com/tags/程序员修炼之道/"}]},{"title":"关于集成极光推送","date":"2016-11-11T09:40:09.000Z","path":"2016/11/11/Jiguang-Push/","text":"版权声明：本文为 muhlenXi 原创文章，欢迎转载，转载请注明来源: http://muhlenxi.com/2016/11/11/Jiguang-Push 前言： 通过极光推送服务，主动及时地向您的用户发起交互，向其发送聊天消息、日程提醒、活动预告、进度提示、动态更新等。 学习贵在记录和总结收获！点击阅读全文了解更多！ 基础篇（集成步骤） 1、生成CSR文件 钥匙串访问 -&gt; 证书助理 -&gt; 从证书颁发机构请求证书… 2、在 苹果开发者网站 登录后，创建 App ID Account -&gt; Certificates,Identifiers&amp;Profiles -&gt; App IDs -&gt; + 3、生成远程推送的测试证书 测试证书： Development -&gt; Apple Push Notification service SSL (Sandbox) 4、生成远程推送的生产证书 生产证书： Production -&gt; Apple Push Notification service SSL (Sandbox &amp; Production) 创建好后分别下载到电脑上，然后双击运行。 5、添加真机 Device （添加过的可以忽略） 6、创建配置文件 Provisioning Profiles 创建好后下载到电脑上，然后双击运行。 7、将推送证书导出并生成 .p12 文件 Apple Development IOS Push Services: 你项目的Bundle identifier 就是在测试环境下的推送证书。 Apple Push Services: 你项目的Bundle identifier 就是生产环境下的证书. 8、在极光开发者中心创建项目并上传刚生成的两个p12文件. 9、下载极光 SDK 并配置项目。 具体配置看iOS SDK 集成指南 提高篇感谢您的阅读，一起学习，一起成长，加油！","tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://yoursite.com/tags/Objective-C/"},{"name":"极光推送","slug":"极光推送","permalink":"http://yoursite.com/tags/极光推送/"}]},{"title":"Swift开发者必备Tips - 学习笔记","date":"2016-10-26T04:08:31.000Z","path":"2016/10/26/Swift-Tips/","text":"版权声明：本文为 muhlenXi 原创文章，欢迎转载，转载请注明来源: http://muhlenxi.com/2016/10/26/Swift-Tips 前言： 这本书是王巍的关于Swift语言的知识点的集合，是作者学习和实践Swift的一些心得，作者以一个个的小技巧和知识点的形式，编写成了这本书，是中级开发人员的Swift进阶读本，该书涵盖了一个中高级开发人员需要知道的Swift语言的方方面面。 点击阅读全文来了解一下详情吧。 正文柯里化（Currying）就是把接收多个参数的方法进行一些变形，使其更加灵活的方法。 Swift的mutating关键字修饰方法是为了能在该方法中修改struct或enum的变量。 @autoclosure做的事情就是把一句表达式自动地封装成一个闭包（closure） ??操作符可以快速地对nil进行条件判断，当??左侧的值为nil时返回右侧的值，否则返回左侧的值。 1234let level:Int? = nillet startLevel = 1let currentLevel = level ?? startLevelprint(currentLevel) //output 1 Swift中我们可以定义一个接受函数作为参数的函数，而在调用时，使用闭包的方式来传递这个参数是常见手段。 函数中的参数（是函数）在异步线程中操作的时候，我们需要在block的类型前加上@escaping标记来表明这个闭包是会逃逸出该方法的。","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/tags/学习笔记/"},{"name":"Swift开发者必备Tips","slug":"Swift开发者必备Tips","permalink":"http://yoursite.com/tags/Swift开发者必备Tips/"}]},{"title":"关于 GCD","date":"2016-10-09T02:02:59.000Z","path":"2016/10/09/GCD/","text":"版权声明：本文为 muhlenXi 原创文章，欢迎转载，转载请注明来源: http://muhlenxi.com/2016/10/09/GCD 前言： GCD 是 Grand Central Dispatch 的缩写。GCD 是一个底层框架，它可以通过操作系统来管理并发和异步执行任务。 学习贵在记录和总结收获！点击阅读全文了解更多！ 正文在主线程中执行1234dispatch_async(dispatch_get_main_queue(), ^&#123; NSLog(@\"主线程执行\");&#125;); 异步线程执行1234dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; NSLog(@\"异步执行\");&#125;); 一次线程执行1234static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; NSLog(@\"只执行一次\");&#125;); 延迟执行1234dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; NSLog(@\"延迟五秒执行\");&#125;); 在自定义线程中执行123456dispatch_queue_t my_que = dispatch_queue_create(\"blog.muhlenxi.com\", NULL);dispatch_async(my_que, ^&#123; NSLog(@\"自定义线程汇中执行\"); &#125;); 多线程并行执行12345678910111213141516171819202122232425dispatch_group_t group = dispatch_group_create(); dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; NSLog(@\"并行线程，下载图片1\"); sleep(1);&#125;); dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; NSLog(@\"并行线程，下载图片2\"); sleep(2);&#125;); dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; NSLog(@\"并行线程，下载图片3\"); sleep(3);&#125;); dispatch_group_notify(group, dispatch_get_global_queue(0, 0), ^&#123; NSLog(@\"这里汇总下载图片结果\"); &#125;); 感谢您的阅读，一起学习，一起成长，加油！","tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://yoursite.com/tags/Objective-C/"},{"name":"GCD","slug":"GCD","permalink":"http://yoursite.com/tags/GCD/"}]},{"title":"iOS开发图片那些事儿","date":"2016-09-30T06:17:09.000Z","path":"2016/09/30/About-Images/","text":"版权声明：本文为 muhlenXi 原创文章，欢迎转载，转载请注明来源: http://muhlenxi.com/2016/09/30/About-Images 前言： APP 开发中，一些 UI 界面的设计常常涉及到 UIImageView 的使用，这和图片是分不开的，随着开发的渐渐深入，要记住的东西越来越多，但我是一个懒人，暂且就把关于图片的知识就放这儿吧。。 点击阅读全文来了解一下详情吧。 iPhone 尺寸规格 设备(iPhone) 对角线(Diagonal) 逻辑分辨率(point) 设备分辨率(pixel) Scale Factor 3GS 3.5-inch 320x480 320x480 @1x 4/4S 3.5-inch 320x480 640x960 @2x 5/5S/5C 4-inch 320x568 640x1136 @2x 6/6S 4.7-inch 375x667 750x1334 @2x 6plus 5.5-inch 414x736 1242x2208 1080x1920 @3x App Logo 尺寸规格logo：适配 iOS7.0 and Later logo命名 图片规格 分辨率 logo20@2x.png @2x 40x40 logo20@3x.png @3x 60x60 logo29@2x.png @2x 58x58 logo29@3x.png @3x 87x87 logo40@2x.png @2x 80x80 logo40@3x.png @3x 120x120 logo60@2x.png @2x 120x120 logo60@3x.png @3x 180x180 logoAppstore@2x.png @2x 1024x1024 App LaunchImage 尺寸规格launchImage：适配 iOS7.0 and Later launchImage：适配 iOS8.0 and Later launchImage命名 图片规格 分辨率 launchImage960@2x.png @2x 640x960 launchImage1136@2x.png @2x 640x1136 launchImage1334@2x.png @2x 750x1334 launchImage2208@3x.png @3x 1242x2208 App 初次安装引导页 尺寸规格launchImage：适配 iOS7.0 and Later launchImage命名 图片规格 分辨率 guide4@2x.png @2x 640x960 guide5@2x.png @2x 640x1136 guide6@2x.png @2x 750x1334 guide6P@3x.png @3x 1242x2208 App 启动广告页 尺寸规格launchImage：适配 iOS7.0 and Later launchImage命名 图片规格 分辨率 ad4@2x.png @2x 640x960 ad5@2x.png @2x 640x1136 ad6@2x.png @2x 750x1334 ad6P@3x.png @3x 1242x2208 本文会不间断更新，如有问题，可以留言给我！最后谢谢阅读！","tags":[{"name":"iOS开发图片","slug":"iOS开发图片","permalink":"http://yoursite.com/tags/iOS开发图片/"}]},{"title":"Objective-C 踩过的坑","date":"2016-09-23T06:10:05.000Z","path":"2016/09/23/Objective-C-Bugs/","text":"版权声明：本文为 muhlenXi 原创文章，欢迎转载，转载请注明来源: http://muhlenxi.com/2016/09/23/Objective-C-Bugs 导语： 在 APP 的开发过程中，随着开发时间的增长，踩过的坑越来越多，虽然当时比较苦恼，但是当解决这个问题的时候，成就感也不会小，为了给自己留个纪念和避免以后的小伙伴和我掉进同一个坑里，特此记录我开发中踩过的坑，吃一堑，长一智，每次都有收获，其实也挺好的，人生哪有一帆风顺的。 点击阅读全文来了解我踩过了哪些坑吧。 关于 Bundle ID切记使用反向域名名称风格字符串，它不能包含星号(*)。 com.domainname.appname //像这样的 导航栏不透明搞得鬼 导航栏默认是半透明的！ 对于同样的frame，导航栏不透明会导致UI控件向下偏移64个点！ 在ViewController中的View中添加一个红色的View 123UIView * redView = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 100, 100)];redView.backgroundColor = [UIColor redColor];[self.view addSubview:redView]; 当我们设置导航栏为不透明时 1self.navigationController.navigationBar.translucent = NO; 效果图如图所示， 导航栏隐藏那些事儿对于导航栏隐藏，以下两行代码都可以做到，但是要注意区别！ 1self.navigationController.navigationBarHidden = YES; 这行代码的作用是让整个 navigationController 都隐藏！ 1self.navigationController.navigationBar.hidden = YES; 这行代码的作用是仅仅隐藏 navigationController 中的一个属性,这个属性是 navigationBar! 区别如下： 当我们使用 navigationController Push一个新的 ViewController 时，在 ViewController 界面的左边，从左往右滑时，会 Pop 到上一个ViewController! 1、当我们使用第一行代码隐藏导航栏时，不影响这个功能，仍然可以通过手势返回到上一个ViewController中。 2、当我们使用第二行代码隐藏导航栏时，则无法通过手势返回到上一个ViewCOntroller中。 tabbar 的高度不一致同一 APP 在不同的 iPhone 设备上的 tabbar 的高度不一致，有可能是加载页 Launcher Image 的配置不全导致的。 一般LauncherImage需要适配iOS 7.0 and Later 和 iOS 7.0 and Later ！，以下是这两项分别所需图片的规格大小： iOS 7.0 and Later2x 对应的图片 640 x 960 pixels Retina 4 对应的图片 640 x 1136 pixels iOS 8.0 and LaterRetina HD 5.5 对应的图片 1242 x 2208 pixels Retina HD 4.7 对应的图片 750 x 1334 pixels 注意：如果只配置其中一项，则会导致 tabbar 的高度不一致，笔者的亲身经历过这样诡异的事情。 关于 UTF-8 编码1[self.nickName stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding ] 本文会不间断更新，如有问题，可以留言给我！最后谢谢阅读！","tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://yoursite.com/tags/Objective-C/"},{"name":"踩坑","slug":"踩坑","permalink":"http://yoursite.com/tags/踩坑/"}]},{"title":"UITabBarController 的详细运用","date":"2016-09-05T06:42:25.000Z","path":"2016/09/05/UITabBarController/","text":"版权声明：本文为 muhlenXi 原创文章，欢迎转载，转载请注明来源: http://muhlenxi.com/2017/09/05/UITabbarController 导语： iPhone 和 iPod touch 都可以使用 UITabBarController 类，令用户能够在多个视图控制器之间切换，并且能够定制屏幕底部的标签栏。用户只需点击一下屏幕，就能切换到其他视图，而且还可以通过 More 按钮来选择并编辑需要显示在屏幕底部标签栏里的标签（Tab）。 写个 demo 玩一下，实践是检验真理的唯一标准。 创建系统 Item【1】在 AppDelegate 的 didFinishLaunchingWithOptions 方法中,我们初始化一个UITabBarController 和 11个 UIViewController ：代码如下 1234567891011121314151617181920212223242526272829//1.初始化TabBarControllerUITabBarController * tabbarC = [[UITabBarController alloc] init];//2.初始化ViewControllersFirstViewController * firstVC = [[FirstViewController alloc] initWithNibName:@\"FirstViewController\" bundle:nil];UINavigationController * firstNav = [[UINavigationController alloc] initWithRootViewController:firstVC];SecondViewController * secondVC = [[SecondViewController alloc] initWithNibName:@\"SecondViewController\" bundle:nil];UINavigationController * secondNav = [[UINavigationController alloc] initWithRootViewController:secondVC];ThirdViewController * thirdVC = [[ThirdViewController alloc] initWithNibName:@\"ThirdViewController\" bundle:nil];UINavigationController * thirdNav = [[UINavigationController alloc] initWithRootViewController:thirdVC];FourthViewController * fourthVC = [[FourthViewController alloc] initWithNibName:@\"FourthViewController\" bundle:nil];UINavigationController * fourthNav = [[UINavigationController alloc] initWithRootViewController:fourthVC];FifthViewController * fifthVC = [[FifthViewController alloc] initWithNibName:@\"FifthViewController\" bundle:nil];UINavigationController * fifthNav = [[UINavigationController alloc] initWithRootViewController:fifthVC];SixthViewController * sixthVC = [[SixthViewController alloc] initWithNibName:@\"SixthViewController\" bundle:nil];UINavigationController * sixNav = [[UINavigationController alloc] initWithRootViewController:sixthVC];SeventhViewController * seventhVC = [[SeventhViewController alloc] initWithNibName:@\"SeventhViewController\" bundle:nil];UINavigationController * sevenNav = [[UINavigationController alloc] initWithRootViewController:seventhVC];EighthViewController * eighthVC = [[EighthViewController alloc] initWithNibName:@\"EighthViewController\" bundle:nil];UINavigationController * eightNav = [[UINavigationController alloc] initWithRootViewController:eighthVC];NinthViewController * ninthVC = [[NinthViewController alloc] initWithNibName:@\"NinthViewController\" bundle:nil];UINavigationController * nineNav = [[UINavigationController alloc] initWithRootViewController:ninthVC];TenthViewController * tenVC = [[TenthViewController alloc] initWithNibName:@\"TenthViewController\" bundle:nil];UINavigationController * tenNav = [[UINavigationController alloc] initWithRootViewController:tenVC];EleventhViewController * elevenVC = [[EleventhViewController alloc] initWithNibName:@\"EleventhViewController\" bundle:nil];UINavigationController * elevenNav = [[UINavigationController alloc] initWithRootViewController:elevenVC];//3.设置viewControllersNSArray * array = @[firstNav,secondNav,thirdNav,fourthNav,fifthNav,sixNav,sevenNav,eightNav,nineNav,tenNav,elevenNav];tabbarC.viewControllers = array; tabbarC.customizableViewControllers = array; //编辑模式 【2】分别在每个Controller的.m文件中重写 initWithNibName 方法，代码如下： 1234567891011- (instancetype)initWithNibName:(NSString *)nibNameOrNil bundle:(NSBundle *)nibBundleOrNil&#123; self = [super initWithNibName:nibNameOrNil bundle:nibBundleOrNil]; if (self) &#123; //创建系统TabBarItem并设置 UITabBarItem * item = [[UITabBarItem alloc] initWithTabBarSystemItem:UITabBarSystemItemMostViewed tag:0]; self.tabBarItem = item; &#125; return self;&#125; 注意：系统共有一下十二种样式的 TabbarItem 0 - UITabBarSystemItemMore, 1 - UITabBarSystemItemFavorites, 2 - UITabBarSystemItemFeatured, 3 - UITabBarSystemItemTopRated, 4 - UITabBarSystemItemRecents, 5 - UITabBarSystemItemContacts, 6 - UITabBarSystemItemHistory, 7 - UITabBarSystemItemBookmarks, 8 - UITabBarSystemItemSearch, 9 - UITabBarSystemItemDownloads, 10 - UITabBarSystemItemMostRecent, 11 - UITabBarSystemItemMostViewed, 编译并运行代码，会出现如下的界面： 如果视图控制器中的控制器的数量超过5个时，就会使用导航控制器管理剩余的视图控制器，并且将导航控制器作为第五个视图控制器。 设置 tabBarController 的代理。点击最后一个 More 标签，进入 More 界面，点击 Edit 后，长按拖动 Item，替换靠前的 Item，我们会发现，这时候 Tabbar 的 Item 的排列顺序发生了改变，记住此时的顺序。然后重新运行 APP，会发现则又恢复到了编辑前的顺序了，若要保存编辑的后顺序，我们需通过 NSUserDefaults 来保存排序后的数组。 【1】设置代理 1tabbarC.delegate = self; 【2】实现相应的代理方法 点击 选中 会触发这两个方法 1234567891011121314 - (BOOL)tabBarController:(UITabBarController *)tabBarController shouldSelectViewController:(UIViewController *)viewController&#123; NSLog(@\"tabBarController -- shouldSelectViewController\"); UINavigationController * nav = (UINavigationController *)viewController; if ([nav.topViewController isKindOfClass:[SecondViewController class]]) &#123; //第二个tabbarItem不能选中 return NO; &#125; return YES;&#125;- (void)tabBarController:(UITabBarController *)tabBarController didSelectViewController:(UIViewController *)viewController&#123; NSLog(@\"tabBarController --- didSelectViewController\");&#125; 点击 编辑 后会触发这个方法 1234- (void)tabBarController:(UITabBarController *)tabBarController willBeginCustomizingViewControllers:(NSArray&lt;__kindof UIViewController *&gt; *)viewControllers&#123; NSLog(@\"tabBarController --- willBeginCustomizingViewControllers\");&#125; 点击 完成 后会触发这两个方法 1234- (void)tabBarController:(UITabBarController *)tabBarController willEndCustomizingViewControllers:(NSArray&lt;__kindof UIViewController *&gt; *)viewControllers changed:(BOOL)changed&#123; NSLog(@\"tabBarController --- willEndCustomizingViewControllers\");&#125; 在这个方法中保存编辑后的 tabbarItem 的数组 123456789101112- (void)tabBarController:(UITabBarController *)tabBarController didEndCustomizingViewControllers:(NSArray&lt;__kindof UIViewController *&gt; *)viewControllers changed:(BOOL)changed&#123; NSLog(@\"tabBarController --- didEndCustomizingViewControllers\"); //获取并保存 NSMutableArray * endEditArray = [NSMutableArray array]; for (UINavigationController * nav in viewControllers) &#123; NSString * name = NSStringFromClass([nav.topViewController class]); [endEditArray addObject:name]; &#125; [[NSUserDefaults standardUserDefaults] setObject:endEditArray forKey:@\"ItemArray\"]; [[NSUserDefaults standardUserDefaults] synchronize]; &#125; 【3】在 didFinishLaunchingWithOptions 方法中，修改tabbarC.viewControllers的设置。 修改如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243UITabBarController * tabbarC = [[UITabBarController alloc] init]; tabbarC.delegate = self;NSMutableArray * getItemArray = [[NSUserDefaults standardUserDefaults] objectForKey:@\"ItemArray\"]; if (getItemArray == nil) &#123; FirstViewController * firstVC = [[FirstViewController alloc] initWithNibName:@\"FirstViewController\" bundle:nil]; UINavigationController * firstNav = [[UINavigationController alloc] initWithRootViewController:firstVC]; SecondViewController * secondVC = [[SecondViewController alloc] initWithNibName:@\"SecondViewController\" bundle:nil]; UINavigationController * secondNav = [[UINavigationController alloc] initWithRootViewController:secondVC]; ThirdViewController * thirdVC = [[ThirdViewController alloc] initWithNibName:@\"ThirdViewController\" bundle:nil]; UINavigationController * thirdNav = [[UINavigationController alloc] initWithRootViewController:thirdVC]; FourthViewController * fourthVC = [[FourthViewController alloc] initWithNibName:@\"FourthViewController\" bundle:nil]; UINavigationController * fourthNav = [[UINavigationController alloc] initWithRootViewController:fourthVC]; FifthViewController * fifthVC = [[FifthViewController alloc] initWithNibName:@\"FifthViewController\" bundle:nil]; UINavigationController * fifthNav = [[UINavigationController alloc] initWithRootViewController:fifthVC]; SixthViewController * sixthVC = [[SixthViewController alloc] initWithNibName:@\"SixthViewController\" bundle:nil]; UINavigationController * sixNav = [[UINavigationController alloc] initWithRootViewController:sixthVC]; SeventhViewController * seventhVC = [[SeventhViewController alloc] initWithNibName:@\"SeventhViewController\" bundle:nil]; UINavigationController * sevenNav = [[UINavigationController alloc] initWithRootViewController:seventhVC]; EighthViewController * eighthVC = [[EighthViewController alloc] initWithNibName:@\"EighthViewController\" bundle:nil]; UINavigationController * eightNav = [[UINavigationController alloc] initWithRootViewController:eighthVC]; NinthViewController * ninthVC = [[NinthViewController alloc] initWithNibName:@\"NinthViewController\" bundle:nil]; UINavigationController * nineNav = [[UINavigationController alloc] initWithRootViewController:ninthVC]; TenthViewController * tenVC = [[TenthViewController alloc] initWithNibName:@\"TenthViewController\" bundle:nil]; UINavigationController * tenNav = [[UINavigationController alloc] initWithRootViewController:tenVC]; EleventhViewController * elevenVC = [[EleventhViewController alloc] initWithNibName:@\"EleventhViewController\" bundle:nil]; UINavigationController * elevenNav = [[UINavigationController alloc] initWithRootViewController:elevenVC]; NSArray * array = @[firstNav,secondNav,thirdNav,fourthNav,fifthNav,sixNav,sevenNav,eightNav,nineNav,tenNav,elevenNav]; getItemArray = [NSMutableArray arrayWithArray:array]; &#125; else &#123; NSMutableArray * items = [NSMutableArray array]; for (NSString * name in getItemArray) &#123; //根据记录的类名创建 UIViewController *vc = [[NSClassFromString(name) alloc] init]; UINavigationController * nav = [[UINavigationController alloc] initWithRootViewController:vc]; [items addObject:nav]; &#125; getItemArray = [[NSMutableArray alloc] initWithArray:items]; &#125; tabbarC.viewControllers = getItemArray; tabbarC.customizableViewControllers = getItemArray; //编辑模式 运行代码后，编辑并保存后。关闭 APP，再打开，会发现是编辑后的顺序了 NavigationBar 和 Tabbar 的外观设置这里是 NavigationBa r的外观的全局设置 1234567891011 //设置状态栏的字体颜色 [[UIApplication sharedApplication] setStatusBarStyle:UIStatusBarStyleLightContent];//设置NavgationBar的字体大小和字体颜色 [[UINavigationBar appearance] setTitleTextAttributes: [NSDictionary dictionaryWithObjectsAndKeys: NavgationTitle_Color, NSForegroundColorAttributeName,S20Font, NSFontAttributeName, nil]]; //设置NavgationBar的背景颜色 [UINavigationBar appearance].barTintColor = NavgationBar_Color; //设置NavgationBar的Item的颜色 [[UINavigationBar appearance] setTintColor:NavgationTitle_Color]; //设置导航栏不透明 [UINavigationBar appearance].translucent = NO; 这里是 TabBar 的外观的全局设置 12345678//设置标题栏不透明[UITabBar appearance].translucent = NO;//设置标签栏的背景颜色[UITabBar appearance].barTintColor = TabBar_Color;//未选中字体颜色[[UITabBarItem appearance] setTitleTextAttributes:[NSDictionary dictionaryWithObjectsAndKeys:TabBarItem_DisselectedColor,NSForegroundColorAttributeName,S12Font,NSFontAttributeName, nil] forState:UIControlStateNormal];//选中字体颜色[[UITabBarItem appearance] setTitleTextAttributes:[NSDictionary dictionaryWithObjectsAndKeys:TabBarItem_SelectedColor,NSForegroundColorAttributeName,S12Font,NSFontAttributeName, nil] forState:UIControlStateSelected]; 一般TabbarItem 的创建【1】在AppDelegate的 didFinishLaunchingWithOptions 方法中,我们初始化一个UITabBarController 和4个 UIViewController,并做一些简单的设置就可以了，代码如下： \u0010\u0010123456789101112131415161718192021222324252627282930313233343536373839//oneOneViewController * oneVC = [[OneViewController alloc]init];UINavigationController * oneNav = [[UINavigationController alloc]initWithRootViewController:self.oneVC];//twoTwoViewController * twoVC = [[TwoViewController alloc]init];UINavigationController * twoNav = [[UINavigationController alloc]initWithRootViewController:self.twoVC];//threeThreeViewController * threeVC = [[ThreeViewController alloc]init];UINavigationController * threeNav = [[UINavigationController alloc]initWithRootViewController:self.threeVC];//fourFourViewController * fourVC = [[FourViewController alloc]init];UINavigationController *fourNav = [[UINavigationController alloc]initWithRootViewController:self.fourVC];//加TabBarControllerUITabBarController *tabBarController = [[UITabBarController alloc] init];tabBarController.viewControllers = @[oneNav,twoNav,threeNav,fourNav];//设置tabbar相关属性UITabBar *tabBar = tabBarController.tabBar;UITabBarItem *oneItem = [tabBar.items objectAtIndex:0];UITabBarItem *twoItem = [tabBar.items objectAtIndex:1];UITabBarItem *threeItem = [tabBar.items objectAtIndex:2];UITabBarItem *fourItem = [tabBar.items objectAtIndex:3];//设置标题oneItem.title = @\"One\";twoItem.title = @\"Two\";threeItem.title = @\"Three\";fourItem.title = @\"Four\";//设置图片//设置一般图片[oneItem setImage:[[UIImage imageNamed:@\"tabbar_contacts\"]imageWithRenderingMode:UIImageRenderingModeAlwaysOriginal ]];//设置选中照片[oneItem setSelectedImage:[[UIImage imageNamed:@\"tabbar_contactsHL\"] imageWithRenderingMode:UIImageRenderingModeAlwaysOriginal ]];[twoItem setImage:[[UIImage imageNamed:@\"tabbar_discover\"]imageWithRenderingMode:UIImageRenderingModeAlwaysOriginal]];[twoItem setSelectedImage:[[UIImage imageNamed:@\"tabbar_discoverHL\"]imageWithRenderingMode:UIImageRenderingModeAlwaysOriginal]];[threeItem setImage:[[UIImage imageNamed:@\"tabbar_mainframe\"]imageWithRenderingMode:UIImageRenderingModeAlwaysOriginal]];[threeItem setSelectedImage:[[UIImage imageNamed:@\"tabbar_mainframeHL\"]imageWithRenderingMode:UIImageRenderingModeAlwaysOriginal]];[fourItem setImage:[[UIImage imageNamed:@\"tabbar_me\"]imageWithRenderingMode:UIImageRenderingModeAlwaysOriginal]];[fourItem setSelectedImage:[[UIImage imageNamed:@\"tabbar_meHL\"]imageWithRenderingMode:UIImageRenderingModeAlwaysOriginal]];//设置window的跟视图控制器self.window.rootViewController = tabBarController; 编译并运行代码，会出现如下的界面： 自定义Tabbar【1】新建一个继承于 XYJTabBarController 的 XYJTabBarController 控制器： 打开.m文件，在类扩展中，定义一个 UIImageView 的属性 customTabbar,代码如下: 1@property (nonatomic,strong) UIImageView * customTabbar; //!&lt; 自定义Tabbar ImageView 【2】在 viewDidLoad 中初始化相关页面 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//创建要放在TabBarController中的视图控制器 //one OneViewController * oneVC = [[OneViewController alloc] init]; UINavigationController * oneNav = [[UINavigationController alloc] initWithRootViewController:oneVC]; //two TwoViewController * twoVC = [[TwoViewController alloc] init]; UINavigationController * twoNav = [[UINavigationController alloc] initWithRootViewController:twoVC]; //three ThreeViewController * threeVC = [[ThreeViewController alloc] init]; UINavigationController * threeNav = [[UINavigationController alloc] initWithRootViewController:threeVC]; //four FourViewController * fourVC = [[FourViewController alloc] init]; UINavigationController * fourNav = [[UINavigationController alloc] initWithRootViewController:fourVC]; //设置viewControllers self.viewControllers = @[oneNav,twoNav,threeNav,fourNav]; //自定义tabbar //1.隐藏系统的tabbar self.tabBar.hidden = YES; //2.初始化customTabbar self.customTabbar = [[UIImageView alloc] initWithFrame:CGRectMake(0, self.view.bounds.size.height-49, self.view.bounds.size.width, 49)]; self.customTabbar.image = [UIImage imageNamed:@\"tabbar_bg\"]; //打开用户交互 self.customTabbar.userInteractionEnabled = YES; [self.view addSubview:self.customTabbar]; //3.给tabbar添加按钮 CGFloat width = self.view.bounds.size.width / 4; //去沙盒读取状态选择 NSUserDefaults *userDefaults = [NSUserDefaults standardUserDefaults]; NSNumber *index = [userDefaults objectForKey:@\"tabbarSelectedIndex\"]; if (index == nil) &#123; //默认选中第一个Item index = @(0); &#125; for (int i = 0; i &lt; 4; i++) &#123; //创建按钮 UIButton *btn = [UIButton buttonWithType:UIButtonTypeCustom]; btn.frame = CGRectMake(width * i, 0, width, 49); //设置正常状态的图片 UIImage *image = [UIImage imageNamed:[NSString stringWithFormat:@\"tab%d_n@2x\", i+1]]; [btn setImage:image forState:UIControlStateNormal]; //设置选中状态的图片 UIImage *selectImage = [UIImage imageNamed:[NSString stringWithFormat:@\"tab%d_s@2x\", i+1]]; [btn setImage:selectImage forState:UIControlStateSelected]; if (i == index.integerValue) &#123; btn.selected = YES; //设置选中状态 &#125; //设置tag btn.tag = i + 100; //添加事件，改变选中状态 [btn addTarget:self action:@selector(btnAction:) forControlEvents:UIControlEventTouchUpInside]; [self.customTabbar addSubview:btn]; &#125; 【3】在AppDelegate的 didFinishLaunchingWithOptions 方法中,我们初始化自定义的TabBarController，并将其设置为 Window 的rootViewController：代码如下 12XYJTabBarController * tabbarController = [[XYJTabBarController alloc] init];self.window.rootViewController = tabbarController; 编译并运行代码，会出现如下的界面： 感谢阅读，TabarController的学习暂时到这里为止","tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://yoursite.com/tags/Objective-C/"},{"name":"UITabBarController","slug":"UITabBarController","permalink":"http://yoursite.com/tags/UITabBarController/"}]},{"title":"把你的英语用起来---读书笔记","date":"2016-08-26T03:00:55.000Z","path":"2016/08/26/Use-your-English/","text":"版权声明：本文为 muhlenXi 原创文章，欢迎转载，转载请注明来源: http://muhlenxi.com/2016/08/26/Use-your-English 导读 这是一本英语学习书。本书适合特别想提高自己的英语能力而不得的人。很多学了 6~10 年的英语的人还是不能阅读英文的资料。想找培训机构，发现针对考试的比较多，费用也很高。在网上跟着大家一起背单词，又枯燥又难以坚持，效果也不是很好。不停的想学英语，但总是拿起又放下，放下又拿起，断断续续，英语水平一直没有得到提高。 从阅读本书开始，真正的把你的英语用起来! 坚持的方法和策略 1、尽量杜绝社交网站的影响。 2、用记事本来监控自己的学习流程。 3、列计划的时候绝对不要自我期望过高。 4、养成立即行动的习惯。 5、要主动养成正面的自我激励模式。 6、养成早睡早起的习惯。 做记录的实用技巧: 首先列出整体的学习计划，然后记录完成多少或者有什么新想法。 记录时间以天为单位，也可以两三天记录一下。 要时刻记录下自己的收获，把自己的英语水平时时都记录下来。 完成重大突破时，可以去庆祝一下，达到自我激励的作用。 寻找闲余时间策略: 和电视剧说拜拜。 不要晚上学习，把学习时间调整到早上。 零碎时间和大块时间穿插创造奇迹。 透析法大战播讲类资料初级通关: 奶爸说：从听说入手，容易让大家有收获感，更能对英文感兴趣，这样越学越想学。 赖世雄 美语从头学 一套，包含以下七本 1.美语入门 2.美语音标 3.初级美语 上 4.初级美语 下 5.中级美语 上 6.中级美语 下 7.高级美语 使用播讲类资料 【1】英文听说透析法 【2】艾宾浩斯复习表格 环节一 攻克英语发音（2~3周）材料:《赖世雄美语音标》 方法：看书听CD，跟着录音大声模仿。 建议：2~3周内，本书至少学习2~3遍 环节二，ESLPOD,英语学习播客，（3~4个月）(English As a Second Language Podcast) 共六本教材： 1.Introduction to the United States 2.A Day in the Life of Jeff 3.A Day in the Life of Lucy 4.Interview Questions Answered 5.English for Business Meeting 6.Using English at Work 中国人的发音难点:基础篇 1. 美音的R怎么发 2. 发好L音和N音 3. 发好长短音/u/和/u:/ 4. 区分好/i/和/i:/ 进阶篇 1.失去爆破 凡是出现爆破音结尾的，不管下一个单词是什么音开头，统统不发出声音，只简单停顿0.1秒。 2.注意at的读法 3.美音中的音变，也就是所谓的浊化现象 T在末尾，如果要连续的话，即下一个单词以原因开头，那么绝大部分情况下，T是要浊化成D的。 T在中间，一般情况下也是读成D,准确来说，是读成近似于D的音。 H音的省略。 4.美音中的连读规则 中级修炼环节一 发音复习课2-3周 【1】American Pronunciation Workshop (美语发音教程) APW一共16个视频，每个视频在20分钟左右，每天一个视频可以看好多遍，请在两周内完成这个任务。 【2】爱荷华大学的口腔剖面 环节二 突破常速多口音的EnglishPod 一共有 365 期 附录2.1为精选100期 学习方法：deep learning narrow input (狭窄输入) 高级修炼: 警告：我们默认适合这本书的同学的基础大约是，要么完成100期的练习，要么可以较为流畅地听懂常速度的英文了。这本书语速很快，而且是全英文写成，对大部分同学来说，难度很大，绝不适合基础一般的同学学习，请确定自己基础达到了再尝试，否则事倍功半。 American Accent Training Ann Cook 即标准美语发音的13秘诀 学习方法：1、先扫一遍目录，诵读编排结构 2、一边看书，一边听CD，从头到尾反复听几遍。 3、一个个章节的重点突破，去做每个章节练习题。 4、模仿录音，矫正发音。 英语语法学习 《文法俱乐部》 旋元佑 英文文法是以句子为主要的研究单位。学文法的目的，就是要看懂英文句子，包括发杂的、难懂的句子，更进一步就能写出正确的，有变化的句子。 英文有声书 Audiobook推荐的英文有声书 audiobook: I Capture the Castle 我的秘密城堡 Never Let Me Go 别让我走 Where the Mountain Meets the Moon 月夜仙踪 Happy Prince 快乐王子 I,Robot 机械公敌 Percy Jackson 波西杰克逊 Artemis Fowl 精灵事件 Harry Potter 哈利波特 Neil Gaiman先生的所有图书 《Graveyard Book 坟场之书》《 Caroline 卡罗兰》 Nicholas Sparks 《Message in a Bottle 瓶中信》 Benedict Cumberbatch 《Casanova 卡萨诺瓦》 删节版 《Dear Joho 分手信》 有声书比较出名的演员: Anne Hathaway 安妮海瑟薇 《公主日记》 Benedict Cumberbatch 本尼迪克特康伯巴奇 《神探夏洛克》 Martin Freeman 马丁弗里曼 《银河漫游指南》 Stephen Fry 斯蒂芬弗雷 《Harry Potter》《维尼熊》《王尔德的一些短篇》《福克斯先生》 R alph Fiennes 拉尔夫范恩斯《The English Patient》 Dan Stevens 《战马》 David Tennant 《大卫田纳特》《Doctor Who 神秘博士》《How to Train Your Dragon 驯龙记》 Alan Rickman 艾伦里克曼 《还乡记》 Emilia Fox 艾米丽雅福克斯 《Pride and Prejudice 》《Never Let Me Go》 大师类作品 Scott Brick 《基地和机器人》 Juliet Stevenson Samule West Frank Muller 《The Dark Tower 黑暗塔》 John Lee 《三个火枪手》 《基督山伯爵》 透析法大战英文原著 伍老师说：把英语用起来，就是在真实的生活中使用这门语言，要求听、说、读、写全部实现英文原著化。 听：听实时的英语新闻，从BBC、CNN到AI Jazeera 说：就是用英语聊天，从身边的熟人到网络另一端的老外。 读：就读老外的英文版，从短信、邮件、到大部头的专著。 写：就写英文邮件、短信给亲友同事乃至生意上的伙伴。 常用的英文原著电子书免费下载网站： 【1】古登堡计划 【2】很多书 【3】feedbooks 【4】原版英语论坛 【5】七彩英语 【6】掌上书苑 注意：选定原著之后，需从一而终，一读到底，浅尝辄止是读书的大忌。 生词量:看首万词不重复词数 测量词汇量 蓝思值:句子复杂程度的科学测算 蓝思官网 核心操作:每两页查一个生词 在生词丛中抓住原著的大意。 每日复习原著生词不超过5分钟. 保证透析成功的训练计划 七天行动:必须义无反顾执行 1、置之死地而后生 2、欲速则不达 3、读到翻页之前绝不做其他事情 4、长期激励：承诺一年读10本原著 5、每读完一本书就写透析记录 一网打尽各种形式的英文原著 1、循序渐进，先打好长篇基础 2、进军短篇，读尽天下英语新闻 3、每月研究一个英文网站 4、每月研究一个英文台 5、透析英文歌，进驻全球乐坛 6、透析英文四暗影，进驻全球影坛 （1）不看字幕。 （2）大量的看。 （3）综合阅读。 推荐的英文原著： 小王子 麦田里的守望者 The Godfather 教父 The Hunt for Red October 猎杀红色十月 Steven Jobs Harry Potter Sherlock Holmes 福尔摩斯 Three Musketeers 三个火枪手 Lady Chatterley’s Lover 查泰莱夫人的情人 Tropic of Cancer 北回归线 商业小说 行业小说之王 Arthur Hailey 阿瑟黑利 The Moneychangers 钱商 商业励志书 Rich Dad,Poor Dad 商业教科书 Freakmics 《魔鬼经济学》 商业期刊 Fortune 《财富》 后记 生活中，我们每个人或许都懂一些大道理，也许仅仅是知道而已，有多少人去规规矩矩的实践呢，又有多少人，能不间断的坚持去做一件事情呢，即使是简单的按时吃饭，早睡早起。这个世界，存在雄鹰一样精英的人物，也存在蜗牛式默默不断前进的小人物。我或许是一只小蜗牛，但是，我不放弃，每天去坚持做几件小事，付出行动，知行统一，才能有所收获。愿不就的将来，你可以成为一个极速蜗牛！ PS:我最喜欢的一幅图","tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/tags/读书笔记/"},{"name":"把你的英语用起来","slug":"把你的英语用起来","permalink":"http://yoursite.com/tags/把你的英语用起来/"}]},{"title":"初识 Swift3","date":"2016-08-19T01:37:28.000Z","path":"2016/08/19/Swift3/","text":"版权声明：本文为 muhlenXi 原创文章，欢迎转载，转载请注明来源: http://muhlenxi.com/2016/08/19/Swift3 导语： Swift 是一个新的编程语言，使用它可以开发 iOS、macOS、watchOS 和 tvOS 等平台上的 APP ，它比 C 和 Objective-C 语言更好的胜任这项工作，Swift 采用安全的编程模式，它加入了一些现代的特色使得编程更加容易、更加灵活和更加有趣，Swift 基于成熟的受人喜爱的 Cocoa 和 CocoaTouch 框架，这是一个重新定义软件是如何开发的机会！Just enjoy it！。 点击阅读全文来了解一下详情吧。 Swift 之初体验单一变量在屏幕上打印 hello，world!1print(\"hello,world!\") 定义一个变量和改变变量的值12var myVariable = 42myVariable = 50 定义一个常量 1let myConstant = 38 我们定义常量和变量的时候可以不显示的声明常量或变量的数据类型，编译器会根据你设置的初始值去推测数据的类型。 带数据类型的常量的声明是这样的。 1let myWeight:Double = 54.0 字符串类型转换。123let label = \"the width is \"let width = 94let widthLabel = label + String(width) 还有个更简单的方式。 1234let apples = 3let oranges = 5let appleSummary = \"I hava \\(apples) apples\"let fruitSummary = \"I have \\(apples + oranges) pieces of fruit\" 定义一个不可变数组 1let animals = [\"猴子\",\"大象\",\"兔子\"] 定义一个可变数组 1234var fruitLists = [\"苹果汁\",\"香蕉\",\"梨\",\"葡萄\"]fruitLists[0] = \"苹果\" //修改 fruitLists.append(\"猕猴桃\") //增加 fruitLists.remove(at: 4) //删除 定义一个空的数组 1let animals = [String]() 定义一个不可变字典 1let wheelsOfCar = [\"独轮车\":1,\"自行车\":2,\"小汽车\":4] 定义一个空的字典 1let emptyDictionary = [String: NSInteger]() 定义一个可变字典 1234var wheelsOfCar = [\"独轮车\":1,\"自行车\":2,\"小汽车\":4]wheelsOfCar[\"三轮车\"] = 3 //增加或修改wheelsOfCar.removeValue(forKey: \"三轮车\") //删除print(\"\\(wheelsOfCar)\") 控制流 if - else 条件判断语句 12345678910let scores = [75,43,103,87]var count = 0 for score in scores &#123; if score &gt; 50 &#123; count += 1 &#125; else &#123; count += 0 &#125; &#125;print(\"分数大于零的科目个数：\\(count)\") if或else后面的（）可以省略，但是 {} 不能省略！ 可选值操作12345678let optionalName:String? = \"张三\"var greeting = \"hello!\"if let name = optionalName &#123; greeting = \"hello,\\(name)\" &#125;else &#123; greeting = \"optionalName is nil\" //当名字为nil时会执行这句 &#125;print(greeting) 我们也可以用操作符 ?? 给可选值设定一个默认值，当可选值为 nil 时会自动以默认值填充！ 1234let nickName:String? = nillet defaultName = \"李四\"let informalGreeting = \"Hi \\(nickName ?? defaultName)\"print(informalGreeting) switch - case 条件判断语句1234567891011let vegetable = \"土豆\"switch vegetable &#123;case \"辣椒\": print(\"辣椒吃多了容易上火。\")case \"红薯\", \"土豆\": print(\"这种蔬菜淀粉含量比较高。\")case let x where x.hasSuffix(\"瓜\"): print(\"\\(x) 属于瓜类的一种\")default: print(\"这种蔬菜的信息暂未获得。\")&#125; 通过 for - in 来遍历数组或字典12345678910111213let intersetingNumbers = [\"素数\":[2,3,5,7,11,13],\"斐波纳契数\":[1,1,2,3,5,8],\"平方数\":[1,4,9,16,25]]var largest = 0//找出这些数中的值最大的数for (_,numbers) in intersetingNumbers &#123; for number in numbers &#123; if number &gt; largest &#123; largest = number &#125; &#125;&#125;print(largest) 可以通过 for-in 来控制循环次数123456789101112131415//全闭区间var sum = 0for i in 0...4 &#123; sum = sum + i //循环5次&#125;print(sum) //半开半闭区间var sum1 = 0for i in 0..&lt;4 &#123; sum1 = sum1 + i //循环4次&#125;print(sum1) while 循环 和 repeat - while 循环 12345678910111213//先判断后执行var n = 2while n &lt; 100 &#123; n = n * 2&#125;print(n) //输出128//先执行后判断 var m = 2repeat &#123; m = m * 2&#125;while m &lt; 100print(m) //输出128 函数 和 闭包用 func 声明一个函数，()中是参数，-&gt;后面是返回值的类型1234func greet(person: String,day :String) -&gt; String &#123; return \"你好 \\(person),今天是 \\(day)。\"&#125; 函数的调用： 12let str:String = greet(person: \"张三\", day: \"星期天\") //调用函数print(str) 禁止设置默认参数名当我们声明函数时不指定参数的名字时，参数的名字默认为形式参数的名字，当然，我们可以通过_来禁止设置默认参数名 1234func greet(_ person:String, on day:String) -&gt; String &#123; return \"Hello \\(person),today is \\(day)\"&#125; 方法调用是这样： 1print(greet(\"Tom\", on: \"Monday\")) 使用元组 (tuple) 来创建复合值123456789101112131415161718func calculateStatistics(scores:[Int]) -&gt; (min:Int,max:Int,sum:Int) &#123; var min = scores[0] var max = scores[0] var sum = 0 for score in scores &#123; if score &gt; max &#123; max = score &#125; else if score &lt; min &#123; min = score &#125; sum += score &#125; return (min,max,sum)&#125; 函数调用时这样的： 1234let statistics = calculateStatistics(scores: [5,3,100,25,4])print(\"min = \\(statistics.min)\")print(\"max = \\(statistics.max)\")print(\"sum = \\(statistics.2)\") 函数的参数个数也可以是不确定的 12345678func sumOf(numbers:Int...) -&gt; Int &#123; var sum = 0 for num in numbers &#123; sum += num &#125; return sum&#125; 调用是这样的： 12print(sumOf()) //输出0print(sumOf(numbers: 100,200,50)) //输出350 函数可以嵌套，嵌套的函数可以读取或修改外部函数的变量的值。123456789101112//函数定义func returnFifteen() -&gt; Int &#123; var y = 10 func add() &#123; y += 5 &#125; add() return y;&#125;//函数调用：print(returnFifteen()) 函数的 返回值 也可以是函数。123456789101112//生成一个增量器func makeIncrementer() -&gt; ((Int) -&gt; Int) &#123; func addOne(number:Int) -&gt; Int &#123; return number + 1 &#125; return addOne;&#125;//方法调用let increment = makeIncrementer()print(increment(7)) 函数的 参数 也可以是函数。1234567891011121314151617func lessThanTen(number:Int) -&gt; Bool &#123; return number &lt; 10&#125; //检查数组中是否包含小于10的元素func checkArray(list:[Int],condition:(Int) -&gt; Bool) -&gt; Bool &#123; for item in list &#123; if condition(item) &#123; return true &#125; &#125; return false&#125; 函数调用是这样的： 123let numbers = [18,9,17,12]let ret = checkArray(list: numbers, condition: lessThanTen)print(ret) 函数是闭包的一种特殊形式,可以用{}实现一个闭包，在闭包中用in来分离参数和返回值类型 。123456789let numbers = [20,19,7,12]//将数组中的元素的值加倍let mappedNumbers = numbers.map(&#123;number in number * 2&#125;)print(mappedNumbers)//逆序排列数组中的元素let sortedNumbers = numbers.sorted&#123;$0 &gt; $1&#125;print(sortedNumbers) 对象 和 类用 class 来创建一个类，属性的声明和常量、变量的声明方式一样，方法和函数的声明方式也一样。可以通过 init 来生成一个 initializer 来初始化对象。 可以通过 deinit 来生成一个 deinitializer，当对象被释放时做一些清理工作。 类的声明如下： 12345678910111213141516//声明一个几何体class Shape &#123; var numberOfSides = 0 //边的个数 var name :String //几何体的名字 init(name:String) &#123; self.name = name &#125; //简单描述 func simpleDescription() -&gt; String &#123; return \"这个叫\\(name)的几何体有\\(numberOfSides)条边\" &#125;&#125; 类的对象的生成： 123let shape = Shape.init(name: \"七边形\")shape.numberOfSides = 7print(shape.simpleDescription()) 类的继承如果该类是继承某一父类的子类，则声明子类的时候要用 :+ 父类名 来表明其继承自什么类。当没有父类的时候，可以省略不写。 当子类要覆写父类的方法时，子类方法前要添加关键词 override 声明一个继承Shape的Square类 123456789101112131415161718192021222324//正方形class Square: Shape &#123; var sideLength:Double //边长 init(sideLength:Double,name:String) &#123; self.sideLength = sideLength super.init(name: name) numberOfSides = 4 &#125; override func simpleDescription() -&gt; String &#123; return \"这个叫\\(name)的几何体有\\(numberOfSides)条边,边长为\\(sideLength)cm\" &#125; //计算面积 func area() -&gt; Double &#123; return sideLength * sideLength &#125; &#125; 子类对象的创建: 123let square = Square.init(sideLength: 4, name: \"正方形\")print(\"面积是：\\(square.area())\")print(square.simpleDescription()) 类的属性，也可以自己生成 getter 和 setter 方法：12345678910111213141516171819202122232425//等边三角形class EquialateralTriangle: Shape &#123; var sideLenth :Double = 0 init(sideLength:Double,name:String) &#123; self.sideLenth = sideLength super.init(name: name) numberOfSides = 3 &#125; //周长 var perimeter:Double &#123; set &#123; sideLenth = newValue / 3.0 &#125; get &#123; return sideLenth * 3.0 &#125; &#125; override func simpleDescription() -&gt; String &#123; return \"这是一个边长为\\(sideLenth)的等边三角形\" &#125;&#125; 等边三角形对象的创建: 1234567let triangle = EquialateralTriangle.init(sideLength: 5, name: \"等边三角形\")//获取周长print(\"周长是：\\(triangle.perimeter)\")triangle.perimeter = 12//获取修改周长后的边长print(\"边长是：\\(triangle.sideLenth)\")print(triangle.simpleDescription()) 枚举 和 结构体用 enum 来声明一个枚举，枚举中也可以关联函数第一个枚举值默认是0，我们也可以指定第一个枚举值为我们想要的值。 举个 🌰 ： 12345678910111213141516171819enum Direction : NSInteger &#123; case up = 1, down, left, right func description() -&gt; String &#123; switch self &#123; case .up: return \"向上\" case .down: return \"向下\" case .left: return \"向左\" case .right: return \"向右\" &#125; &#125;&#125; 调用如下： 1234let direc = Direction.downprint(direc)print(direc.rawValue)print(direc.description()) 我们也可以通过 rawValue 来初始化一个枚举的选项，得到的是一个可能值。 12let direc = Direction(rawValue: 2)print(direc!.description()) 枚举中的选项还可以和不同的常量值关联，当我们创建一个枚举的实例时，就可以初始化不同的常量值。 1234enum ServerResponse &#123; case result(String,String) case failure(String)&#125; 用 struct 来声明一个结构体，枚举中也可以关联函数举个 🌰 ： 1234567891011121314151617//矩形类struct Rectangle &#123; var origin:CGPoint var width:Float var height:Float func area() -&gt; String &#123; let area = width * height return \"\\(area)\" &#125; func perimeter() -&gt; Float &#123; return (width + height) * 2 &#125;&#125; 简单运用 123let myRectangle = Rectangle(origin: CGPoint.init(x: 0, y: 0), width: 5, height: 6)print(\"周长：\\(myRectangle.perimeter())\")print(\"面积：\\(myRectangle.area())\") 协议 和 类扩展用 protocol 来声明一个协议。1234protocol TestProtocol &#123; var simpleDescription:String &#123; get &#125; mutating func adjust()&#125; 类、枚举和结构体都可以遵循协议 1234567891011121314151617class TestClass: TestProtocol &#123; var value:Int = 108 var simpleDescription: String = \"这是一个测试类\" func adjust() &#123; simpleDescription.append(\"+测试值是\\(value)\") &#125;&#125; struct TestStruct:TestProtocol &#123; var simpleDescription: String = \"一个测试结构体\" mutating func adjust() &#123; simpleDescription.append(\"+ 遵循协议\") &#125;&#125; 简单运用 1234567let test = TestClass()test.adjust()print(test.simpleDescription) var testStruct = TestStruct()testStruct.adjust()print(testStruct.simpleDescription) 用 extension 来声明一个类扩展，给存在的类增加一个方法或算值属性 。举个 🌰 ： 123456789101112extension Int&#123; //简介 算值属性 var simpleDescription:String &#123; return \"the number \\(self)\" &#125; //自增2 mutating func addTwo() &#123; self = self + 2 &#125; &#125; 简单使用 1234var num:Int = 8print(num.simpleDescription)num.addTwo()print(num) 用 extension 也可以让存在的类或数据类型遵循某项协议。 123456789101112131415161718protocol testProtocol &#123; var simpleDescription:String &#123; get &#125; mutating func adjust()&#125;extension Double: testProtocol&#123; var simpleDescription: String &#123; return \"Double value \\(self)\" &#125; mutating func adjust() &#123; self *= 2 &#125;&#125; 简单运用： 1234var pi:Double = 3.14print(pi.simpleDescription)pi.adjust()print(pi) 错误处理通过遵循错误协议 Error 来声明一个错误类型。 12345enum PrinterError:Error &#123; case outOfPaper case noToner case onFire&#125; 用 throw 来抛出错误和用 throws 来标记一个可以抛出错误的函数，当函数抛出错误时，函数会立即返回，并调用错误处理方法。 123456func send(job:Int, toPrinter printerName:String) throws -&gt;String &#123; if printerName == \"Nerver Has Toner\" &#123; throw PrinterError.noToner &#125; return \"Job sent\"&#125; 用 do-catch 来处理错误，在 do代码块 中，调用可抛出错误的函数时，前面需要用 try 来标记,而在 catch代码块 中，错误的默认名字是 error，除非设置了一个别名。 12345678do &#123; let printerResponse = try send(job: 1040, toPrinter: \"Nerver Has Toner\") print(printerResponse) &#125; catch &#123; print(error) &#125;&#125; 可以用多重 catch代码块 来详细处理错误 12345678910do &#123; let printerResponse = try send(job: 1040, toPrinter: \"Nerver Has Toner\") print(printerResponse) &#125; catch PrinterError.onFire &#123; print(\"打印机过热，休息一会儿再使用\") &#125; catch PrinterError.noToner&#123; print(\"打印机没墨了，请添加墨水\") &#125; catch &#123; print(\"纸张用完，请添加纸张\") &#125; 另一种处理错误是用 try? 将结果转换成一个可选值，如果函数抛出错误，这个错误将被丢弃，结果为nil，否则返回值是一个包含结果的可选值。 12let printerSuccess = try? send(job: 1884, toPrinter: \"hello world\")let printerFailure = try? send(job: 1884, toPrinter: \"Nerver Has Toner\") 使用defer代码块来声明函数返回前需要执行的语句，该语句不管函数是否抛出错误都会执行。 1234567891011121314var fridgeIsOpen = falselet fridgeContent = [\"milk\",\"eggs\",\"apple\"] func fridgeContains(food:String) -&gt; Bool &#123; fridgeIsOpen = true defer &#123; fridgeIsOpen = false &#125; let result = fridgeContent.contains(food) return result &#125; 简单运用 123let ret = fridgeContains(food: \"banana\")print(ret)print(fridgeIsOpen) 泛型用 &lt;name&gt; 声明一个泛型或泛型方法。123456789101112func makeArray&lt;Item&gt;(repeat item:Item, numberOfItems:Int) -&gt; [Item] &#123; var result = [Item]() for _ in 0..&lt;numberOfItems &#123; result.append(item) &#125; return result &#125;//函数调用print(makeArray(repeat: \"Apple\", numberOfItems: 7)) 函数、类、枚举、结构体等也可以声明成泛型的方式 123456789enum OptionalValue&lt;Wrapped&gt; &#123; case none case some(Wrapped)&#125;//简单调用var possibleValue:OptionalValue&lt;Int&gt; = .nonepossibleValue = .some(200)print(possibleValue) 在方法名后面来使用 where 指定对类型的需求—比如，需要都实现一个协议，需要两个对象的类型一样，或都用于共同的父类等 123456789101112//判断是否有共同元素 func anyCommonElements&lt;T: Sequence, U: Sequence&gt;(_ lhs: T, _ rhs: U) -&gt; Bool where T.Iterator.Element: Equatable, T.Iterator.Element == U.Iterator.Element &#123; for lhsItem in lhs &#123; for rhsItem in rhs &#123; if lhsItem == rhsItem &#123; return true &#125; &#125; &#125; return false&#125; 简单运用 12let ret = anyCommonElements([1,2,3], [5])print(ret) 结束语：在这里查阅Swift3官方文档 感谢阅读，有什么不对的地方可以给我留言，一起学习，一起进步！","tags":[{"name":"Swift3初体验","slug":"Swift3初体验","permalink":"http://yoursite.com/tags/Swift3初体验/"}]},{"title":"魔方还原秘诀","date":"2016-08-11T01:50:03.000Z","path":"2016/08/11/The-Rubik-s-Cube-Reduction/","text":"版权声明：本文为 muhlenXi 原创文章，欢迎转载，转载请注明来源: http://muhlenxi.com/2016/08/11/The-Rubik-s-Cube-Reduction 导语： 魔方，英文名为 Rubik’s Cube ，又叫魔术方块或鲁比克方块，是一种手部极限运动。通常泛指三阶魔方。三阶魔方魔方形状通常是正方体，由有弹性的硬塑料制成。玩法是将魔方打乱，然后在最短的时间内复原。目前三阶魔方官方世界纪录是由 Lucas Etter 保持的4.90秒。 玩魔方是一种高雅的健身活动，它可以锻炼人的手脑并用能力，对培养人的动作技能都十分有效；可增强人的记忆力，丰富空间想象力；可培养人的耐力和毅力！ 注意事项熟记：白色为底，黄色是顶，正对你的是红色，则蓝色就在你的左边。 标注： ×2，即旋转180度 U - 上面顺时针旋转90度 U&apos; - 上面逆时针旋转90度 D - 下面顺时针旋转90度 D&apos; - 下面逆时针旋转90度 L - 左面顺时针旋转90度 L&apos; - 左面逆时针旋转90度 R - 右面顺时针旋转90度 R&apos; - 右面逆时针旋转90度 F - 前面顺时针旋转90度 F&apos; - 前面逆时针旋转90度 B - 后面顺时针旋转90度 B&apos; - 后面逆时针旋转90度 二阶魔方三阶魔方还原第一层 该层比较简单，自己摸索即可。 完成状态：以白色为底面，侧棱颜色一致。 还原第二层 前提条件：先转成倒T型,此时有两种状态。 【1】第一种状态是，将第三层中间的那块移到第二层右边那块. 口诀：U R U&#39; R&#39; U&#39; F&#39; U F 【2】第二种状态是，将第三层中间那块移到第二层左边那块。 前提条件：将对好的倒T整体转向右面（白色为底）执行下面口诀 口诀：U&#39; F&#39; U F U R U&#39; R&#39; 还原第三层【1】步骤一：拼十字 口诀：R&#39; U&#39; F&#39; U F R 【2】步骤二：还原十字所在方块的侧面和中心块的颜色一致 [2-1]一个面与中心块的颜色一致，将好的一面转向你的后面，执行口诀达到2-2效果。 口诀：R U R&#39; U R U×2 R&#39; [2-2]相邻的两面与中心块的颜色一致，将好的两面整体转到你的左面和后面，执行口诀使四个面都与中心块颜色一致 口诀：U R U R&#39; U R U×2 R&#39; 【3】步骤三：还原顶角四个方块所在的位置，即顶角包含的三个颜色要和顶角坐在的三个大面的颜色一致，将好的顶角放在你的右边，执行口诀，直到四个角的位置都正确。 口诀：U R U&#39; L&#39;U R&#39; U&#39; L 【4】步骤四：还原顶角的三个颜色，还原好一个后，将对好的角转到左边，重复步骤4，直到还原好所有的角。 口诀：R&#39; D&#39; R D 到此，一个三阶魔方就还原好了。 四阶魔方","tags":[{"name":"魔方","slug":"魔方","permalink":"http://yoursite.com/tags/魔方/"}]},{"title":"Objective-C 开发备忘录","date":"2016-08-09T05:57:03.000Z","path":"2016/08/09/Objective-C-Notebook/","text":"版权声明：本文为 muhlenXi 原创文章，欢迎转载，转载请注明来源: http://muhlenxi.com/2016/08/09/Objective-C-Notebook 导语： 俗话说，好记性不如烂笔头。学习的过程就是不断总结，不断记录的过程。做开发就要有一颗潜心阅读，潜心修炼的心，这样才能一通百通，从而从容应对开发过程中出现的问题。 我们要记住一条经验：如果程序的机制有漏洞，那么请不要低估用户利用这一漏洞的能力！ 配置备忘Xcode代码块路径 /Users/username/Library/Developer/Xcode/UserData/CodeSnippets Objective-C 调用 Swift【1】确保将项目的Target的 Build Setting -&gt; Packaging -&gt; Defines Module 设置为 YES。【2】修改Build Setting 中的 Product Module Name 为 项目名。【3】在调用的地方 导入 #import &lt;项目名-Swift.h&gt;即可。 pch文件路径$(SRCROOT)/项目名称/pch文件名 自动布局AutoLayout注意事项首先创建视图，然后将其添加到上级视图里，接下来禁用translatesAutoresizingMaskIntoConstraints,最后运用必要的约束规则。 代码备忘设置父视图的时候，只对父视图的透明度进行更改，而不影响它上面子视图的透明度。1view.backgroundColor = [[UIColor blackColor] colorWithAlphaComponent:0.5]; 使自定义 BBI，侧滑手势生效1self.navigationController.interactivePopGestureRecognizer.delegate =(id)self; 设置 navigationBar 的背景颜色 字体颜色 字体大小和类型12[UINavigationBar appearance].barTintColor = [UIColor greenColor];[UINavigationBar appearance].titleTextAttributes = [NSDictionary dictionaryWithObjectsAndKeys:[UIColor whiteColor],NSForegroundColorAttributeName, [UIFont fontWithName:@\"宋体\" size:22.0],NSFontAttributeName, nil]; 屏幕宽和高的宏定义12#define kScreenWidth [UIScreen mainScreen].bounds.size.width#define kScreenHeight [UIScreen mainScreen].bounds.size.height 根据文字调整 UILabel 的大小1[msgLabel sizeToFit]; 放弃第一响应着1[textField resignFirstResponder]; 增加 UILabel 的视差效果12345678UIInterpolatingMotionEffect * motionEffect = [[UIInterpolatingMotionEffect alloc] initWithKeyPath:@\"center.x\" type:UIInterpolatingMotionEffectTypeTiltAlongHorizontalAxis];motionEffect.minimumRelativeValue = @(-25);motionEffect.maximumRelativeValue = @(25);[msgLabel addMotionEffect:motionEffect];motionEffect = [[UIInterpolatingMotionEffect alloc] initWithKeyPath:@\"center.y\" type:UIInterpolatingMotionEffectTypeTiltAlongVerticalAxis];motionEffect.minimumRelativeValue = @(-25);motionEffect.maximumRelativeValue = @(25);[msgLabel addMotionEffect:motionEffect]; 抛异常1@throw [NSException exceptionWithName:@\"单例\" reason:@\"Use +[XYJItemsStore sharedStore]\" userInfo:nil]; 识别点击手势之前避免向 UIView 发送 touchesBegan 消息1doubleTapRecognizer.delaysTouchesBegan = YES; 弱引用1__weak typeof(self) weakSelf = self; 判断系统版本是否大于等于8.0 宏定义1#define GreaterThanEight ([[[UIDevice currentDevice] systemVersion] floatValue] &gt; 8.0) 打开或关闭网络活动指示器12[UIApplication sharedApplication].networkActivityIndicatorVisible = YES;[UIApplication sharedApplication].networkActivityIndicatorVisible = NO; 判断是 iphone 宏定义1#define IS_IPHONE (UI_USER_INTERFACE_IDIOM() == UIUserInterfaceIdiomPhone) 判断是 ipad1#define IS_IPAD (UI_USER_INTERFACE_IDIOM() == UIUserInterfaceIdiomPad) 通过通知中心监听键盘的弹出和隐藏1234[[NSNotificationCenter defaultCenter] addObserverForName:UIKeyboardWillShowNotification object:nil queue:[NSOperationQueue mainQueue] usingBlock:^(NSNotification * _Nonnull note) &#123; NSLog(@\"键盘将要弹出\"); //修改UITextView或UITextField的frame &#125;]; 1234[[NSNotificationCenter defaultCenter] addObserverForName:UIKeyboardWillHideNotification object:nil queue:[NSOperationQueue mainQueue] usingBlock:^(NSNotification * _Nonnull note) &#123; NSLog(@\"键盘将要隐藏\"); //恢复UITextView或UITextField的frame &#125;]; 获取 APP 的名称123//获取App的名成NSString *app_Name = [[NSBundle mainBundle] objectForInfoDictionaryKey:@\"CFBundleDisplayName\"];NSLog(@\"app_Name == %@\",app_Name); 设置 UIImageView 的填充样式1self.headerView.contentMode = UIViewContentModeScaleAspectFill; 设置 UITableView 内容下移1self.tableView.contentInset = UIEdgeInsetsMake(200, 0, 0, 0); 判断字符串是否是纯数字123456789101112- (BOOL) stringIsNumber:(NSString *) str&#123; //判断字符串是否是纯数字 NSString *regex =@\"[0-9]*\"; NSPredicate *pred = [NSPredicate predicateWithFormat:@\"SELF MATCHES %@\",regex]; if ([pred evaluateWithObject:str] == YES) return YES; else &#123; return NO; &#125;&#125; 拨打电话123NSString * number = @\"电话号码\"; NSMutableString * str=[[NSMutableString alloc] initWithFormat:@\"tel:%@\",number];[[UIApplication sharedApplication] openURL:[NSURL URLWithString:str]]; 使用 Auto Layout 布局时要禁用 translatesAutoresizingMaskIntoConstraints autoresizing(自动调整尺寸) 是一种由IB所使用的 Struts-and-spring式布局工具，也可以指程序代码里用到的一些相关标志，例如UIViewAutoresizingFlexibleWidth等。如果要通过这些手段来调整视图的自动调整行为，那么在定义约束规则的时候，就不应该再引用该视图了。 使用约束规则之前，应该先禁用视图中的有关属性，该属性会把涉及自动调整功能的掩码自行转换为约束规则。如果启用该属性，那么视图会通过与自动调整功能有关的掩码来参与到Auto Layout 系统里面，要是禁用它，开发者就需要自己添加约束规则。 这个与约束规则有关的属性叫做translatesAutoresizingMaskIntoConstraints，如果将其设为NO,我们就可以放心的向视图中添加自己的约束规则，而不必担心它与系统自动生成的规则想冲突。这一点非常重要。若是没有禁用该属性，就开始添加约束，则可能会引起冲突。由自动调整功能所生成的那些规则无法与开发者自己编写的这些规则和平相处。 因此在基于自动调整功能的布局和基于约束规则的布局之间进行抉择是编写代码时的一项重要任务。 图片备忘iphone 各款机型参数 导航栏和工具栏 图标尺寸 沙盒存放路径","tags":[{"name":"Objective-C Notes","slug":"Objective-C-Notes","permalink":"http://yoursite.com/tags/Objective-C-Notes/"}]},{"title":"如何阅读一本书---读书笔记","date":"2016-07-26T03:00:32.000Z","path":"2016/07/26/How-to-read-a-book/","text":"版权声明：本文为 muhlenXi 原创文章，欢迎转载，转载请注明来源: http://muhlenxi.com/2016/07/26/How-to-read-a-book 导读 《如何阅读一本书》是2004年在商务印书馆出版的图书，该书的作者是该书作者是[美] 莫提默·J. 艾德勒、查尔斯·范多伦。该书强调阅读是一种主动的活动。 阅读一般分为三种目的的阅读： 娱乐消遣、获取资讯、增进理解力。只有最后一种目的的阅读能帮助阅读者增长心智，不断成长! 本书是关于阅读的艺术，是为了增强理解力而写的。阅读，努力越多，效果越好。 读书，我们应保持金字塔模式，即基础厚实，顶端尖锐。读书太快或太慢，都将一无所获！ 基础阅读 阅读是什么？这是一个凭借着头脑运作，除了玩味读物中的一些字句之外，不假任何外助，以一己之力来提升自我的过程。你的头脑会从从粗浅的了解推进到深入的理解。而会产生这种结果的运作技巧，就是由许多不同活动所组合成的阅读的艺术。 阅读就是学习，蒙田曾说过，初学者的无知在于未学，而学者的无知在于学后。当我们在阅读的时候，我们应该在思索，这个句子在说什么呢？ 学习阅读的阶段可以分为四个： 1、阅读准备阶段，出生到六七岁为止。 2、会学习读一些简单的读物。 3、快速建立字汇的能力，根据上下文提供的线索，揭发不熟悉的字眼。 4、精练与增进前面所学的技巧。 检视阅读 这个层次的阅读，核心是，你要努力提出问题，然后尽可能地找出答案。我们应该思索的问题包括，这本书在谈些什么？这本书的架构如何？这本书包含哪些部分？这是哪一类的书-还是科学论文？ 检视阅读一：有系统的略读或粗读。 略读的步骤可以分为以下6步： 1、先看书名页，然后如果有序就先看序。 2、研究目录页，对这本书的基本架构做概括性的理解。 3、如果书中附有索引，也要检阅一下-大多数论说类的书籍都会有索引。 4、如果那是本包着书衣的新书，不妨读一下出版者的介绍。 5、从一本书的目录概略，挑几个跟主题相关的篇章来看，如有摘要说明则仔细阅读。 6、最后一步，东翻翻，西翻翻，把全书翻过一遍。 检视阅读二：粗浅的阅读。 当我们第一次阅读一本书时，我们应遵守这个规则：头一次面对一本难读的书的时候，从头到尾先读完一遍，碰到不懂的地方不要停下来查询或思索。,同时，阅读的过程避免逗留和倒退. 如何训练呢？手指顺着章节段落一动，强迫自己的眼睛跟着手部动作一动。继续练习，加快手的动作。我们要注意在阅读一本书的时候，慢不该慢到不值得，快不该快到有损于满足和理解。; 我们要提出这4个基本问题： 1、整体来说，这本书到底在谈些什么？ 2、作者细部说了什么？怎么说的？ 3、这本书说的有道理么？是全部有道理，还是部分有道理？ 4、这本书跟你有什么关系？ 要回答第一个问题，我们不妨参考以下规则： 【1】依照书本的种类与主题作分类。 【2】用最简短的句子说出整本书在谈些什么。 【3】按照顺序与关系，列出全书的重要部分。将全书的纲要拟出来之后，再将各个部分的纲要也一一列出。 【4】找出作者在问的问题，或作者想要解决的问题。 在阅读的过程中，我们可以做一下笔记，如结构笔记 、概念笔记、辩证笔记等。读书的艺术或技巧，只属于那个能养成习惯，而且能依照规则运作的人。这也是艺术家或任何领域的工匠与众不同之处。 分析阅读阶段一： 第一阶段，只需遵循这4个规则： 规则1、依照书本的种类与主题作分类。 规则2、用最简短的句子说出整本书在谈些什么。 规则3、按照顺序与关系，列出全书的重要部分。将全书的纲要拟出来之后，再将各个部分的纲要也一一列出。 规则4、找出作者在问的问题，或作者想要解决的问题。 阅读的过程中，我们会迷惑，这是一本哲学的书，还是一本科学的书，其实有个判断的小技巧。如果一本理论的书所强调的内容，超乎你日常、例行、正常生活的经验，那就是科学的书。否则就是一本哲学的书 。 阶段二： 你一定要利用上下文自己已经了解的所有字句，来推敲出你所不了解的那个字的意义。不论这个方法看起来多么像是在绕圈子，但却是唯一的方法。用你自己的话来说，是测验你懂不懂一个句子的主旨的最佳办法。 第二阶段，可以回答回答这本书的详细内容是什么？如何叙述的？同样需遵循4个规则： 规则5、诠释作者使用的关键字，与作者达成共识。 规则6、从最重要的句子中抓出作者的重要主旨。 规则7、找出作者的论述，重新架构这些论述的前因后果，以明白作者的主张。 规则8、确定作者已经解决了那些问题，还有哪些是未解决的。在未解决的问题中，确定哪些是作者认为自己无法解决的问题。 阶段三： 除非你看完一本书，否则不要看某个人的导读。这是很有必要的。 最后阶段的规则只有3个： 规则9、在你说出我同意、我不同意、或我暂缓评论之前，你一定要能肯定地说，我了解了。 规则10、当你不同意作者的观点时，要理性的表达自己的意见，不要无理地辩驳或争论。 规则11、尊重知识与个人观点的不同，在作任何评断之前，都要找出理论基础。 我们阅读的过程中，偶尔会与作者发生冲突，想要与作者辩论。理想化的辩论必须满足的条件: 【1】因为人有理性的一面，又有动物的一面，所以在争辩时就要注意你会带进去的情绪，或是在当场引发的脾气。 【2】你要把自己的前提或假设摊出来，你要知道你的偏见是什么-这也是你的预先判断。否则你就不容易接受对手也有不同假设的权利。 【3】派别之争几乎难以避免地会造成一些盲点，要化解这些盲点，应尽力尝试不偏不倚。 当我们对作者进行批评的时候，我们可以参考一下批评标准： 1、证明作者的知识不足。 2、证明作者的知识错误。。 3、证明作者不合逻辑。 4、证明作者的分析与理由是不完整的。 如何阅读其他类型的书？如何阅读实用型的书？ 我们只需问两个问题？ 1、作者的目的是什么？ 2、他建议用什么办法达到这个目的？ 规则四修改：找出作者想要你做什么 规则八修改：了解他要你这么做的目的。 如何阅读想象文学？ 阅读想象文学时，不要抗拒想象文学带给你的影响力。在想象文学中，不要去找共识、主旨或论述。那是逻辑的，不是诗的，二者完全不同。不要用适用于传递知识的，与真理一致的标准来批评小说。 小说的要素是插曲、事件、角色与他们的思想、言语、感觉及行动。其中小说的要素与整个表现的场景或背景有关，共识与主旨有关。如果说论述性作品中有任何活动，那就是论述的发展。由证据到理由到结构的一个逻辑性的演变。 只需注意以下即可： 【1】你必须将想象文学作品分类。 【2】你要能抓住整本书的大意。 【3】你不仅要能将整本书简化为大意，还要能发现整本书各个部分是如何架构起来的。 在你衷心感激作者试着为你创造的经验之前，不要批评一本想象的作品。一个好读者不会质疑作者所创造出来，然后在他自己心中又重新再创造一遍的世界。 懂得阅读方法的人，文学品位都很高。 阅读故事、戏剧与诗的一些建议 阅读故事书的建议： 快读，并且全心全意地读。 阅读希腊悲剧： 【1】记住悲剧的精髓在时间，或是说缺乏时间。 【2】我们确实知道在希腊的戏剧中，所有悲剧演员都穿一种高出地面几英寸的靴子，他们也戴面具。 阅读抒情书： 【1】不论你觉得自己懂不懂，都要一口气读完，不要停。 【2】重读一边-大声读出来。 【3】要了解一首诗，一定要去读它 - 一遍又一遍地读。 阅读历史书: 【1】对你感兴趣的事件或时期，尽可能阅读一种以上的历史书。 【2】阅读历史时，不知要关心在过去某个时间、地点真正发生了什么事，还要读懂在任何时空之中，尤其是现在，人们为什么会有如此这般行动的原因。 读者要擦亮眼睛！阅读科学著作时，你至少可以把一些比你想象的基础程度的数学读的更明白。 主题阅读 主题阅读就是能面面俱到，而自己并不预设立场。 在主题阅读中，遵循以下五个步骤可以帮助我们更好得阅读： 步骤1、找到相关的章节。 步骤2、带引作者与你达成共识。 步骤3、厘清问题。 步骤4、界定议题。 步骤5、分析讨论。 一、观察研究范围：主题阅读的准备阶段【1】针对你要研究的主题，设计一份试验性的数目。你可以参考图书馆目录、专家的建议与书中的书目索引。 【2】浏览这份书目上所有的书，确定哪些与你的主题相关，并就你的主题建立起清楚的概念。 二、主题阅读方法：阅读所有第一阶段收集到的书籍【1】浏览所有在第一阶段被认定与你主题相关的书，找出最相关的章节。 【2】根据主题创造出一套中立的词汇，带领作者与你达成共识—无论作者是否实际用到这些词汇，所有的作者， 或至少绝大部分的作者都可以用这套词汇来诠释。 【3】建立一个中立的主旨，列出一连串的问题—无论作者是否明白谈过这些问题，所有的作者，或者至少大多数 的作者都能够解读为针对这些问题提供了他们的回答。 【4】界定主要及次要的议题。然后将作者针对各个问题的不同意见整理陈列在各个议题之旁。你要记住，各个作 者之间或之中，不见得一定存在着某个议题。有时候，你需要针对一些不是作者主要关心范围的事情， 把他的观点解读，才能构造出这种议题。 【5】分析这些讨论。这得把问题和议题按顺序排列，以求突显主题。比较有共同性的议题，要放在比较没有共通性的议题之前。各个议题之间的关系也要清楚的界定出来。 注意：理想上，要一直保持对话式的疏离与客观。要做到这一点，每当你要解读某个作家对一个议题的观点时，必须从他自己的文章中引一段话来并列。 随着我们读书的数量增长和境界的提高，我们会发现： 1、当你成功的阅读了一本难读的好书之后，你的阅读技巧必然增进了。 2、一本好书能教你了解这个世界以及你自己。你不只懂得如何读的更好，还更懂得生命。你变得更有智慧，而不只是更有知识。你会成为一位智者，对人类生命中永恒的真理有更深刻的体认。 最后以一张特别形象的图来结束这篇读书笔记","tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/tags/读书笔记/"},{"name":"如何阅读一本书","slug":"如何阅读一本书","permalink":"http://yoursite.com/tags/如何阅读一本书/"}]},{"title":"iOS APP 多语言支持","date":"2016-07-07T08:47:19.000Z","path":"2016/07/07/Localized-Language/","text":"版权声明：本文为 muhlenXi 原创文章，欢迎转载，转载请注明来源: http://muhlenxi.com/2016/07/07/Localized-Language 导语： APP 根据手机系统的语言进行显示。第二种是在 APP 内自行设置语言，也就是应用内切换语言，设置的是什么语言，就显示什么语言。 写个 Demo 玩一下，实践是检验真理的唯一标准。 基础文件配置: 1、首先是添加 APP 的本地化语言支持。方法：PROJECT -&gt; Info -&gt; Localizations -&gt; 点击 + 添加。 2、添加 APP 名称本地化文件文件的名字一定要是 InfoPlist！ 方法：File -&gt; New -&gt; File... -&gt; iOS-&gt; Resource -&gt; Strings File 3、设置 InfoPlist.strings 的 Localization方法：在项目中找到并选中 InfoPlist.strings 文件，在靠右边的窗口中，选择支持的语言类型。 本例中选择的是英语、简体中文、繁体中文 4、设置对应文件的 key-value 键值对点击 InfoPlist.strings 左边的三角形符号展开该文件，分别在对应的 strings 文件中设置对应的键值对。 4-1、在 InfoPlist.strings(English) 文件中输入： 1\"CFBundleDisplayName\" = \"EnglishName\"; 4-2、在 InfoPlist.strings(Chinese(Simplified)) 文件中输入： 1\"CFBundleDisplayName\" = \"CFBundleDisplayName\" = \"中文名字\"; 保存后编译并运行就可以了。 系统语言切换:创建 Localizable 字符串文件同样的步骤，执行2-3步骤，创建一个名字为 Localizable 的strings文件，然后设置 Localizable.strings 的 Localization 。 然后执行步骤4，设置不同语言中项目所需的字符串。 本例中，我们需要设置 Alarm clock、Medicine、Setings、Find Band、test words 等字符串。 也就是说： 1-在 Localizable.strings(English) 文件中输入： 123456\"Alarm clock\" = \"Alarm clock\";\"Medicine\" = \"Medicine\";\"Setings\" = \"Setings\";\"Find Band\" = \"Find Band\";\"test words\" = \"test words\"; 2-在 Localizable.strings(Chinese(Simplified)) 文件中输入： 123456\"Alarm clock\" = \"闹钟提醒\";\"Medicine\" = \"吃药提醒\";\"Setings\" = \"设置\";\"Find Band\" = \"寻找手环\";\"test words\" = \"测试语句\"; 调用 NSLocalizedString(key, comment)方法举例： 1self.descriptionLabel.text = NSLocalizedString(@\"test words\", @\"描述文字\"); 到这里第二部分的内容基本就完了。 应用内切换语言: 应用内切换语言的思路是：每当我们添加一种语言的支持后，系统就会在我们的项目中生成对应语言的.lproj 支持文件。我们将 NSUserDefaults 将用户的语言设置保存到本地中，保存的 String 的值和下图中的文件名一样。然后通过 NSBundle 根据 .lproj 支持文件生成 bundle，最后通过 NSLocalizedStringFromTableInBundle 方法获取对应的 String 的值。 具体的做法如下：为了方便使用，我们新建一个继承 NSObject 的 XYJLanguageTool 类，用来管理我们的语言。 XYJLanguageTool.h 中的代码如下：* 123456789101112131415161718#import &lt;Foundation/Foundation.h&gt;#define XYJGetStringWithKey(key) [[XYJLanguageTool sharedInstance] getStringForKey:key]@interface XYJLanguageTool : NSObject@property (nonatomic,strong,readonly) NSBundle * bundle;// 单例初始化方法+ (id) sharedInstance;// 根据key获取相应的String- (NSString *) getStringForKey:(NSString *) key;// 应用内设置新语言- (void) setNewLanguage:(NSString *) language;@end XYJLanguageTool.m ,中的代码如下：* 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#import \"XYJLanguageTool.h\"#define Language_Key @\"languageKey\"#define Chinese_Simple @\"zh-Hans\"#define Chinese_Traditional @\"zh-Hant\"#define English_US @\"en\"@implementation XYJLanguageTool+ (id)sharedInstance&#123; static dispatch_once_t onceToken; static XYJLanguageTool * languageTool; dispatch_once(&amp;onceToken, ^&#123; languageTool = [[XYJLanguageTool alloc] init]; &#125;); return languageTool;&#125;// 根据语言名获取bundle- (NSBundle *)bundle&#123; NSString * setLanguage = [[NSUserDefaults standardUserDefaults] objectForKey:Language_Key]; //默认是简体中文 if (setLanguage == nil) &#123; setLanguage = Chinese_Simple; &#125; NSString * bundlePath = [[NSBundle mainBundle] pathForResource:setLanguage ofType:@\"lproj\"]; return [NSBundle bundleWithPath:bundlePath];&#125;// 根据key获取value- (NSString *)getStringForKey:(NSString *)key&#123; NSBundle * bundle = [[XYJLanguageTool sharedInstance] bundle]; if (bundle) &#123; return NSLocalizedStringFromTableInBundle(key, @\"Localizable\", bundle, @\"HelloWord\"); &#125; return NSLocalizedString(key, @\"HelloWord\");&#125;- (void)setNewLanguage:(NSString *)language&#123; NSString * setLanguage = [[NSUserDefaults standardUserDefaults] objectForKey:Language_Key]; if ([language isEqualToString:setLanguage]) &#123; return; &#125; // 简体中文 else if ([language isEqualToString:Chinese_Simple]) &#123; [[NSUserDefaults standardUserDefaults] setObject:Chinese_Simple forKey:Language_Key]; [[NSUserDefaults standardUserDefaults] synchronize]; &#125; // 繁体中文 else if ([language isEqualToString:Chinese_Traditional]) &#123; [[NSUserDefaults standardUserDefaults] setObject:Chinese_Traditional forKey:Language_Key]; [[NSUserDefaults standardUserDefaults] synchronize]; &#125; // 英文 else if ([language isEqualToString:English_US]) &#123; [[NSUserDefaults standardUserDefaults] setObject:English_US forKey:Language_Key]; [[NSUserDefaults standardUserDefaults] synchronize]; &#125; // 发送更新语言的通知，用于重新设置Window的RootViewController [[NSNotificationCenter defaultCenter] postNotificationName:@\"UpDateLanguageUI\" object:nil];&#125; 使用方法如下（记得导入头文件）：通过调用 XYJGetStringWithKey 方法来获取相应的字符串。 举例如下： 1self.navigationItem.title = XYJGetStringWithKey(@\"Alarm clock\"); 最后的真机运行图如下:应用内切换为英语 应用内切换为简体中文 应用内切换为繁体中文 本例中的demo已经提交到Github上，点击这里下载，欢迎提出批评和指正，最后谢谢大家！","tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://yoursite.com/tags/Objective-C/"},{"name":"多语言","slug":"多语言","permalink":"http://yoursite.com/tags/多语言/"}]},{"title":"APP 启动广告页的实现和封装","date":"2016-06-08T03:26:27.000Z","path":"2016/06/08/APP-Advertisement/","text":"版权声明：本文为 muhlenXi 原创文章，欢迎转载，转载请注明来源: http://muhlenxi.com/2017/06/08/APP-Advertisement 导语： 也许你也注意到了，现在很多 App 在启动页加载完毕后，还会出现一个 n 秒的广告页面，页面中有一个倒计时的按钮，我们可以通过点击跳过那个按钮来跳过，我们点击广告的时候，会进入广告的详情页面。如果我们不做任何操作的话，当倒计时为 0 秒是会自动进入主页面。 接下来我们就研究研究这个是如何实现的。 解决方案我们仔细想想：不妨也有两种思路来解决。 1、一种是 APP 初次运行时，将广告页面的图片 URL 和要点击广告要跳转的 URL 数据通过服务器下载下来，然后再异步下载图片数据，最后将图片的数据和跳转URL保存到本地沙盒中。第二次运行 APP 的时候会显示广告界面，这时候再通过服务器更新本地沙盒中的数据。第一次由于本地沙盒中没有数据则不会显示。目前大部分 APP 采用此方式 2、第二种是每次启动时就通过服务器异步下载图片数据和跳转 URL，然后将其显示出来。这样做的优点时，可以实时更新广告页面数据。缺点是当网络出现阻塞时或无网络时，会出现一个空白的广告界面。 针对该缺点，有一个解决思路，就是当网络不好时，用一个固定的图片和跳转 URL 来替换或者只用一个固定的图片来替换，点击广告则不跳转。但是当跳转 URL 失效时，需要通过迭代版本，重新上架来更新。 第一种方案。Demo 演示视频 传送门 XYJAdvertisementView 的实现在 Xcode 中通过 File -&gt; New -&gt;File... 新建一个继承与 UIVIew 的XYJLaunchAdvertisingView； 编写程序的核心在于要有一个完整的思路！其次为了高效率的编程，我们需要学会一些偷懒的方法，比如宏定义的使用、类型常量的使用、变量的高效命名… 【1】在 XYJAdvertisementView.h 文件中，我们需要几个宏定义和类型常量。代码如下： 12345678#define kScreenWidth [UIScreen mainScreen].bounds.size.width#define kScreenHeight [UIScreen mainScreen].bounds.size.height#define kScreenBounds [UIScreen mainScreen].boundsstatic NSString * const adImageName = @\"adImageName\";static NSString * const adDownloadUrl = @\"adDownloadUrl\";static NSInteger const adTime = 3;static NSString * const pushToADNotiName = @\"pushToADNotiName\";static NSString * const pushToADUrl = @\"pushToADUrl\"; 我们还需声明一个图片路径和一个显示广告的 show 方法。 12@property (nonatomic,copy) NSString * filePath; //!&lt; \u0010图片路径 用于属性传值- (void) showAD; //显示广告页面方法 【2】在 XYJAdvertisementView.m 文件中,在匿名类中声明我们需要的控件。 声明如下： 1234@property (nonatomic,strong) UIImageView * adImageView;@property (nonatomic,strong) UIButton * countBtn; //倒计时@property (nonatomic,strong) NSTimer * countTimer;@property (nonatomic,assign) NSInteger count; //记录当前的秒数 接下来我们依次实现相应的方法，我们要记住高内聚低耦合的原则 通过重写 initWithFrame 方法来搭建我们的UI界面 12345678910111213141516171819202122232425262728- (instancetype)initWithFrame:(CGRect)frame&#123; self = [super initWithFrame:frame]; if (self) &#123; //其他控件的初始化写在这里 //1.广告图片 _adImageView = [[UIImageView alloc] initWithFrame:frame]; _adImageView.userInteractionEnabled = YES; _adImageView.backgroundColor = [UIColor yellowColor]; _adImageView.contentMode = UIViewContentModeScaleAspectFill; _adImageView.clipsToBounds = YES; UITapGestureRecognizer * tap = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(tapGesHandle:)]; [_adImageView addGestureRecognizer:tap]; //2.跳过按钮 CGFloat btnW = 60.0f; CGFloat btnH = 30.0f; _countBtn = [[UIButton alloc] initWithFrame:CGRectMake(kScreenWidth-btnW-24, btnH, btnW, btnH)]; [_countBtn addTarget:self action:@selector(dismissAD) forControlEvents:UIControlEventTouchUpInside]; _countBtn.titleLabel.font = [UIFont systemFontOfSize:15]; [_countBtn setTitleColor:[UIColor whiteColor] forState:UIControlStateNormal]; [_countBtn setTitle:[NSString stringWithFormat:@\"跳过%ld\",adTime] forState:UIControlStateNormal]; _countBtn.backgroundColor = [UIColor colorWithRed:38/255.0 green:38/255.0 blue:38/255.0 alpha:0.6]; _countBtn.layer.cornerRadius = 4; [self addSubview:_adImageView]; [self addSubview:_countBtn]; &#125; return self;&#125; 通过 懒加载 的方式实现我们的定时器 countTimer 所谓的懒加载也就是延时加载，即当对象需要用到的时候再去加载，简单理解就是，重写对象的get方法。当我们重写get方法时，一定要注意，先要判断当前对象是否为空，为空的话再去实例化对象。 懒加载的优点如下： 1、对象的实例化在get方法中实现，可以降低耦合度。 2、不需要在viewDidLoad中再实例化对象，可以简化代码，同时增强代码的可读性。 3、有效减少内存的占用率。 代码如下： 1234567- (NSTimer *)countTimer&#123; if (_countTimer == nil) &#123; _countTimer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(countDownEventHandle) userInfo:nil repeats:YES]; &#125; return _countTimer;&#125; 实现我们的事件响应方法 1234567891011121314151617181920212223242526//广告界面点击- (void) tapGesHandle:(UITapGestureRecognizer *) tap&#123; [self dismissAD]; [[NSNotificationCenter defaultCenter] postNotificationName:pushToADNotiName object:nil userInfo:nil];&#125;//定时器响应- (void) countDownEventHandle&#123; _count--; [_countBtn setTitle:[NSString stringWithFormat:@\"跳过%ld\",_count] forState:UIControlStateNormal]; if (_count == 0) &#123; [self dismissAD]; &#125;&#125;//跳过按钮触发- (void) dismissAD&#123; [self.countTimer invalidate]; self.countTimer = nil; [UIView animateWithDuration:0.3 animations:^&#123; self.alpha = 0; &#125; completion:^(BOOL finished) &#123; [self removeFromSuperview]; &#125;];&#125; 实现我们前面声明的 Show 方法 12345678910111213141516171819//启动定时器- (void) startTimer&#123; _count = adTime; [[NSRunLoop mainRunLoop] addTimer:self.countTimer forMode:NSRunLoopCommonModes];&#125;//显示广告页面- (void)showAD&#123; [self startTimer]; UIWindow * window = [UIApplication sharedApplication].keyWindow; [window addSubview:self];&#125;//图片赋值- (void)setFilePath:(NSString *)filePath&#123; _filePath = filePath; _adImageView.image = [UIImage imageWithContentsOfFile:filePath];&#125; 到这里，我们的View就定制完成，我们还需要一个数据管理类来管理沙盒中的广告数据！ 数据管理类 XYJADDataManager 的实现通过 File -&gt; New -&gt;File... 新建一个继承与 NSObject 的 XYJADDataManager； 【1】在 XYJADDataManager.h 文件中，声明一个添加广告的方法声明。代码如下： 导入头文件： 1#import \"XYJAdvertisementView.h\" 方法声明： 1+ (void) addXYJAdvertisementView; 【2】在 XYJADDataManager.m 文件中，实现相应的方法。代码如下： 在实现show方法之前，我们要先实现一些帮助方法 通过图片的名字获取该图片在沙盒中的绝对路径 123456789+ (NSString *)getFilePathWithImageName:(NSString *)imageName&#123; if (imageName) &#123; NSArray * paths = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES); //图片默认存储在Cache目录下 return [paths[0] stringByAppendingPathComponent:imageName]; &#125; return nil;&#125; 判断该路径下是否存在文件 123456+ (BOOL)isFileExistWithFilePath:(NSString *) filePath&#123; NSFileManager * fileManager = [NSFileManager defaultManager]; BOOL isDirectory = NO; return [fileManager fileExistsAtPath:filePath isDirectory:&amp;isDirectory]; &#125; 删除旧的图片 1234567891011+ (void) deleteOldImage&#123; NSString * imageName = [[NSUserDefaults standardUserDefaults] objectForKey:adImageName]; if (imageName) &#123; NSString * filePath = [self getFilePathWithImageName:imageName]; NSFileManager * fileManager = [NSFileManager defaultManager]; if ([self isFileExistWithFilePath:filePath]) &#123; [fileManager removeItemAtPath:filePath error:nil]; &#125; &#125;&#125; 向服务器请求广告数据 该方法中要根据实际项目需求做相应调整 123456789101112131415161718+ (void) UpdateAdvertisementDataFromServer&#123; //TODO 在这里请求广告的数据，包含图片的图片路径和点击图片要跳转的URL //我们这里假设从服务器中获得的 图片的下载URl和跳转URl如下所示 NSString * imageurl = @\"http://pic.paopaoche.net/up/2012-2/20122220201612322865.png\"; NSString * pushtoURl = @\"http://www.jianshu.com\"; //获取图片名 NSString * imageName = [[imageurl componentsSeparatedByString:@\"/\"] lastObject]; //将图片名与沙盒中的数据比较 NSString * oldImageName =[[NSUserDefaults standardUserDefaults] objectForKey:adImageName]; if ((oldImageName == nil) || (![oldImageName isEqualToString:imageName]) ) &#123; //异步下载广告数据 [self downloadADImageWithUrl:imageurl iamgeName:imageName]; //保存跳转路径到沙盒中 [[NSUserDefaults standardUserDefaults] setObject:pushtoURl forKey:pushToADUrl]; [[NSUserDefaults standardUserDefaults] synchronize]; &#125; &#125; 异步下载图片数据 1234567891011121314151617181920212223+ (void) downloadADImageWithUrl:imageUrl iamgeName:(NSString *) imageName&#123;dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; //TODO 异步操作 //1、下载数据 NSData * data = [NSData dataWithContentsOfURL:[NSURL URLWithString:imageUrl]]; UIImage * image = [UIImage imageWithData:data]; //2、获取保存文件的路径 NSString * filePath = [self getFilePathWithImageName:imageName]; //3、写入文件到沙盒中 BOOL ret = [UIImagePNGRepresentation(image) writeToFile:filePath atomically:YES]; if (ret) &#123; NSLog(@\"广告图片保存成功\"); [self deleteOldImage]; //保存\u0010图片名和下载路径 [[NSUserDefaults standardUserDefaults] setObject:imageName forKey:adImageName]; [[NSUserDefaults standardUserDefaults] setObject:imageUrl forKey:adDownloadUrl]; [[NSUserDefaults standardUserDefaults] synchronize]; &#125; else &#123; NSLog(@\"广告图片保存失败\"); &#125; &#125;);&#125; 实现 addXYJAdvertisementView 方法 12345678910111213141516171819+ (void) addXYJAdvertisementView;&#123; //1.判断沙盒中是否存在广告的图片名字和图片数据，如果有则显示 NSString * imageName = [[NSUserDefaults standardUserDefaults] objectForKey:adImageName]; if (imageName != nil) &#123; NSString * filePath = [self getFilePathWithImageName:imageName]; BOOL isExist = [self isFileExistWithFilePath:filePath]; //本地存在图片 if (isExist) &#123; NSLog(@\"本地存在图片\"); XYJAdvertisementView * adView = [[XYJAdvertisementView alloc] initWithFrame:kScreenBounds]; adView.filePath = filePath; [adView showAD]; &#125;&#125; //更新本地广告数据 [self UpdateAdvertisementDataFromServer];&#125; 最后一步，在 AppDelegate 文件中添加广告 1、在 AppDelegate.h 文件中导入 XYJADDataManager.h 文件 。 2、在 didFinishLaunchingWithOptions 方法中加入如下代码即可。 12//添加启动广告[XYJADDataManager addXYJAdvertisementView]; 3、如果你需要获取广告点击事件，则需要进行如下操作。 在主界面ViewController的 viewDidLoad 方法中添加： 12//添加广告点击的监听 [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(pushToADVC) name:pushToADNotiName object:nil]; 同时实现事件响应方法： 12345678- (void) pushToADVC&#123; //TODO 在这里处理广告事件响应 NSLog(@\"广告点击了\"); XYJADWebViewController * webVC = [[XYJADWebViewController alloc] init]; webVC.url = [[NSUserDefaults standardUserDefaults] objectForKey:pushToADUrl]; [self.navigationController pushViewController:webVC animated:YES];&#125; 编译运行后，会发现跟我们前面的效果展示是一样的。 点这里下载完整 Demo 目前暂无实现第二种方案 感谢阅读，有什么意见可以给我留言","tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://yoursite.com/tags/Objective-C/"},{"name":"XYJLaunchAdvertisingView","slug":"XYJLaunchAdvertisingView","permalink":"http://yoursite.com/tags/XYJLaunchAdvertisingView/"}]},{"title":"iOS实现应用外自带地图、高德地图、百度地图导航","date":"2016-05-19T02:42:54.000Z","path":"2016/05/19/Map-Guide/","text":"版权声明：本文为 muhlenXi 原创文章，欢迎转载，转载请注明来源: http://muhlenxi.com/2016/05/19/Map-Guide 导语： 在地图类应用开发中，我们经常有导航这个功能需求。根据导航方式可以分为应用内导航和应用外导航，其中应用内导航指的是使用第三方提供的地图 SDK（高德、百度等）将导航嵌入到我们开发的 APP 内部。应用外导航指的是以 URL Scheme 跳转的方式，跳转到对应的地图 APP 中，使用对方的导航功能。 点击阅读全文来了解一下详情吧。 本次开发的需求是，实现应用外导航。通过选项列表（UIAlertController、UIActionSheet）的方式提供用户选择，当用户既安装了高德地图和百度地图时，则弹出如下图所示的选项列表。否则用户安装了哪个地图，就增加哪个地图的选择项。 环境的配置在iOS 9 下涉及到平台客户端跳转，系统会自动到项目 info.plist 下检测是否设置平台 Scheme，对于需要配置的平台，如果没有配置，将无法正常跳转平台客户端，因此需要配置 Scheme 名单。本文我们需要添加百度地图和高德地图的 scheme 白名单。 具体方法：在项目的 info.plist 中添加 LSApplicationQueriesSchemes 字段，类型是 Array，然后添加两个 Item。 如图： 根据系统的版本号来初始化对应选项列表我们需要一个属性来记录导航目标的终点坐标 1@property (nonatomic,assign) CLLocationCoordinate2D coordinate; //!&lt; 要导航的坐标 在 viewDidLoad 中初始化该坐标值。 12//导航到深圳火车站self.coordinate = CLLocationCoordinate2DMake(22.53183, 114.117206); 我们再定义一个判断系统版本是否大于等于 8.0 的一个宏定义 12//系统版本号是否大于8.0#define IS_SystemVersionGreaterThanEight ([UIDevice currentDevice].systemVersion.doubleValue &gt;= 8.0) 在低于8.0的系统版本中使用 UIAlertController 会崩溃，所以我们要根据系统版本号来选择合适的选项列表。 在导航按钮的事件响应方法中，我们添加如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475//系统版本高于8.0，使用UIAlertController if (IS_SystemVersionGreaterThanEight) &#123; UIAlertController * alertController = [UIAlertController alertControllerWithTitle:@\"导航到设备\" message:nil preferredStyle:UIAlertControllerStyleActionSheet]; //自带地图 [alertController addAction:[UIAlertAction actionWithTitle:@\"自带地图\" style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) &#123; NSLog(@\"alertController -- 自带地图\"); //使用自带地图导航 MKMapItem *currentLocation =[MKMapItem mapItemForCurrentLocation]; MKMapItem *toLocation = [[MKMapItem alloc] initWithPlacemark:[[MKPlacemark alloc] initWithCoordinate:self.coordinate addressDictionary:nil]]; [MKMapItem openMapsWithItems:@[currentLocation,toLocation] launchOptions:@&#123;MKLaunchOptionsDirectionsModeKey:MKLaunchOptionsDirectionsModeDriving, MKLaunchOptionsShowsTrafficKey:[NSNumber numberWithBool:YES]&#125;]; &#125;]]; //判断是否安装了高德地图，如果安装了高德地图，则使用高德地图导航 if ( [[UIApplication sharedApplication] canOpenURL:[NSURL URLWithString:@\"iosamap://\"]]) &#123; [alertController addAction:[UIAlertAction actionWithTitle:@\"高德地图\" style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) &#123; NSLog(@\"alertController -- 高德地图\"); NSString *urlsting =[[NSString stringWithFormat:@\"iosamap://navi?sourceApplication= &amp;backScheme= &amp;lat=%f&amp;lon=%f&amp;dev=0&amp;style=2\",self.coordinate.latitude,self.coordinate.longitude]stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding]; [[UIApplication sharedApplication]openURL:[NSURL URLWithString:urlsting]]; &#125;]]; &#125; //判断是否安装了百度地图，如果安装了百度地图，则使用百度地图导航 if ([[UIApplication sharedApplication] canOpenURL:[NSURL URLWithString:@\"baidumap://\"]]) &#123; [alertController addAction:[UIAlertAction actionWithTitle:@\"百度地图\" style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) &#123; NSLog(@\"alertController -- 百度地图\"); NSString *urlsting =[[NSString stringWithFormat:@\"baidumap://map/direction?origin=&#123;&#123;我的位置&#125;&#125;&amp;destination=latlng:%f,%f|name=目的地&amp;mode=driving&amp;coord_type=gcj02\",self.coordinate.latitude,self.coordinate.longitude] stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding]; [[UIApplication sharedApplication] openURL:[NSURL URLWithString:urlsting]]; &#125;]]; &#125; //添加取消选项 [alertController addAction:[UIAlertAction actionWithTitle:@\"取消\" style:UIAlertActionStyleCancel handler:^(UIAlertAction * _Nonnull action) &#123; [alertController dismissViewControllerAnimated:YES completion:nil]; &#125;]]; //显示alertController [self presentViewController:alertController animated:YES completion:nil]; &#125; else &#123; //系统版本低于8.0，则使用UIActionSheet UIActionSheet * actionsheet = [[UIActionSheet alloc] initWithTitle:@\"导航到设备\" delegate:self cancelButtonTitle:@\"取消\" destructiveButtonTitle:nil otherButtonTitles:@\"自带地图\", nil]; //如果安装高德地图，则添加高德地图选项 if ( [[UIApplication sharedApplication] canOpenURL:[NSURL URLWithString:@\"iosamap://\"]]) &#123; [actionsheet addButtonWithTitle:@\"高德地图\"]; &#125; //如果安装百度地图，则添加百度地图选项 if ([[UIApplication sharedApplication] canOpenURL:[NSURL URLWithString:@\"baidumap://\"]]) &#123; [actionsheet addButtonWithTitle:@\"百度地图\"]; &#125; [actionsheet showInView:self.view]; &#125; 实现 UIActionSheetDelegate 代理方法当使用 UIActionSheet 时，需要设置 Delegate 为 self ,并且遵循 UIActionSheetDelegate 协议，实现相应代理方法。 当点击取消选项时，会触发该代理方法 1234567#pragma mark - UIActionSheetDelegate- (void)actionSheetCancel:(UIActionSheet *)actionSheet&#123; NSLog(@\"ActionSheet - 取消了\"); [actionSheet removeFromSuperview];&#125; 当点击其他选项是，则会触发下面的代理方法 使用自带地图导航时，需要用到 MKMapItem ,我们需要导入头文件 #import &lt;MapKit/MapKit.h&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960- (void)actionSheet:(UIActionSheet *)actionSheet clickedButtonAtIndex:(NSInteger)buttonIndex&#123; NSLog(@\"numberOfButtons == %ld\",actionSheet.numberOfButtons); NSLog(@\"buttonIndex == %ld\",buttonIndex); if (buttonIndex == 0) &#123; NSLog(@\"自带地图触发了\"); MKMapItem *currentLocation =[MKMapItem mapItemForCurrentLocation]; MKMapItem *toLocation = [[MKMapItem alloc] initWithPlacemark:[[MKPlacemark alloc] initWithCoordinate:self.coordinate addressDictionary:nil]]; [MKMapItem openMapsWithItems:@[currentLocation,toLocation] launchOptions:@&#123;MKLaunchOptionsDirectionsModeKey:MKLaunchOptionsDirectionsModeDriving, MKLaunchOptionsShowsTrafficKey:[NSNumber numberWithBool:YES]&#125;]; &#125; //既安装了高德地图，又安装了百度地图 if (actionSheet.numberOfButtons == 4) &#123; if (buttonIndex == 2) &#123; NSLog(@\"高德地图触发了\"); NSString *urlsting =[[NSString stringWithFormat:@\"iosamap://navi?sourceApplication= &amp;backScheme= &amp;lat=%f&amp;lon=%f&amp;dev=0&amp;style=2\",self.coordinate.latitude,self.coordinate.longitude]stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding]; [[UIApplication sharedApplication]openURL:[NSURL URLWithString:urlsting]]; &#125; if (buttonIndex == 3) &#123; NSLog(@\"百度地图触发了\"); NSString *urlsting =[[NSString stringWithFormat:@\"baidumap://map/direction?origin=&#123;&#123;我的位置&#125;&#125;&amp;destination=latlng:%f,%f|name=目的地&amp;mode=driving&amp;coord_type=gcj02\",self.coordinate.latitude,self.coordinate.longitude] stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding]; [[UIApplication sharedApplication] openURL:[NSURL URLWithString:urlsting]]; &#125; &#125; //安装了高德地图或安装了百度地图 if (actionSheet.numberOfButtons == 3) &#123; if (buttonIndex == 2) &#123; if ( [[UIApplication sharedApplication] canOpenURL:[NSURL URLWithString:@\"iosamap://\"]]) &#123; NSLog(@\"只安装的高德地图触发了\"); NSString *urlsting =[[NSString stringWithFormat:@\"iosamap://navi?sourceApplication= &amp;backScheme= &amp;lat=%f&amp;lon=%f&amp;dev=0&amp;style=2\",self.coordinate.latitude,self.coordinate.longitude]stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding]; [[UIApplication sharedApplication]openURL:[NSURL URLWithString:urlsting]]; &#125; if ([[UIApplication sharedApplication] canOpenURL:[NSURL URLWithString:@\"baidumap://\"]]) &#123; NSLog(@\"只安装的百度地图触发了\"); NSString *urlsting =[[NSString stringWithFormat:@\"baidumap://map/direction?origin=&#123;&#123;我的位置&#125;&#125;&amp;destination=latlng:%f,%f|name=目的地&amp;mode=driving&amp;coord_type=gcj02\",self.coordinate.latitude,self.coordinate.longitude] stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding]; [[UIApplication sharedApplication] openURL:[NSURL URLWithString:urlsting]]; &#125; &#125; &#125; &#125; 知识点补充【1】使用 canOpenURL 方法来检测该手机是否安装相应 APP。 该方法会返回一个 BOOL 值，当为 YES 时，表明已安装该 APP 1[[UIApplication sharedApplication] canOpenURL:[NSURL URLWithString:@\"iosamap://\"]] 常用的4个地图的 URL Scheme： 1、苹果自带地图（不需要检测，所以不需要URL Scheme） 2、百度地图 baidumap:// 3、高德地图 iosamap:// 4、谷歌地图 comgooglemaps:// 点击这里查看更多常用的URL Scheme 对URL Scheme不了解的点这里 如何自定义URL Scheme点这里 【2】wgs84，gcj-02,bd-09是什么? wgs84是国际标准，从GPS设备中取出的原始数据就是这个标准的数据，iOS的SDK中用到的坐标系统也是国际标准的坐标系统WGS-84； gcj-02是中国标准，行货GPS设备取出的原始数据是该标准的数据，根据规定，国内出版的各种地图系统，必须至少采用gcj-02对地理位置进行首次加密。网络上也称之为火星坐标。 bd-09是百度标准，百度SDK使用的就是这个标准。 如何进行转换点这里 运行结果图示以下是选择了不同的选项对应的结果图。 自带地图导航。 高德地图导航。 百度地图导航。 感谢阅读，有什么意见可以给我留言!","tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://yoursite.com/tags/Objective-C/"},{"name":"地图导航","slug":"地图导航","permalink":"http://yoursite.com/tags/地图导航/"}]},{"title":"高德 SDK 的正确打开方式","date":"2016-04-07T02:02:20.000Z","path":"2016/04/07/Gaode-Map/","text":"版权声明：本文为 muhlenXi 原创文章，欢迎转载，转载请注明来源: http://muhlenxi.com/2016/04/07/Gaode-Map 导语： 高德地图 iOS SDK 是一套基于 iOS 6.0.0 及以上版本的地图应用程序开发接口，供开发者在自己的 iOS应用中加入地图相关的功能。通过 iOS SDK，开发者可以轻松地开发出地图显示与操作、兴趣点搜索、地理编码、路线规划等功能。 点击下载本文的demo研究，记得给star支持博主的努力哦！ 点击阅读全文来瞅瞅如何开发吧。 由于官方文档更新不及时，很多方法弃用了，新的方法只能自己摸索了。本文大部分是参考官方文档来做的。 点这里查看高德开发平台,在这里注册高德账号并成为开发者。 如果是第一次接触高德地图，可以大概看一下入门指南 高德地图SDK的部署由于我喜欢简单粗暴的部署方式，所以一直选择 CocoaPods 来安装和配置第三方库。 关于 CocoaPods,不了解的可以看一下我的另一篇博文，zsh的配置和CocoaPods的安装与使用。这里就不详细展开了。 方法就是，使用 终端cd 到你的项目所在的路径下，vim 一个 Podfile 文件，点击 字母i 进入编辑状态，在文件中输入： 123456platform:ios,'7.0'target 'gaodeMapDemo' dopod 'AMap2DMap', '~&gt; 3.3.0'pod 'AMapLocation', '~&gt; 1.2.0' #定位SDKpod 'AMapSearch' #搜索服务SDKend 然后按下 Esc，shift+：然后输入 wq ，最后 终端 输入 pod install --verbose --no-repo-update 安装即可。 高德地图SDK的打开方式点这里查看高德地图 iOS SDK。 配置好就可以正式干活了，我们先导入高德地图的头文件 #import &lt;MAMapKit/MAMapKit.h&gt; 先来一个屏幕宽和高的宏定义吧。 12#define kScreenWidth [UIScreen mainScreen].bounds.size.width#define kScreenHeight [UIScreen mainScreen].bounds.size.height 再声明一个 mapView 的属性。 1@property (nonatomic,strong) MAMapView * mapView; 添加地图自定义一个设置地图的方法 setupMap 1234567891011121314//设置高德地图- (void) setupMap&#123; [MAMapServices sharedServices].apiKey = gaode_key; self.mapView = [[MAMapView alloc] initWithFrame:CGRectMake(0, 0, kScreenWidth, kScreenHeight)]; [self.view addSubview:self.mapView]; //设置地图模式 // MAMapTypeSatellite // 卫星地图 // MAMapTypeStandard // 普通地图 self.mapView.mapType = MAMapTypeStandard; &#125; 在 viewDidLoad 中调用这个方法，然后 编译运行，看看添加的地图长啥样。 会发现基本长这样： 卫星地图 基本长这样： 显示实时路况，默认是不显示的 1self.mapView.showTraffic = YES; 不显示比例尺，默认是显示的,可以通过 compassOrigin 属性可改变指南针的显示位置。 123self.mapView.showsScale = NO;//设置比例尺位置self.mapView.scaleOrigin= CGPointMake(_mapView.scaleOrigin.x, 82); 不显示罗盘，默认是显示的,可以通过 scaleOrigin 属性可改变改变比例尺的显示位置 123self.mapView.showsCompass = NO;//设置指南针位置self.mapView.compassOrigin= CGPointMake(_mapView.compassOrigin.x, 82); 高德地图的 Logo 不能移除，可以通过 logoCenter 属性来调整 Logo 的显示位置。 12//显示logo在右下角self.mapView.logoCenter = CGPointMake(kScreenWidth-55, kScreenHeight-13); 设置地图的中心坐标和显示范围点这里坐标拾取器来获取经纬度吧。 写一个根据经纬度和跨度来设置地图显示范围的方法 12345678910- (void) setMapViewDisplayAreaWithLatitude:(double)lati andLongitude:(double) longi Span:(double) span_value&#123; CLLocationCoordinate2D center = &#123;lati,longi&#125;; MACoordinateSpan span = &#123;span_value,span_value&#125;; MACoordinateRegion region = &#123;center,span&#125;; [self.mapView setRegion:region animated:YES];&#125; 在 viewDidLoad 中调用这个方法。 1234//设置显示区域为深圳展滔科技大厦114.038072,22.639641 double lati = 22.639641; double longi = 114.038072; [self setMapViewDisplayAreaWithLatitude:lati andLongitude:longi Span:0.02]; 然后编译运行，结果如下。 添加系统样式的标注标注可以精确表示用户需要展示的位置信息，高德地图SDK提供的标注功能允许用户自定义图标和信息窗，同时提供了标注的点击、拖动事件的回调。 写一个根据经纬度添加系统样式标注的方法 12345678910//添加默认样式的点标记，即大头针- (void) addPointAnnotationWithLatitude:(double)lati andLongitude:(double) longi Title:(NSString *) title Subtitle:(NSString *) subtitle&#123; MAPointAnnotation * pointAnnotation = [[MAPointAnnotation alloc] init]; pointAnnotation.coordinate = CLLocationCoordinate2DMake(lati, longi); pointAnnotation.title = title; pointAnnotation.subtitle = subtitle; [self.mapView addAnnotation:pointAnnotation];&#125; 在 viewDidLoad 中添加标注 12//添加系统样式标注[self addPointAnnotationWithLatitude:lati andLongitude:longi Title:@\"展滔科技大厦\" Subtitle:@\"深圳市宝安区民治大道1079号\"]; 此时编译运行的话，地图上仅仅显示一个红色的大头针，点击大头针没任何反应 我们在软件开发中，设计到协议、代理、回调方法时，一定要切记这三步曲！ 第一步：遵循协议。 第二步：设置代理（这步千万不能忘）！ 第三步：实现相应代理方法。 第一步遵循 &lt;MAMapViewDelegate&gt; 协议。 1@interface RootViewController ()&lt;MAMapViewDelegate&gt; 第二步设置代理，在 setupMap 方法中加入如下代码。 12//设置地图的代理self.mapView.delegate = self; 第三步通过实现协议中的 mapView:viewForAnnotation: 回调函数，设置标注样式. 1234567891011121314151617181920212223242526#pragma mark - MAMapViewDelegate- (MAAnnotationView *)mapView:(MAMapView *)mapView viewForAnnotation:(id&lt;MAAnnotation&gt;)annotation&#123; if ([annotation isKindOfClass:[MAPointAnnotation class]]) &#123; //复用标识符 static NSString * pointReuseIndentifier = @\"pointReuseIndentifier\"; MAPinAnnotationView * annotationView = (MAPinAnnotationView*)[mapView dequeueReusableAnnotationViewWithIdentifier:pointReuseIndentifier]; if (annotationView == nil) &#123; annotationView = [[MAPinAnnotationView alloc] initWithAnnotation:annotation reuseIdentifier:pointReuseIndentifier]; &#125; //设置气泡可以弹出，默认为NO annotationView.canShowCallout= YES; //设置标注动画显示，默认为NO annotationView.animatesDrop = YES; //设置标注可以拖动，默认为NO annotationView.draggable = YES; //设置大头针的颜色，有MAPinAnnotationColorRed, MAPinAnnotationColorGreen, MAPinAnnotationColorPurple三种 annotationView.pinColor = MAPinAnnotationColorPurple; return annotationView; &#125; return nil;&#125; 此时编译并运行代码，地图上会显示一个紫色的大头针，点击大头针会弹出一个气泡，气泡中显示设置的标题和副标题。如图所示： 添加一组标注用这个方法 123//数组中存放的是MAPointAnnotation的对象NSArray * array = @[pointAnnotation];[self.mapView addAnnotations:array]; 删除一个标注 1[self.mapView removeAnnotation:pointAnnotation]; 删除一组标注 123//数组中存放的是要删除的标注，也是MAPointAnnotation的对象NSArray * array = @[pointAnnotation]; [self.mapView removeAnnotations:array]; 添加自定义样式的标注自定义标注的效果如图所示： 如果想实现这个效果，我们需要自定义两个 View。 1、CustomCalloutView : UIView //自定义的气泡 2、CustomAnnotationView : MAAnnotationView //自定义的标注View 新建我们的CustomCalloutView：在 CustomCalloutView.h 文件中声明我们需要的属性： 123@property (nonatomic,strong) UIImage * thumbnail; //!&lt; 缩略图片@property (nonatomic,copy) NSString * title; //!&lt; 标题@property (nonatomic,copy) NSString * address; //!&lt; 地址 在 CustomCalloutView.m 文件中 新建一个匿名类（类扩展） 声明我们需要的控件： 12345678@interface CustomCalloutView ()@property (nonatomic,strong) UIImageView * thumbnailImageView; //!&lt; 缩略图@property (nonatomic,strong) UILabel * titleLabel; //!&lt; 标题Label@property (nonatomic,strong) UILabel * addressLabel; //!&lt; 地址Label@end 重写 - (instancetype)initWithFrame:(CGRect)frame 方法，初始化我们的控件 1234567891011121314151617181920212223242526272829303132- (instancetype)initWithFrame:(CGRect)frame&#123; self = [super initWithFrame:frame]; if (self) &#123; //其他控件的初始化写在这里 self.backgroundColor = [UIColor clearColor]; //初始化缩略图 self.thumbnailImageView = [[UIImageView alloc] initWithFrame:CGRectMake(5, 5, 70, 50)]; self.thumbnailImageView.backgroundColor = [UIColor yellowColor]; [self addSubview:self.thumbnailImageView]; //初始化标题Label self.titleLabel = [[UILabel alloc] initWithFrame:CGRectMake(5+70+5, 5, 120-8, 20)]; self.titleLabel.font = [UIFont systemFontOfSize:14]; self.titleLabel.textColor = [UIColor whiteColor]; self.titleLabel.text = @\"title\"; [self addSubview:self.titleLabel]; //初始化地址Label self.addressLabel = [[UILabel alloc] initWithFrame:CGRectMake(5+70+5, 20, 120-8, 20*2)]; self.addressLabel.font = [UIFont systemFontOfSize:12]; self.addressLabel.numberOfLines = 0; self.addressLabel.textColor = [UIColor lightGrayColor]; self.addressLabel.text = @\"address\"; [self addSubview:self.addressLabel]; &#125; return self;&#125; 重写 CustomCalloutView.h 文件中声明的属性的 Setter 方法，方便我们给控件赋值： 1234567891011121314- (void)setTitle:(NSString *)title&#123; self.titleLabel.text = title;&#125;- (void)setAddress:(NSString *)address&#123; self.addressLabel.text = address;&#125;- (void)setThumbnail:(UIImage *)thumbnail&#123; self.thumbnailImageView.image = thumbnail;&#125; 最后重写 - (void)drawRect:(CGRect)rect 方法绘制我们气泡的背景和添加阴影效果： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859- (void)drawRect:(CGRect)rect&#123; //绘制曲线 CGContextRef contextRef = UIGraphicsGetCurrentContext(); CGContextSetLineWidth(contextRef, 2.0f); CGContextSetFillColorWithColor(contextRef, [UIColor colorWithRed:0.3 green:0.3 blue:0.3 alpha:0.8].CGColor); CGRect calloutRect = self.bounds; CGFloat radius = 6.0; CGFloat triangleHeight = 10; //倒三角的高度 CGFloat x = CGRectGetMinX(calloutRect); CGFloat midX = CGRectGetMidX(calloutRect); CGFloat width = CGRectGetMaxX(calloutRect); CGFloat y = CGRectGetMinY(calloutRect); CGFloat height = CGRectGetMaxY(calloutRect)-10; //用起始点开始 CGContextMoveToPoint(contextRef, x+radius, y); //画上面的直线 CGContextAddLineToPoint(contextRef, x+width-radius, y); //画右上角圆弧 CGContextAddArcToPoint(contextRef, x+width, y, x+width, y+radius, radius); //画右边的直线 CGContextAddLineToPoint(contextRef, x+width, y+height-radius); //画右下角弧线 CGContextAddArcToPoint(contextRef, x+width, y+height, x+width-radius, y+height, radius); //画倒三角靠右的下边的直线 CGContextAddLineToPoint(contextRef, midX+triangleHeight, y+height); //画倒三角 CGContextAddLineToPoint(contextRef, midX, y+height+triangleHeight); CGContextAddLineToPoint(contextRef, midX-triangleHeight, y+height); //画倒三角靠左的下边的直线 CGContextAddLineToPoint(contextRef, x+radius, y+height); //画左下角的弧线 CGContextAddArcToPoint(contextRef, x, y+height, x, y+height-radius, radius); //画左边的直线 CGContextAddLineToPoint(contextRef, x, y+radius); //画左上角的弧线 CGContextAddArcToPoint(contextRef, x, y, x+radius, y, radius); CGContextClosePath(contextRef); CGContextFillPath(contextRef); //添加阴影 self.layer.shadowColor = [[UIColor blackColor] CGColor]; //阴影的透明度 self.layer.shadowOpacity = 1.0f; //阴影的偏移 self.layer.shadowOffset = CGSizeMake(0, 0);&#125; 到这里我们的自定义气泡就大功告成了！ 新建我们的CustomAnnotationView：新建一个继承自 MAAnnotationView 的CustomAnnotationView，在 CustomAnnotationView.h文件中，导入前面的自定义气泡的头文件： #import &quot;CustomCalloutView.h&quot; 声明一个气泡的属性： 12@property (nonatomic,strong) CustomCalloutView * calloutView;\u0010 在 CustomAnnotationView.m 文件中重写标注选中的方法 - (void)setSelected:(BOOL)selected animated:(BOOL)animated: 1234567891011121314151617181920212223242526272829303132//重写选中方法setSelected- (void)setSelected:(BOOL)selected animated:(BOOL)animated&#123; if (self.selected == selected) &#123; return; &#125; if (selected == YES) &#123; //如果气泡为空则初始化气泡 if (self.calloutView == nil) &#123; self.calloutView = [[CustomCalloutView alloc] initWithFrame:CGRectMake(0, 0, 200, 70)]; //设置气泡的中心点 CGFloat center_x = self.bounds.size.width/2; CGFloat center_y = -self.bounds.size.height; self.calloutView.center = CGPointMake(center_x, center_y); &#125; //给calloutView赋值 self.calloutView.thumbnail = [UIImage imageNamed:@\"zhantao\"]; self.calloutView.title = self.annotation.title; self.calloutView.address = self.annotation.subtitle; [self addSubview:self.calloutView]; &#125; else &#123; //移除气泡 [self.calloutView removeFromSuperview]; &#125; [super setSelected:selected animated:animated];&#125; 到这里我们的自定义标注View也完成了，接下来就能使用了 在我们的地图的标注回调函数 mapView: viewForAnnotation: 中设置我们的CustomAnnotationView： 1234567891011121314151617181920212223- (MAAnnotationView *)mapView:(MAMapView *)mapView viewForAnnotation:(id&lt;MAAnnotation&gt;)annotation&#123; if ([annotation isKindOfClass:[MAPointAnnotation class]]) &#123; static NSString * reuseIndetifier = @\"annotationReuseIndetifier\"; CustomAnnotationView * annotationView = (CustomAnnotationView *)[mapView dequeueReusableAnnotationViewWithIdentifier:reuseIndetifier]; if (annotationView == nil) &#123; annotationView = [[CustomAnnotationView alloc] initWithAnnotation:annotation reuseIdentifier:reuseIndetifier]; annotationView.image = [UIImage imageNamed:@\"dingfen\"]; ///设置中心点偏移，使得标注底部中间点成为经纬度对应点 annotationView.centerOffset = CGPointMake(0, -15); return annotationView; &#125; &#125; return nil;&#125; 如果没问题的话，运行的结果会和前面提到的效果图一致的！ 标注移动的回调处理当我们长按住大头针时会移动大头针在地图上的位置。高德地图会回调如下方法 123456789101112131415//移动标注会调用这个方法- (void)mapView:(MAMapView *)mapView annotationView:(MAAnnotationView *)view didChangeDragState:(MAAnnotationViewDragState)newState fromOldState:(MAAnnotationViewDragState)oldState&#123; //标注停止移动时 if (newState == MAAnnotationViewDragStateEnding) &#123; //获取标注新的位置所在的经纬度坐标 CGPoint endPoint = view.centerOffset; CLLocationCoordinate2D coo = [mapView convertPoint:endPoint toCoordinateFromView:view]; NSLog(@\"移动后大头针的经纬度：latitude = %f longitude = %f\",coo.latitude,coo.longitude); &#125;&#125; 在地图上移动大头针后，会输出如下结果： 2016-09-27 16:49:35.255 gaodeMapDemo[5930:2794113] 移动后大头针的经纬度：latitude = 22.646707 longitude = 114.035228 添加折线官网中指导的代理回调方法已经弃用了，还未做出更新！ 自定义一个绘制折线的方法，代码中的坐标需要根据实际项目需求调整 123456789101112131415161718192021222324252627282930313233//绘制折线- (void) addPolyLineOnMap&#123; NSInteger count = 5; CLLocationCoordinate2D commonPolylineCoords[count]; //起点：展滔科技大厦 commonPolylineCoords[0].latitude = 22.639641; commonPolylineCoords[0].longitude = 114.038072; //北站114.02887,22.609235 commonPolylineCoords[1].latitude = 22.609235; commonPolylineCoords[1].longitude = 114.02887; //民乐地铁站114.048809,22.594144 commonPolylineCoords[2].latitude = 22.594144; commonPolylineCoords[2].longitude = 114.048809; //东站114.119699,22.60225 commonPolylineCoords[3].latitude = 22.60225; commonPolylineCoords[3].longitude = 114.119699; //终点：坂田114.06942,22.634804 commonPolylineCoords[4].latitude = 22.634804; commonPolylineCoords[4].longitude = 114.06942; //构造折线对象 MAPolyline *commonPolyline = [MAPolyline polylineWithCoordinates:commonPolylineCoords count:count]; //在地图上添加折线对象 [self.mapView addOverlay: commonPolyline];&#125; 实现协议中的 mapView:rendererForOverlay: 回调函数，设置折线样式。 12345678910111213141516171819202122- (MAOverlayRenderer *)mapView:(MAMapView *)mapView rendererForOverlay:(id&lt;MAOverlay&gt;)overlay&#123; if ([overlay isKindOfClass:[MAPolyline class]]) &#123; NSLog(@\" MAPolylineRenderer 调用了\"); MAPolylineRenderer * lineRenderer = [[ MAPolylineRenderer alloc] initWithOverlay:overlay]; //折线宽度 lineRenderer.lineWidth = 5.0f; //折线的颜色 lineRenderer.strokeColor = [UIColor blueColor]; //折线起始点类型 lineRenderer.lineJoin = kCGLineJoinBevel; //折线终点类型 lineRenderer.lineCap = kCGLineJoinBevel; return lineRenderer; &#125; return nil;&#125; 在ViewDidLoad中调用该方法添加折线： 12//添加折线[self addPolyLineOnMap]; 编译并运行代码，会出现一条蓝色的折线。如图所示： 删除折线 12//commonPolyline是要删除的折线，是MAPolyline的对象[self.mapView removeOverlay:commonPolyline]; 添加圆形覆盖物首先，在 viewDidLoad 中添加如下代码来添加圆圈: 123//添加圆形覆盖物，radius指的是圆圈的半径MACircle *Circle1 = [MACircle circleWithCenterCoordinate:CLLocationCoordinate2DMake(lati, longi) radius:500];[self.mapView addOverlay:Circle1]; 然后，在协议中的 mapView:rendererForOverlay: 回调函数，中添加代码来设置圆圈样式。 将下面的代码加到 return nil; 的前面！ 12345678910111213141516//如果是圆形覆盖物if ( [overlay isKindOfClass:[MACircle class]]) &#123; NSLog(@\" MACircleRenderer 调用了\"); MACircleRenderer * circleRenderer = [[MACircleRenderer alloc] initWithOverlay:overlay]; //设置圆圈的圆边的宽度 circleRenderer.lineWidth = 3.0f; //圆边的颜色 circleRenderer.strokeColor = [UIColor colorWithRed:236/255.0 green:65/255.0 blue:110/255.0 alpha:0.8]; //设置圆圈的填充颜色 circleRenderer.fillColor = [UIColor colorWithRed:236/255.0 green:65/255.0 blue:110/255.0 alpha:0.3]; return circleRenderer; &#125; 编译运行代码，刚添加的圆圈如下所示： 如果想在移动标注的时候删除圈圈，然后在新的标注点添加圆圈，需要修改 didChangeDragState 代理方法中的代码！，修改如下： 123456789101112131415161718192021222324252627282930313233343536373839//移动标注会调用这个方法- (void)mapView:(MAMapView *)mapView annotationView:(MAAnnotationView *)view didChangeDragState:(MAAnnotationViewDragState)newState fromOldState:(MAAnnotationViewDragState)oldState&#123; //标注移动时 if (newState == MAAnnotationViewDragStateStarting) &#123; NSArray * overlays = mapView.overlays; MACircle * cicle = [[MACircle alloc] init]; for (NSInteger i = 0; i &lt; overlays.count; i++) &#123; //如果是圈圈则删除 if ([overlays[i] isKindOfClass:[cicle class]]) &#123; [mapView removeOverlay:overlays[i]]; &#125; &#125; &#125; //标注停止移动时 if (newState == MAAnnotationViewDragStateEnding) &#123; //获取标注新的位置所在的经纬度坐标 CGPoint endPoint = view.centerOffset; //修正一下位置 endPoint.x = endPoint.x + 22; endPoint.y = endPoint.y + 36; CLLocationCoordinate2D coo = [mapView convertPoint:endPoint toCoordinateFromView:view]; NSLog(@\"移动后大头针的经纬度：latitude = %f longitude = %f\",coo.latitude,coo.longitude); //添加新的圈圈 MACircle * Circle1 = [MACircle circleWithCenterCoordinate:coo radius:500]; [mapView addOverlay:Circle1]; &#125;&#125; 编译运行代码，移动标注后，新添加的圆圈如下所示： 高德地图的地图 SDK 到这里就告一段落了 定位SDK的打开方式点这里查看 iOS 定位 SDK. 导航 SDK 的打开方式点这里查看 iOS 导航 SDK . 关于导航，可以参考我的这篇博文。 iOS实现应用外自带地图、高德地图、百度地图导航 室内地图SDK的打开方式点这里查看 iOS 室内地图SDK 室内定位SDK的打开方式点这里查看 iOS 室内定位SDK 结束语本文会阶段性的持续更新的！欢迎大家批评和指正！ 点击下载 本文的demo，记得给 star 支持博主的努力哦！ 感谢阅读，有什么意见可以给我留言!","tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://yoursite.com/tags/Objective-C/"},{"name":"高德地图SDK","slug":"高德地图SDK","permalink":"http://yoursite.com/tags/高德地图SDK/"}]},{"title":"使用 FMDB 管理 SQLite 数据库","date":"2016-03-17T03:06:46.000Z","path":"2016/03/17/FMDB/","text":"版权声明：本文为 muhlenXi 原创文章，欢迎转载，转载请注明来源: http://muhlenxi.com/2016/03/17/FMDB 导语： FMDB 是一个面向对象的管理数据库的轻量级框架，它用 Obective-C 语言对数据库 SQLite 的 C 语言API 进行了封装，并且它对多线程的并发操作进行了处理，是线程安全的! 点击阅读全文来深入了解 FMDB 的如何使用。 本文，我会以一个小 demo (同学录)的方式讲在项目中如何使用FMDB的。假如我们有一个老师，他要保存一个班级的所有同学的个人信息，他可以添加学生、删除学生、根据条件查找学生，比如性别、名字等 和 修改学生信息。 如图所示： 下载完整 Demo 一起交流学习，记得给 star 支持博主的努力哦！ FMDB的安装 方式一：使用 CocoaPods 安装。 方式二：直接去 GitHub 下载，拖入到项目中使用。 FMDB 传送梦 注意，如果使用第二种方式，需要导入系统依赖库 sqlite3.0.tbd 后，才能使用。 FMDB 的使用(线程安全的)在一个项目中，我们往往是通过单例的模式去管理数据库中的，也就是说整个项目中只有一个数据库管理员(DatabaseManager)。 首先我们要创建要管理的对象 (Model)，本文中是人 (Person)。 创建人的模型 （XYJPerson）新建一个继承自 NSObject 的 XYJPerson 的类，用来保存人的相关信息。 在XYJPerson.h中，声明我们所需要的信息。 12345678@property (nonatomic,copy) NSString * name; //!&lt; 姓名@property (nonatomic,assign) NSInteger age; //!&lt; 年龄@property (nonatomic,copy) NSString * sex; //!&lt; 性别@property (nonatomic,copy) NSString * QQnumber; //!&lt; qq号@property (nonatomic,copy) NSString * phoneNumber; //!&lt; 手机号@property (nonatomic,copy) NSString * weixinNumber; //!&lt; 微信号@property (nonatomic,copy) NSString * headImagePath; //!&lt; 头像@property (nonatomic,assign) NSTimeInterval updateDate; //!&lt; 添加的时间 在 XYJPerson.m 中覆写 description 方法，可以方便我们查看 Person 的详细信息。 12345- (NSString *)description&#123; return [NSString stringWithFormat:@\"name == %@ \\n age == %ld \\n sex == %@ \\n QQnumber == %@ \\n phoneNumber == %@ \\n weixinNumber == %@ \\n headImagePath == %@ \\n updateDate == %f\",self.name,self.age,self.sex,self.QQnumber,self.phoneNumber,self.weixinNumber,self.headImagePath,self.updateDate]; &#125; 其次，我们要新建一个 XYJDatabaseManage r用来管理数据库中 Perso n数据的 增、删、改、查。 创建 （XYJDatabaseManager）新建一个继承自 NSObject 的 XYJDatabaseManager 的类不是很难。 第一步：在 XYJDatabaseManager.h 文件中导入FMDB的头文件，声明相关属性和单例入口 1#import &lt;FMDB/FMDB.h&gt; 12345@property (nonatomic,strong,readonly) FMDatabaseQueue * databaseQueue; //!&lt; 用户数据库操作的队列，线程安全的/** * 单例入口 */+ (instancetype) shareManager; 第二步：在 XYJDatabaseManager.m 文件中创建数据库和实现单例。 单例方法的实现： 12345678910+ (instancetype)shareManager&#123;static XYJDatabaseManager * manager; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; manager = [[XYJDatabaseManager alloc] init]; &#125;); return manager;&#125; 覆写 init 方法，在 init 方法中创建数据库和表 1234567891011121314151617181920212223242526272829303132333435363738- (instancetype)init&#123; if (self = [super init]) &#123; //数据库存放路径 NSString * libDirPath = [NSSearchPathForDirectoriesInDomains(NSLibraryDirectory, NSUserDomainMask, YES) firstObject]; NSString * dbPath = [libDirPath stringByAppendingPathComponent:@\"databaseDemo.sqlite\"]; NSLog(@\"dbpath == %@\",dbPath); //创建数据库 _databaseQueue = [FMDatabaseQueue databaseQueueWithPath:dbPath]; if (_databaseQueue == nil) &#123; NSLog(@\"数据库创建失败\"); [NSException raise:NSInternalInconsistencyException format:@\"数据库创建异常\"]; &#125; else &#123; //创建一个表 NSString *createTablSQL = @\"CREATE TABLE IF NOT EXISTS T_PersonList (name text PRIMARY KEY NOT NULL, age integer NOT NULL,sex text,qqNumber text,phoneNumber text,weixinNumber text,headImagePath text,updateDate double)\"; [_databaseQueue inDatabase:^(FMDatabase *db) &#123; BOOL ret = [db executeUpdate:createTablSQL]; if (ret) &#123; NSLog(@\"创建T_PersonList 表成功\"); &#125; else &#123; NSLog(@\"创建T_PersonList 表失败\"); &#125; &#125;]; &#125; &#125; return self;&#125; 在 XYJDatabaseManager.m 中也可以写对 Model（Person）数据的增、删、改、查方法，但是为了更加方便一些，我们创建一个 Person 的类别，在这个类别中一次实现上述方法。 创建的XYJPerson类别 （XYJPerson+database）创建方法：Xcode -&gt; File -&gt; New -&gt; File…选择iOS Source Objective-C File -&gt; Next 然后Next下去就好了。 在 XYJPerson+database.h 中声明常用对象的操作方法。 首先得导入#import &quot;XYJDatabaseManager.h&quot;文件。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * 添加或更新 一条数据到数据库中 * * @return 成功或失败 */- (BOOL) saveToDataBase;/** * 插入一条数据到数据库中 * * @return 成功或失败 */- (BOOL) insertToDataBase;/** * 根据名字修改数据库中的那条数据 * * @param lastName 修改之前的名字 * * @return 成功或失败 */- (BOOL) updateToDataBaseWithName:(NSString *) lastName;/** * 从数据库中读出所有的人的信息 * * @return 所有的人数组 */+ (NSArray *) getAllPersonFromDataBase;/** * 根据名字从数据库中查找人的信息 * * @param name 名字 * * @return 人的数组 */+ (NSArray *) getPersonFromDataBasewithName:(NSString *) name;/** * 根据性别从数据库中查找人的信息 * * @param sex 性别 * * @return 人的数组 */+ (NSArray *) getPersonFromDataBasewithSex:(NSString *) sex;/** * 根据名字从数据库中删除信息 * * @param name 要删除的名字 * * @return 成功或失败 */+ (BOOL) deleteFromDataBaseByName:(NSString *) name; 接着是去 XYJPerson+database.m 中文件中实现前面声明的方法： 增加记录将对象保存到数据库的表中，每个对象都是表中的一条记录！注意执行语句的关键词 REPLACE INTO 如果表中存在这条数据，就将这条数据替换掉，如果没有，则把这条数据加入到表中。 12345678910111213- (BOOL)saveToDataBase&#123; NSString * replaceSQl = @\"REPLACE INTO T_PersonList(name, age, sex, qqNumber, phoneNumber, weixinNumber, headImagePath ,updateDate) VALUES(?, ?, ?, ?, ?, ?, ?, ?)\"; __block BOOL ret = NO; [[XYJDatabaseManager shareManager].databaseQueue inDatabase:^(FMDatabase *db) &#123; ret = [db executeUpdate:replaceSQl,self.name,@(self.age),self.sex,self.QQnumber,self.phoneNumber,self.weixinNumber,self.headImagePath,@(self.updateDate)]; &#125;]; return ret;&#125; 插入一条数据到数据库的表中;注意执行语句的关键词 INSERT INTO 1234567891011121314- (BOOL)insertToDataBase&#123; NSString * replaceSQl = @\"INSERT INTO T_PersonList(name, age, sex, qqNumber, phoneNumber, weixinNumber, headImagePath ,updateDate) VALUES(?, ?, ?, ?, ?, ?, ?, ?)\"; __block BOOL ret = NO; [[XYJDatabaseManager shareManager].databaseQueue inDatabase:^(FMDatabase *db) &#123; ret = [db executeUpdate:replaceSQl,self.name,@(self.age),self.sex,self.QQnumber,self.phoneNumber,self.weixinNumber,self.headImagePath,@(self.updateDate)]; &#125;]; return ret;&#125; 删除记录删除根据名字查找到的那条数据;注意执行语句的关键词 DELETE FROM...WHERE 1234567891011121314+ (BOOL)deleteFromDataBaseByName:(NSString *) name&#123; NSString * deleteSQl = @\"DELETE FROM T_PersonList WHERE name = ?\"; __block BOOL ret = NO; [[XYJDatabaseManager shareManager].databaseQueue inDatabase:^(FMDatabase *db) &#123; ret = [db executeUpdate:deleteSQl,name]; &#125;]; return ret;&#125; 修改记录修改根据名字查找到的那条数据;注意执行语句的关键词 UPDATE...SET...WHERE 1234567891011121314- (BOOL)updateToDataBaseWithName:(NSString *)lastName&#123; NSString * replaceSQl = @\"UPDATE T_PersonList SET name = ?, age = ?, sex = ?, qqNumber = ?, phoneNumber = ?, weixinNumber = ?, headImagePath = ? ,updateDate= ? WHERE name = ?\"; __block BOOL ret = NO; [[XYJDatabaseManager shareManager].databaseQueue inDatabase:^(FMDatabase *db) &#123; ret = [db executeUpdate:replaceSQl,self.name,@(self.age),self.sex,self.QQnumber,self.phoneNumber,self.weixinNumber,self.headImagePath,@(self.updateDate),lastName]; &#125;]; return ret;&#125; 查询记录查询到的结果是放在一个 FMResultSet（结果集）中的，遍历这个结果集，将相关数据添加到 Person 对象中，最后以数组的方式返回。 根据名字查询数据;注意执行语句的关键词 `SELECT FROM…WHERE`* 12345678910111213141516171819202122232425262728293031+ (NSArray *)getPersonFromDataBasewithName:(NSString *)name&#123; NSString * querrySQL = @\"SELECT * FROM T_PersonList WHERE name = ?\"; NSMutableArray * result = [NSMutableArray array]; [[XYJDatabaseManager shareManager].databaseQueue inDatabase:^(FMDatabase *db) &#123; FMResultSet * rs = [db executeQuery:querrySQL,name]; while ([rs next]) &#123; XYJPerson * person = [[XYJPerson alloc] init]; //给模型赋值 person.name = [rs stringForColumn:@\"name\"]; person.age = [rs intForColumn:@\"age\"]; person.sex = [rs stringForColumn:@\"sex\"]; person.QQnumber = [rs stringForColumn:@\"qqNumber\"]; person.phoneNumber = [rs stringForColumn:@\"phoneNumber\"]; person.weixinNumber = [rs stringForColumn:@\"weixinNumber\"]; person.updateDate = [rs doubleForColumn:@\"updateDate\"]; person.headImagePath = [rs stringForColumn:@\"headImagePath\"]; [result addObject:person]; &#125; &#125;]; return result;&#125; 根据性别查询数据 123456789101112131415161718192021222324252627282930313233+ (NSArray *)getPersonFromDataBasewithSex:(NSString *)sex&#123; NSString * querrySQL = @\"SELECT * FROM T_PersonList WHERE sex = ?\"; NSMutableArray * result = [NSMutableArray array]; [[XYJDatabaseManager shareManager].databaseQueue inDatabase:^(FMDatabase *db) &#123; FMResultSet * rs = [db executeQuery:querrySQL,sex]; while ([rs next]) &#123; XYJPerson * person = [[XYJPerson alloc] init]; //给模型赋值 person.name = [rs stringForColumn:@\"name\"]; person.age = [rs intForColumn:@\"age\"]; person.sex = [rs stringForColumn:@\"sex\"]; person.QQnumber = [rs stringForColumn:@\"qqNumber\"]; person.phoneNumber = [rs stringForColumn:@\"phoneNumber\"]; person.weixinNumber = [rs stringForColumn:@\"weixinNumber\"]; person.updateDate = [rs doubleForColumn:@\"updateDate\"]; person.headImagePath = [rs stringForColumn:@\"headImagePath\"]; [result addObject:person]; &#125; &#125;]; return result;&#125; 查询表中的所有数据；并根据添加的时间先后顺序排序 123456789101112131415161718192021222324252627282930313233+ (NSArray *)getAllPersonFromDataBase&#123; //根据时间先后顺序排序 //ASC 升序 DESC 降序 NSString * querrySQL = @\"SELECT * FROM T_PersonList ORDER BY updateDate ASC\"; NSMutableArray * result = [NSMutableArray array]; [[XYJDatabaseManager shareManager].databaseQueue inDatabase:^(FMDatabase *db) &#123; FMResultSet * rs = [db executeQuery:querrySQL]; while ([rs next]) &#123; XYJPerson * person = [[XYJPerson alloc] init]; //给模型赋值 person.name = [rs stringForColumn:@\"name\"]; person.age = [rs intForColumn:@\"age\"]; person.sex = [rs stringForColumn:@\"sex\"]; person.QQnumber = [rs stringForColumn:@\"qqNumber\"]; person.phoneNumber = [rs stringForColumn:@\"phoneNumber\"]; person.weixinNumber = [rs stringForColumn:@\"weixinNumber\"]; person.updateDate = [rs doubleForColumn:@\"updateDate\"]; person.headImagePath = [rs stringForColumn:@\"headImagePath\"]; [result addObject:person]; &#125; &#125;]; return result;&#125; 到这里，我们基本的方法都已经写完了，接下来就剩下来调用了。搭建个简易的 UI 界面测试一下 FMDB 的测试搭建一个 Input 界面： 添加数据的调用方法： 12345678910BOOL ret = [person insertToDataBase]; //这样也可以//BOOL ret = [person saveToDataBase]; if (ret) &#123; NSLog(@\"插入数据 到数据库成功\"); &#125; else &#123; NSLog(@\"插入数据 到数据库失败\");&#125; 搭建一个修改信息的界面： 修改数据的调用方法： 1234567if ([person updateToDataBaseWithName:self.lastName]) &#123; NSLog(@\"更新数据 到数据库成功\");&#125;else&#123; NSLog(@\"更新数据 到数据库失败\");&#125; 将TableViewCell向左滑可以删除信息： 删除数据的调用方法： 12//删除数据库数据[XYJPerson deleteFromDataBaseByName:person.name]; 查询所有数据的调用方法 12//从数据库中取出所有的用户NSArray * allPerson = [XYJPerson getAllPersonFromDataBase ]; 一个根据性别查询信息的界面： 根据性别查找数据库的调用方法 1array = [XYJPerson getPersonFromDataBasewithSex:@\"女\"]; 一个根据名字查询信息的界面： 根据名字查找数据库的调用方法 1array = [XYJPerson getPersonFromDataBasewithName:@\"要查询的名字\"]; FMDB 的使用(线程不是安全的)这个暂未更新，后续会补上的…","tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://yoursite.com/tags/Objective-C/"},{"name":"FMDB","slug":"FMDB","permalink":"http://yoursite.com/tags/FMDB/"}]},{"title":"对 iOS 开发中 MVC 模式的理解","date":"2016-02-04T02:41:11.000Z","path":"2016/02/04/MVC/","text":"版权声明：本文为 muhlenXi 原创文章，欢迎转载，转载请注明来源: http://muhlenxi.com/2016/02/04/MVC 前言： MVC，全名是 Model View Controller，是模型 (model)－视图 (view)－控制器 (controller) 的缩写，一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。 学习贵在记录和总结收获！点击阅读全文了解更多！ 正文：MVC 是什么？MVC 是一个基本机制，用于将程序中的所有对象拆分到三个阵营（三层）的一个阵营中。第一层是 Model，第二层是 View，第三层是 Controller。 Model = 你的应用是什么？ Controller = 控制 Model 如何显示在屏幕上。 View = 你的控制器的元素，用于构成界面。 MVC 是如何通信的？Controller -&gt; Model Controller 对 Model 有完全访问权限。 Model -&gt; Controller Model 通过 Notification &amp; KVO 的方式与 Controller 通信。 Controller -&gt; View Controller 对 View 也有完全的访问权限。如：Controller 拥有一个 outlet 属性，该属性指向View 中的对象。 View -&gt; Controller View 通过 action-target 的方式与 Controller 通信。如：button 的点击 View 还通过 Delegate 的方式与 Controller通信。 数据不能作为视图的内部属性。它是通过 data source delegate 的方式与 Controller 通信的。也就是说，Controller 从 Model 中获取数据然后传递给 View。 Model &lt;-&gt; View Model 和 View 不能相互通信。是完全独立的。 通过下图，我们可以很好的理解他们之间的通信方式。 多个MVC的协作MVC 的堆叠可以构成一个复杂的应用 如图所示： 感谢您的阅读，一起学习，一起成长，加油！","tags":[{"name":"MVC","slug":"MVC","permalink":"http://yoursite.com/tags/MVC/"}]},{"title":"关于 NSURLConnection 的使用","date":"2016-01-15T07:48:39.000Z","path":"2016/01/15/NSURLConnection/","text":"版权声明：本文为 muhlenXi 原创文章，欢迎转载，转载请注明来源: http://muhlenxi.com/2016/01/15/NSURLConnection 前言： NSURLConnection 是 iOS7之前专门用来做数据请求的类。 学习贵在记录和总结收获！点击阅读全文了解更多！ 基础知识什么是 HTTP 请求？如图就是一个 HTTP 请求简介 一个 HTTP 请求包含URL（请求地址）、Method（请求方式）、Header（请求头）、Body（请求体）。 一个 HTTP 响应包含Header（响应头）、Body（响应体）。 什么是 URL？URL - 统一资源定位符 可以通过 NSURL class 来生成一个 URL： 1NSURL *url = [NSURL URLWithString:@\"http://10.0.8.8/sns/my/user_list.php\"]; 什么是 request？request - 数据请求 可以通过 NSURLRequest class 来生成一个 Request： 创建 Request： 1NSURLRequest *request = [NSURLRequest requestWithURL:url]; 创建带超时的 Request: 1NSURLRequest *request = [NSURLRequest requestWithURL:url cachePolicy:NSURLRequestUseProtocolCachePolicy timeoutInterval:30.0f] 创建可变的的 Request: （可以修改 Request 的属性，如 Method 等，POST 会用到。） 12345NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url];request.HTTPMethod = @\"POST\";//设置请求体NSString *paramStr = @\"username=st1508&amp;password=123456\";request.HTTPBody = [paramStr dataUsingEncoding:NSUTF8StringEncoding]; NSURLConnection 的应用NSURLConnection：负责发送请求，建立客户端和服务器的连接。发送 NSURLRequest 的数据给服务器，并收集来自服务器的响应数据。 发送请求的基本步骤： 发送请求的三个步骤： 1.设置请求路径 2.创建请求对象 3.发送请求（同步或异步请求） 发送同步请求（一直在等待服务器返回数据，这行代码会卡住，如果服务器，没有返回数据，那么在主线程UI会卡住不能继续执行操作）有返回值 发送异步请求：没有返回值 注意：任何 NSURLRequest 默认都是 Get 请求。 NSURLConnection 代码举例发送一个同步请求:1234567891011121314151617181920NSString *urlStr = @\"请求的地址\";NSURL * URL = [NSURL URLWithString:urlStr];NSURLRequest * request = [NSURLRequest requestWithURL:URL cachePolicy:NSURLRequestUseProtocolCachePolicy timeoutInterval:30.0]; //超时30sNSError * error = nil; //请求错误NSURLResponse *response = nil; //请求响应//请求响应的数据NSData * data = [NSURLConnection sendSynchronousRequest:request returningResponse:&amp;response error:&amp;error];//请求成功if (error == nil ) &#123; NSDictionary * jsonDic = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingMutableLeaves error:nil]; NSLog(@\"jsonDic == %@\",jsonDic); //在这里处理响应的数据 &#125;else&#123; NSLog(@\"请求失败：%@\",error.localizedDescription); //在这里处理请求失败的情况&#125; 发送一个异步请求: 默认是 Get方式一：请求的结果通过 Block 返回。 1234567891011121314151617NSURL *URL = [NSURL URLWithString:@\"请求的地址\"]; NSURLRequest *request = [NSURLRequest requestWithURL:URL]; // 发送一个异步请求，请求的结果是通过completionHandler这个Block返回的[NSURLConnection sendAsynchronousRequest:request queue:[NSOperationQueue mainQueue] completionHandler:^(NSURLResponse *response, NSData *data, NSError *connectionError) &#123; if (connectionError != nil) &#123; NSLog(@\"请求出错: %@\", connectionError); //在这里处理请求失败的情况 &#125; else &#123; NSLog(@\"请求成功，解析数据\"); id jsonObj = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingMutableContainers error:nil]; NSLog(@\"jsonObj == %@\",jsonObj); //在这里处理响应的数据 &#125;&#125;]; 方式二：请求的结果通过 Delegate 返回。 详情请看 NSURLConnectionWithDelegateDemo。 发送一个 POST 异步请求:1234567891011121314151617181920212223242526272829303132333435363738394041424344NSURL *url = [NSURL URLWithString:@\"http://10.0.8.8/sns/my/user_list.php\"]; // NSMutableURLRequest 可以修改请求的一些默认设置NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url]; // 如果有必要，可以设置请求头// [request setValue:@\"application/json\" forHTTPHeaderField:@\"Content-Type\"];// [request setValue:@\"2555\" forHTTPHeaderField:@\"Content-Length\"]; // 把请求的Method改成POST，默认是GET// GET请求的参数，是拼在URL的后面// POST请求参数，是放在请求体里面的request.HTTPMethod = @\"POST\"; // page=1&amp;number=5 默认NSString *paramStr = @\"page=1&amp;number=2\";// 把字符串转成二进制对象，NSString -&gt; NSDataNSData *paramData = [paramStr dataUsingEncoding:NSUTF8StringEncoding]; // 把二进制对象，转成字符串，NSData -&gt; NSString// [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding]; // 把参数放到请求体里面request.HTTPBody = paramData; // 如果接口要求参数是一个JSON，就这样写，在这里没办法测试// NSDictionary *dict = @&#123;@\"page\":@\"1\", @\"number\": @\"5\"&#125;;// NSData *paramData2 =[NSJSONSerialization dataWithJSONObject:dict options:NSJSONWritingPrettyPrinted error:nil];// request.HTTPBody = paramData;// 发送POST的异步请求[NSURLConnection sendAsynchronousRequest:request queue:[NSOperationQueue mainQueue] completionHandler:^(NSURLResponse *response, NSData *data, NSError *connectionError) &#123; if (connectionError == nil) &#123; id jsonObj = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingMutableContainers error:nil]; NSLog(@\"jsonObj == %@\",jsonObj); //在这里处理响应的数据 &#125; else &#123; NSLog(@\"请求失败: %@\", connectionError); &#125;&#125;]; 感谢您的阅读，一起学习，一起成长，加油！","tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://yoursite.com/tags/Objective-C/"},{"name":"NSURLConnection","slug":"NSURLConnection","permalink":"http://yoursite.com/tags/NSURLConnection/"}]},{"title":"iOS用户头像的获取与上传","date":"2015-12-01T02:03:45.000Z","path":"2015/12/01/Upload-images/","text":"版权声明：本文为 muhlenXi 原创文章，欢迎转载，转载请注明来源: http://muhlenxi.com/2015/12/01/Upload-images 导语： 在 APP 的开发过程中，经常涉及到个人信息界面的开发，其中有一个常见的功能，就是用户头像的选择与上传。用户可以通过拍照或者在相册中选择一个已经存在的照片，然后设置为头像并上传到服务器中储存。我们来看看这个功能是怎么实现的。作为一个程序猿，生命不止，学习则不止。 点击阅读全文来了解一下详情吧。 本次开发的需求是，实现一个个人信息界面，用户可以通过两种不同的方式来选择头像并保存到服务器中。本次开发是通过 AFNetworking 这个框架来实现头像的上传功能，通过 SDWebImage 这个框架来实现图片的异步下载和缓存。 AFNetworking 传送门 SDWebImage 传送梦 类似于下面这样的界面： UI界面的搭建这里就忽略了。接下来开始办大事了 选项表的实现不会选项表的可以看这里，记得要设置代理和遵循 ‘UIActionSheetDelegate’ 协议啊,在需要弹出选项列表的事件响应方法中写入如下代码即可 123UIActionSheet * actionSheet = [[UIActionSheet alloc] initWithTitle:nil delegate:self cancelButtonTitle:@“取消” destructiveButtonTitle:nil otherButtonTitles:@“拍照”,@“从手机相册中选择”, nil];[actionSheet showInView:self.view]; 接下来实现代理方法 12345678910111213141516171819202122232425#pragma mark - UIActionSheetDelegate- (void)actionSheet:(UIActionSheet *)actionSheet clickedButtonAtIndex:(NSInteger)buttonIndex&#123; //NSLog(@\"buttonIndex == %ld\",buttonIndex); switch (buttonIndex) &#123; case 0: //照相机 &#123; [self presentCameraImagePicker]; &#125; break; case 1: //从相册获取 &#123; [self presentPhotoLibraryImagePicker]; &#125; break; case 2: &#123; NSLog(@\"取消了头像选择\"); &#125; break; default: break; &#125;&#125; 这里用到的方法，下面会详细介绍。 工欲善其事必先利其器这里详细介绍前面调用的的几个方法 拍照和从手机相册中选择功能需要用到UIImagePickerController,我们就从这个开始写起。 记得遵循 UIImagePickerControllerDelegate,UINavigationControllerDelegate 协议。 拍照【1】拍照 12345678910111213141516171819202122- (void) presentCameraImagePicker&#123; //首先判断该设备是否支持照相功能 if ([UIImagePickerController isSourceTypeAvailable:UIImagePickerControllerSourceTypeCamera]) &#123; UIImagePickerController * imagePicker = [[UIImagePickerController alloc] init]; imagePicker.delegate = self; imagePicker.allowsEditing = YES; //设置为图片的来源为拍照获取模式 imagePicker.sourceType = UIImagePickerControllerSourceTypeCamera; imagePicker.modalPresentationStyle = UIModalPresentationCurrentContext; [self presentViewController:imagePicker animated:YES completion:nil]; &#125; else &#123; NSLog(@\"该设备无摄像头\"); &#125; &#125; 从手机相册中选择照片【2】从手机相册中选择照片 12345678910- (void) presentPhotoLibraryImagePicker&#123; UIImagePickerController * imagePicker = [[UIImagePickerController alloc] init]; imagePicker.delegate = self; imagePicker.allowsEditing = YES; //选择图片的来源为从相册获取 imagePicker.sourceType = UIImagePickerControllerSourceTypePhotoLibrary; [self presentViewController:imagePicker animated:YES completion:nil];&#125; 保存照片到本地沙盒中【3】保存照片到本地沙盒中，并根据条件判断是否要上传到服务器中 12345678910111213141516171819202122232425262728293031323334353637383940- (void) saveImage:(UIImage *) image NeedUpload:(BOOL) upload&#123; NSFileManager * fileManager = [NSFileManager defaultManager]; NSError * error = nil; //照片的存储路径 NSString * imagePath = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES)[0]; //添加照片的名称 imagePath = [imagePath stringByAppendingPathComponent:@\"headImage.png\"]; NSLog(@\"imagePath == %@\",imagePath); //如果本地存在该照片则删除 if ([fileManager fileExistsAtPath:imagePath] == YES) &#123; BOOL ret = [fileManager removeItemAtPath:imagePath error:&amp;error]; if (ret) &#123; NSLog(@\"该路径存在该照片，已删除该文件\"); &#125; &#125; //根据项目要求实际需求改变照片的大小 //改变图像尺寸为120*120 CGSize size = CGSizeMake(120, 120); UIGraphicsBeginImageContext(size); [image drawInRect:CGRectMake(0, 0, size.width, size.height)]; UIImage * newImage = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); //将图片写入本地沙盒中 BOOL ret = [UIImageJPEGRepresentation(newImage, 1.0) writeToFile:imagePath atomically:YES]; if (ret == YES) &#123; NSLog(@\"保存头像图片到本地成功\"); if (upload == YES) &#123; //上传头像到服务器 [self uploadHeadImageToServer]; &#125; &#125; else &#123; NSLog(@\"保存头像图片到本地失败\"); &#125; &#125; 通过 AFNetworking 上传到服务器中【4】关键的一步，上传到服务器中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566- (void) uploadHeadImageToServer&#123; //以下的URL和参数需要根据项目的接口文档做调整 NSString * url = @“这里填写上传头像的URLString”; NSDictionary * dic2 = @“这里写具体的上传参数”; NSLog(@\"上传头像Parameters == %@\",dic2); //初始化AFHTTPSessionManager AFHTTPSessionManager *manager = [AFHTTPSessionManager manager]; // 设置二进制响应解析器 manager.responseSerializer = [AFHTTPResponseSerializer serializer]; // 设置二进制请求解析器 manager.requestSerializer = [AFJSONRequestSerializer serializer]; // 设置超时时间 [manager.requestSerializer willChangeValueForKey:@\"timeoutInterval\"]; manager.requestSerializer.timeoutInterval = 10.f; [manager.requestSerializer didChangeValueForKey:@\"timeoutInterval\"]; // AFNetworking进行multipart/form-data的请求方法 // constructingBodyWithBlock 是用来构造请求体的(HTTPBody) //Post请求上传数据 [manager POST:url parameters:dic2 constructingBodyWithBlock:^(id&lt;AFMultipartFormData&gt; _Nonnull formData) &#123; // 添加照片的文件流 NSError *error = nil; NSString * imagePath = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES)[0]; imagePath = [imagePath stringByAppendingPathComponent:@\"headImage.png\"]; [formData appendPartWithFileURL:[NSURL fileURLWithPath:imagePath] name:@\"headImage\" error:&amp;error]; if (error != nil) &#123; NSLog(@\"添加文件流出错: %@\", error); &#125;else &#123; NSLog(@\"添加文件流成功\"); &#125; &#125; progress:^(NSProgress * _Nonnull uploadProgress) &#123; &#125; success:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) &#123; NSLog(@\"上传头像数据请求成功\"); id jsonObj = [NSJSONSerialization JSONObjectWithData:responseObject options:NSJSONReadingMutableContainers error:nil]; NSLog(@\"%@\", jsonObj); //这里做数据的额后续处理，需根据实际需求操作 NSLog(@\"msg == %@\",jsonObj[@\"msg\"]); NSDictionary * result = jsonObj[@\"result\"]; //拼接图片网络URL NSString * headImageURL = [NSString stringWithFormat:@\"%@/%@\",FF_doname_uploadImage,result[@\"headImage\"]]; NSLog(@\"headImageURL == %@\",headImageURL); //将头像的网络URL保存到本地 [[NSUserDefaults standardUserDefaults] setObject:headImageURL forKey:@\"headImageURL\"]; [[NSUserDefaults standardUserDefaults] synchronize]; //设置头像 [self.headImageView sd_setImageWithURL:[NSURL URLWithString:headImageURL] placeholderImage:[UIImage imageNamed:@\"head60\"]]; &#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123; NSLog(@\"上传头像数据请求成功数据请求失败：%@\", error); &#125;]; &#125; 拍照或选择图片的事件处理 当拍照后，点击使用照片会触发这个代理方法。 当从相册中选择照片后，点击选取后会触发下面这个代理方法，在这个方法中，我们可以处理获取到的照片。 触发的代理方法如下 123456789101112#pragma mark - UIImagePickerControllerDelegate- (void)imagePickerController:(UIImagePickerController *)picker didFinishPickingMediaWithInfo:(NSDictionary&lt;NSString *,id&gt; *)info&#123; [picker dismissViewControllerAnimated:YES completion:nil]; //获取图片 UIImage * image = [info objectForKey:UIImagePickerControllerEditedImage]; [self saveImage:image NeedUpload:YES]; //保存图片到本地,并上传到服务器 &#125; 点击取消会触发这个方法，在这个方法中，我们要关闭照相页面 1234- (void)imagePickerControllerDidCancel:(UIImagePickerController *)picker&#123; [picker dismissViewControllerAnimated:YES completion:nil];&#125; 编译运行代码，如果没问题的话，效果如下: 是不是难度不是很大，恭喜您又学会一招，其实在开发过程中，看优秀的开源代码能然我们走的更远！ 上传多张照片到服务器：AFNetworking 3.0+ 上传多张图片 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//上传多张照片到服务器- (void) uploadPhotosToTheServer&#123; // 1、设置上传图片的接口路径 NSString *urlString = @\"上传图片的地址\"; NSMutableDictionary * paramDic = [NSMutableDictionary dictionary]; // 2、配置上传参数 //比如：paramDic[@\"date\"] = @\"2016-11-11\"; // 基于AFN3.0+ 封装的HTPPSession句柄 AFHTTPSessionManager *manager = [AFHTTPSessionManager manager]; manager.requestSerializer.timeoutInterval = 200; manager.responseSerializer.acceptableContentTypes = [NSSet setWithObjects:@\"text/plain\", @\"multipart/form-data\", @\"application/json\", @\"text/html\", @\"image/jpeg\", @\"image/png\", @\"application/octet-stream\", @\"text/json\", nil]; [manager POST:urlString parameters:paramDic constructingBodyWithBlock:^(id&lt;AFMultipartFormData&gt; _Nonnull formData) &#123; // formData: 专门用于拼接需要上传的数据,在此位置生成一个要上传的数据体 // self.photoArr：是你存放图片的数组,可以是图片，可以是保存在本地的图片路径 // 3、循环添加图片的数据 for (int i = 0; i &lt; self.photoArr.count; i++) &#123; UIImage *image = [UIImage imageWithContentsOfFile:self.self.photoArr[i]]; NSData *imageData = UIImageJPEGRepresentation(image, 0.5); // 在网络开发中，上传文件时，是文件不允许被覆盖，文件重名 // 要解决此问题， // 可以在上传时使用当前的系统事件时间字符串作为文件名 NSDateFormatter *formatter = [[NSDateFormatter alloc] init]; // 设置时间格式 [formatter setDateFormat:@\"yyyyMMddHHmmss\"]; NSString *dateString = [formatter stringFromDate:[NSDate date]]; NSString *fileName = [NSString stringWithFormat:@\"%@.jpg\", dateString]; /* *该方法的参数 1. appendPartWithFileData：要上传的照片[二进制流] 2. name：对应网站上[upload.php中]处理文件的字段（比如upload） 3. fileName：要保存在服务器上的文件名 4. mimeType：上传的文件的类型 */ [formData appendPartWithFileData:imageData name:@\"upload\" fileName:fileName mimeType:@\"image/jpeg\"]; // &#125; &#125; progress:^(NSProgress * _Nonnull uploadProgress) &#123; NSLog(@\"---上传进度--- %@\",uploadProgress); &#125; success:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) &#123; NSLog(@\"---上传成功--- %@\",responseObject); &#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123; NSLog(@\"---上传失败--- %@\", error); &#125;];&#125; 感谢阅读，有什么意见可以给我留言!","tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://yoursite.com/tags/Objective-C/"},{"name":"头像上传","slug":"头像上传","permalink":"http://yoursite.com/tags/头像上传/"}]},{"title":"Effective objective-C 2.0 学习笔记","date":"2015-11-10T06:52:41.000Z","path":"2015/11/10/Effective-objective-C-2-0/","text":"版权声明：本文为 muhlenXi 原创文章，欢迎转载，转载请注明来源: http://muhlenxi.com/2015/11/10/Effective-Objective-C-2-0 前言： Effective objective-C,翻译过来是编写高质量 iOS 与 OS X 代码的52个有效方法，作者是 Matt Galloway ，本书是世界级 C++ 开发大师 Scott Meyers 亲自担当顾问编辑的 “Effective Software Development Series” 系列丛书中的新作，Amazon 全五星评价。全书从语法、接口与API设计、内存管理、框架等7大方面总结和探讨了 Objective-C 编程中 52 个鲜为人知的和容易被忽视的特性和陷阱！ 学习贵在记录和总结收获！点击阅读全文了解更多！ Objective-C 源自 Smalltalk ，是一门相当动态的语言，代码是在运行期（runtime）执行的！ 第1条：了解Objective-C语言的起源C++,Java等使用的是function calling ，运行所执行的代码由编译器来决定。如果调用的函数是多态的，那么在运行时就要按照 virtual table (虚方法表) 来查出应该执行哪个函数实现。 Objective-C语言使用的是动态绑定的 message structure (消息结构) ，其运行时所执行的代码由运行环境来决定；无论多态，总是在运行时才会去检查对象的类型和查找所要执行的方法。 Objective-C 语言中的对象是用来指示对象的。 举个🌰 ： 1NSString * str = @\"hello world\"; 对象所占的内存是分配在堆空间中！ 指向对象的指针变量分配在栈上！ 一般不含星号的变量也分配在栈上! 如 CGRect，CGSize… 第2条：在类的头文件中尽量少引用其他头文件 除非确有必要，否则不要引入头文件！使用前向声明！ 解决办法：在类的头文件中使用前向声明提到的类。并在.m文件中引入那些类的头文件。 好处：降低了类之间的耦合度，减少了编译时间， 1@class XYJMyMenuTVC; //前向声明语法 有时无法使用前向声明，比如要声明某个类遵循一项协议。此时，尽量把该类遵循某协议的声明已到匿名类中。如果不行的话，就把协议单独放在一个头文件中，然后将其引入。 第3条：多用字面量语法，少用与之等价的方法 应该使用字面量语法来创建字符串、数值、数组、字典。与创建此类对象的常规方法相比，这么做更加简明扼要。 应该通过取下标操作来访问数组下标或字典中键所对应的元素。 用字面量语法创建数组或字典，若值中有 nil，则会抛出异常。因此，务必确保值里不含 nil ！ 字面量语法举例： 举个🌰 ： 12345678910NSString * string = @\"hello world\"; NSNumber * intNumber = @1;NSNumber * floatNumber = @2.5f;NSNumber * doubleNumber = @3.14159;NSNumber * boolNumber = @YES;NSNumber * charNUmber = @'A'; NSArray * array = @[@\"1\",@\"2\"];NSDictionary * dic = @&#123;@\"keyone\":@\"1\",@\"keytwo\":@\"2\"&#125;; 不可变对象转为可变对象： 举个🌰 ： 123NSMutableArray * arrayM = [@[@\"1\",@\"2\"] mutableCopy];NSMutableString * strM = [@\"hello\" mutableCopy];NSMutableDictionary * dicM = [@&#123;@\"one\":@\"1\"&#125; mutableCopy]; 第4条：多用类型常量，少用#define预处理指令 不要用预处理指令定义常量。这样定义出来的常量不含类型信息，编译器只是会在编译前据此查找与替换操作。即使有人重新定义了常量值，编译器也不会产生警告信息，这将导致应用程序中的常量值不一致。 在实现文件中使用 static const 来定义 只在编译单元内可见的常量。由于此类常量不在全局符号表中，所以无须为其名称加前缀。 在头文件中使用 extern 来声明全局常量，并在相关实现文件中定义其值。这种常量会出现在全局符号表中，所以其名称应加以区隔，通常用与之相关的类名称做前缀。 常量名称的常用命名法是：若常量局限于某编译单元内，也就是实现文件之内，则在前面加字母 k ； 若不打算公开某个常量，则应将其定义在使用该常量的实现文件里 变量一定要同时用 static 与 const 来声明，如果试图修改由 const 修饰符所声明的变量，那么编译器就会报错！ 举个🌰 ： 1static const NSTimeInterval kAnimationDuration = 0.3; //定义一个类型为NSTimeInterval的时间常量 若常量在类之外可见，则通常以类名为前缀。 常量定义从右往左解读，注意 const 修饰符在常量类型中的位置。 举个🌰 ： 123extern NSString * const XYJLoginManagerDidLoginNotification; //在.h文件中声明NSString * const XYJLoginManagerDidLoginNotification = @\"XYJLoginManagerDidLoginNotification\"; //在.m文件中定义 第5条：用枚举表示状态、选项、状态码 应该用枚举来表示状态机的状态、传递给方法的选项以及状态码等值，给这些值起个易懂的名字吧。 如果把传递给某个方法的选项表示为枚举类型，而多个选项又可同时使用，那么就将各选项值定义为 2 的幂，以便通过按位或操作将其组合起来。 用 NS_ENUM与NS_OPTIONS 宏来定义枚举类型，并指明底层数据类型。这样做可以确保枚举是用开发者所选的底层数据类型实现出来的，而不会采用编译器所选的类型。 在处理枚举类型的 switch 语句中不要实现 default 分支，这样的话，加入新枚举之后，编译器就会提示开发者：switch 语句并未处理所有枚举。 凡是需要以 按位或 操作来组合的枚举都应使用 NS_OPTIONS 定义，若是枚举不需要互相组合，则应使用 NS_ENUM 来定义 举个🌰 ： 12345678910111213141516171819typedef enum : NSUInteger &#123; ConnectionStateDisconnected , ConnectionStateConnecting, ConnectionStateConnected,&#125; TCPConnectionState;typedef NS_ENUM (NSUInteger,UDPConnectionState) &#123; UDPConnectionStateDisconnected, UDPConnectionStateConnecting, UDPConnectionStateConnected,&#125;;typedef NS_OPTIONS(NSUInteger, PermittedDirection)&#123; PermittedDirectionUp = 1 &lt;&lt; 0, PermittedDirectionDown = 1 &lt;&lt; 1, PermittedDirectionLeft = 1 &lt;&lt; 2, PermittedDirectionRight = 1 &lt;&lt; 3, &#125;; 第6条：理解属性这一概念 可以用@property语法来定义对象中所封装的数据。 通过 “attribute（特质)” 来指定存储数据所需的正确语义。 在设置属性所对应的实例变量时，一定要遵从该属性所声明的语义。 开发 iOS 程序时应该使用 noatomic 属性，因为 atomic 属性会严重影响性能。 在对象之间传递数据并执行任务的过程就叫做”消息传递”（Messaging）。 当应用程序运行起来，为其提供相关支持的代码叫做 “Objective-C runtime”（运行期环境） 在类的的实现代码里可以通过 @synthesize 语法来指定实例变量的名字 举个🌰 ： 要写在@implementation的下面 1@synthesize firstName = _myFirstName; //将生成的实例变量命名为_myFirstName 在类的的实现代码里可以通过 @dynamic 语法来阻止编译器自动合成存取方法 举个🌰 ： 要写在 @implementation 的下面 1@dynamic firstName; 属性的特质： 1.原子性（atomic / noatomic） 2、读写权限 （readwrite / readonly） 3、内存管理语义（assign / strong / weak / unsafe_unretained / copy） 4、方法名 （setter = 名字 / getter = 名字） 第7条：在对象内部尽量直接访问实例变量 在对象内部 读取数据 时，应该直接通过 实例变量 来读，而在 写入数据时，则应通过 属性 来写。 在 初始化方法 和 dealloc 方法中，总是应该直接通过 实例变量 来读写数据。 有时候会使用 懒加载 配置某个数据，这种情况下，需要通过 属性 来读取数据。 第8条：理解 “对象等同性” 这一概念 若想检测的对象的等同性，请提供 isEqual: 和 hash 方法。 相同的对象必须具有相同的哈希码，但是两个哈希码相同的对象却未必相同。 不要盲目地逐个检测每条属性，而是依照具体需求来制定检测方案。 编写 hash 方法时，应该使用计算速度快而且哈希码碰撞几率低的算法。 第9条：以“类族模式” 隐藏实现细节 类族模式可以把实现细节隐藏在一套简单的公共接口后面。 系统框架中经常使用类族。 从类族的公共抽象基类中继承子类时要当心，若有开发文档，则应首先阅读。 需要向类族中新增实体子类，需要遵守的几条规则： 子类应该继承自类族的抽象基类。 子类应该定义自己的数据存储方式。 子类应当覆写超类文档中指明需要覆写的方法。 第10条：在既有类中使用关联对象存放自定义数据 可以通过“关联对象”机制来把两个对象关联起来。 定义关联对象时可指定内存管理语义，用以模仿定义属性时所采用的“拥有关系” 和 “非拥有关系”。 只有其他做法不可行时才应选用关联对象，因为这种做法通常会引入难以查找的bug。 对象关联类型： 关联对象 等效的@property属性 OBJC_ASSOCIATION_ASSIGN assign OBJC_ASSOCIATION_RETAIN_NONATOMIC nonatomic,retain OBJC_ASSOCIATION_COPY_NONATOMIC nonatomic,copy OBJC_ASSOCIATION_RETAIN retain OBJC_ASSOCIATION_COPY copy 管理关联对象的方法： 以给定的键和策略为某对象设置关联对象值 1objc_setAssociatedObject(id object, void *key, d value, objc_AssociationPolicy policy) 从某对象中根据键获取设置关联对象的值 1objc_getAssociatedObject(id object, const void *key) 移除指定对象的全部关联对象 1objc_removeAssociatedObjects(id object) 第11条：理解objc_msgSend的作用 消息由接收者、选择子及参数构成。给某对象发送消息（invoke a message）也就相当于在该对象上调用方法 (call a method)。 发给某对象的全部消息都要由”动态消息派发系统（dynamic message dispatch system）来处理，该系统会查出对应的方法，并执行其代码。” objc_msgSend 函数会依据接收者与选择子的类型来调用适当的方法。为了完成此操作，该方法需要在接收者所属的类中搜寻其”方法列表”（list of methods），如果能找到与选择子名称相符的方法，就跳至其实现代码。如果找不到，那就沿着继承体系继续向上查找，等找到合适的方法之后再跳转。如果做种还是找不到相符的方法，那就执行“消息转发” (message forwarding) 操作。 第12条：理解消息转发机制 \u0010若对象无法响应某个选择子，则进入消息转发流程。 通过运行期的动态方法解析功能，我们可以在需要用到某个方法时再将其加入类中。 对象可以把其无法解读的某些选择子转交给其他对象来处理。 经过上述两步之后，如果还是没办法处理选择子，那就启动完整的消息转发机制。 消息转发分为两大阶段： 第一阶段：先征询接收者所属的类，看其是否能动态添加方法，以处理这个未知的选择子 (unknow selector)，这叫做动态方法解析（dynamic selector resolution）。 第二阶段：(完整的消息转发机制 full forwarding mechanism ) 如果运行期系统已经把第一阶段执行完了，那么接收者自己就无法再以动态新增方法的手段来相应包含该选择子的消息了，这时，运行期系统会请求接收者以其他手段来处理与消息相关的方法调用。 第一步：如果有其他对象能够处理这条消息，则把消息转给那个对象，消息转发过程结束，一切如常。 第二步：如果没有（replacement receiver），则启动完整的消息转发机制，运行期系统会把与消息有关的全部细节都封装到 NSInvocation 对象中，再给接收者最后一次机会，令其设法解决当前还未处理的这条消息。 对象收到无法解读的消息后，首先会调用其所属类的类方法： 1+(BOOL)resolveInstanceMethod:(SEL)sel 第13条：用方法调配技术(method swizzling)调试黑盒方法 在运行期，可以向类中新增或替换选择子所对应的方法实现。 使用另一份实现来替换原有的方法实现，这道工序叫做”方法调配”，开发者常用此技术向原有实现中添加新功能。 一般来说，只有调试程序的时候才需要在运行期修改方法实现，这种做法不宜滥用。 交换方法实现，举个 🌰： 12345678//获取lowercaseString的方法实现Method originalMethod = class_getInstanceMethod([NSString class], @selector(lowercaseString));//获取自定义的xyj_myLowercaseString的方法实现Method swappedMethod = class_getInstanceMethod([NSString class], @selector(xyj_myLowercaseString));//交换两个方法的实现method_exchangeImplementations(originalMethod, swappedMethod); 第14条：理解”类对象”的用意 每个实例都有一个指向 Class 对象的指针，用以表明其类型，而这些 Class 对象则构成了类的继承体系。 如果对象的类型无法在编译期确定，那么就应该使用类型信息查询方法来探知。 尽量使用类型查询方法来确定对象类型，而不要直接比较类对象，因为某些对象可能实现了消息转发功能。 每个对象结构体的首个成员是Class类的变量，该变量定义了对象所属的类，通常称之为is a指针。 isMemberOfClass:判断对象是否为某个特定类的实例。 isKindOfClass:判断对象是否为某类或其派生类的实例。 第15条：用前缀避免命名空间冲突 选择与你的公司、应用程序或二者皆有关联之名称作为类名的前缀，并在所有代码中均使用这一前缀。 若自己所开发的程序库中用到了第三方库，则应为其中的名称加上前缀。 Apple宣称其保留使用所有“两字母前缀（two-letter prefix）”的权利，所以你自己选用的前缀应该是三个字母的！ 第16条：提供 “全能初始化方法（designed initializer）” 在类中提供一个全能初始化方法，并于文档中指明。其他初始化方法均应调用此方法。 若子类的全能初始化方法与超类不同，则需覆写超类中的对应方法。 如果超类的初始化方法不适用于子类，那么应该覆写这个超类方法，并在其中抛出异常。 全能初始化方法：指为对象提供必要信息以便其能完成工作的初始化方法。 如何抛异常 举个 🌰 ： 1@throw [NSException exceptionWithName:NSInternalInconsistencyException reason:@\"这里写异常原因\" userInfo:nil]; 第17条：实现description方法 实现 description 方法返回一个有意义的字符串，用以描述该实例。 如果想在description方法中输出很多互不相同的信息，那就借助NSDictionary类的description方法。 举个 🌰 ： 1234- (NSString *)description&#123; return [NSString stringWithFormat:@\"&lt;%@: %p %@&gt;\",[self class],self,@&#123;@\"title\":_title,@\"latitude\":@(_latitude),@\"longitude\":@(_longitude)&#125;];&#125; 若想在调试时打印出更详尽的对象描述信息，则应实现 debugDescription 方法。 debugDescription方法是开发者在调试器(debugger)中以控制台命令打印对象时才调用的。 LLDB 的 po 命令可以完成对象打印(print-object)工作！举个 🌰 ： 123456789- (NSString *)description&#123; return [NSString stringWithFormat:@\"%@ %@\",_firstName,_lastName];&#125;- (NSString *)debugDescription&#123; return [NSString stringWithFormat:@\"&lt;%@: %p \\\" %@ %@ \\\"&gt;\",[self class],self,_firstName,_lastName];&#125; 第18条：尽量使用不可变对象 尽量创建不可变的对象。 举个 🌰 ： 1@property (nonatomic,copy,readonly) NSString * firstName; //!&lt; 名字 若某属性仅用于对象内部修改，则在 “class-continuation分类” 中将 readonly 属性扩展为 readwrite 属性。 举个 🌰 ： 12345@interface XYJPerson ()@property (nonatomic,copy,readwrite) NSString * firstName;@end 不要把可变的 collection 作为属性公开，而应提供相应的方法，以此修改对象中的可变 collection。 举个 🌰 ： 12345678910111213141516171819202122232425262728293031323334353637383940//.h文件中的声明@property (nonatomic,strong,readonly) NSSet * friends;- (void) addFriends:(XYJPerson *) person;- (void) deleteFriends:(XYJPerson *) person;//.m文件中的实现&#123; NSMutableSet * _internalFriends;&#125;- (instancetype)initWithFirstName:(NSString *) first lastName:(NSString *) last&#123; self = [super init]; if (self) &#123; _firstName = [first copy]; _lastName = [last copy]; _internalFriends = [NSMutableSet new]; //注意初始化 &#125; return self;&#125;- (void)addFriends:(XYJPerson *)person&#123; [_internalFriends addObject:person];&#125;- (void) deleteFriends:(XYJPerson *)person&#123; [_internalFriends removeObject:person];&#125;//覆写friends的getter方法- (NSSet *)friends &#123; return [_internalFriends copy];&#125; 不要在返回的对象上查询类型以确定其是否可变。 开发者或许不宜从底层直接修改对象中的数据。 第19条：使用清晰而协调的命名方式 起名时应遵从标准的 Objective-C 命名规范，这样创建出来的接口更容易为开发者所理解。 方法名要言简意赅，从左至右读起来要像个日常用语中的句子才好。 方法名里不要使用缩略后的类型名称 给方法起名时的第一个要务就是确保风格与你自己的代码或所集成的框架相符。 变量与方法名使用 驼峰式大小命名法 — 以小写字母开头，其后每个单词首字母大写。类名也用驼峰命名法，不过其首字母要大写，前面通常还有三个前缀字母。 方法命名的注意事项： 如果方法的返回值是新创建的，那么方法名的首个词应该是返回值的类型，除非前面还有修饰语。属性的存取方法不遵循这种命名方式，因为一般认为这些方法不会创建新对象，即便有时返回内部对象的一份拷贝，我们也认为那相当于原有的对象。这些存取方法应该按照其所对应的属性来命名。 应该把表示参数类型的名词放在参数前面。 如：mutableString 如果方法要在当前对象上执行操作，那么就应该包含动词；若执行操作时还需要参数，则应该在动词后面加上一个或多个名词。 不要使用 str 这种简称，应该使用 string 这样的全称。 Boolean 属性应加 is 前缀。如果某方法返回非属性的 Boolean 值，那么应该根据其功能，选用 has 或 is 当前缀。 将 get 这个前缀留给那些借由“输出参数”来保存返回值的方法。 第20条：为私有方法名加前缀 给私有方法的名称加上前缀，这样可以很容易地将其同公共方法区别开。 不要单用一个下划线做私有方法的前缀，因为这种做法是预留给苹果公司用的。 第21条：理解Objective-C错误类型 \u0010只有发生了可使整个应用程序崩溃的严重错误时，才应使用异常。 在错误不那么严重的情况下，可以指派委托方法 (delegate method) 来处理错误，也可以把错误对象放到 NSError 对象里，经由输出参数返回给调用者。 第22条：理解 NSCopying协议 若想令自己所写的对象具有拷贝功能，则需实现 NSCopying 协议。 如果自定义的对象分为可变版本和不可变版本，那么需要同时实现 NSCopying 和 NSMutableCopying 协议。 复制对象时需决定采用深拷贝还是浅拷贝，一般情况下应该尽量执行浅拷贝。 如果你写的对象需要深拷贝，那么可考虑新增一个专门执行深拷贝的方法。 若想某个类支持拷贝功能，只需声明该类遵循NSCopying协议，并实现其中的 copyWithZone 这个方法。 举个 🌰 ： 12345- (id) copyWithZone:(NSZone *) zone&#123; XYJPerson * copy = [[[self class] allocWithZone:zone] initWithFirstName:_firstName andLastName:_lastName]; return copy;&#125; 在可变对象上调用 copy 方法会返回另外一个不可变类的实例。 深拷贝：在拷贝对象自身时，将其底层数据也一并复制过去。 浅拷贝：只拷贝容器对象本身，而不复制其中数据，浅拷贝之后的内容与原始内容均指向相同对象。 第23条：通过委托与数据源协议进行对象间通信 委托模式为对象提供了一套接口，使其可由此将相关事件告知其他对象。 将委托对象应该支持的接口定义成协议，在协议中把可能需要处理的事件定义成方法。 当某对象需要从另外一个对象中获取数据时，可以使用委托模式。这种情境下，该模式亦称“数据源协议（data source protocol）”。 若有必要，可实现含有位段的结构体，将委托对象是否能相应相关协议方法这一信息缓存至其中。 Objective-C不支持多重继承，因而我们把某个类应该实现的一系列方法定义在协议里面。协议最为常见的用途是实现委托模式。 类别（Category）使得我们无需继承子类即可直接为当前类添加方法。 委托模式（Delegate pattern）的主旨是： 定义一套接口，某对象若想接受另一个对象的委托，则需遵从此接口，以便成为其委托对象 （Delegate）。而另一个对象则可以给其委托对象回传一些信息，也可以在发生相关事件时通知委托对象。 被委托的对象的操作步骤： 1、定义一套协议，协议名通常是在相关类名后面加上 Delegate 一词，然后声明协议要实现的方法，一般是可选的，用 @optional 关键字标注。 2、在类中声明一个委托对象的属性，需用 weak 来修饰。 3、事件触发的时候调用声明的协议方法。 委托对象的操作步骤： 1、一般在 class-continuation 分类中声明遵守该委托协议。 2、设置被委托对象的 Delegate 为 self。 3、实现委托协议中的代理方法。 第24条：将类的实现代码分散到便于管理的数个分类（category）之中 使用分类机制把类的实现代码划分成易于管理的小块。 将应该视为“私有”的方法归入名为 Private 的分类中，以隐藏实现细节。 第25条：总是为第三方类的分类名称加前缀 向第三方类中添加分类时，总应给其名称加上你专用的前缀。 向第三方类中添加分类时，总应给其中的方法加上你专用的前缀。 第26条：勿在分类中声明属性 把封装数据所用的全部属性都定义在主接口里。 在“ class-continuation 分类”之外的其他分类中，可以定义存取方法，但尽量不要定义属性。 第27条：使用“class-continuation分类”隐藏实现细节 通过 class-continuation 分类向类中新增实例变量。 如果某属性在主接口中声明为 readonly ，而类的内部又要用设置方法修改此属性，那么就在 class-continuation分类 中将其扩展为 readwrite。 把私有方法的原型声明在 class-continuation 分类里面。 若想使类所遵循的协议不为人所知，则可于class-continuation 分类中声明。 第28条：通过协议提供匿名对象 协议可在某种程度上提供匿名类型。具体的对象类型可以淡化成遵从某协议的 id 类型，协议里规定了对象所应实现的方法。 使用匿名对象来隐藏类型名称（或类名）。 如果具体类型不重要，重要的是对象能够响应（定义在协议里的）特定方法，那么可以使用匿名对象来表示。 第29条：理解引用计数 引用计数机制通过可以递增递减的计数器来管理内存。对象创建好之后，其保留计数至少为 1。若保留计数为正，则对象继续存活。当保留计数降为 0 时，对象就销毁了。 在对象生命周期中，其余对象通过引用来保留或释放此对象。保留和释放操作分别会递增及递减保留计数。 autorelease 能延长对象生命周期，使其在跨越方法调用边界后依然可以存活一段时间。 第30条：以ARC简化引用计数 有 ARC 之后，程序员就无需担心内存管理问题了。使用 ARC 来编程，可省去类中的许多“样板代码”。 ARC 管理对象生命期的办法基本上就是：在合适的地方插入“保留”及“释放”操作，在ARC环境下，变量的内存语义可以通过修饰符指明，而原来则需要手工执行“保留”及“释放”操作。 由方法所返回的对象，其内存管理语义总是通过方法名来体现。ARC 将此确定为开发者必须遵守的原则。 ARC 只负责管理 Objective-C 对象的内存。尤其要注意：CoreFoundation 对象不归 ARC 管理，开发者必须适时调用 CFRetain / CFRelease。 第31条：在 dealloc 方法中只释放引用并解除监听 在 dealloc 方法里，应该做的事情就是释放指向其他对象的引用，并取消原来订阅的键值观测（KVO）或 NSNotificationCenter 等通知，不要做其他事情。 如果对象持有文件描述符等系统资源，那么应该专门编写一个方法来释放此种资源。这样的类要和其使用者约定：用完资源后必须调用 close 方法。 执行异步任务的方法不应在 dealloc 方法里调用；只能在正常状态下执行的那些方法也不应在 dealloc 里调用，因为此时对象已处于正在回收的状态了。 第32条：编写“异常安全代码”时留意内存管理问题 捕获异常时，一定要注意将 try 块内所创立的对象清理干净。 在默认情况下，ARC 不生成安全处理异常所需的清理代码。开启编译器标志后，可以生成这种代码，不过会导致应用程序变大，而且降低运行效率。 若使用ARC且必须捕获异常，则需打开编译器的 -fobjc-arc-exceptions 标志。 第33条：以若引用避免保留环 将某些应用设为 weak，可避免出现“保留环”。 weak 引用可以自动清空，也可以不自动清空。自动清空（ autoniling） 是随着 ARC 而引入的新特性，由运行期系统来实现。在具备自动清空功能的弱引用上，可以随意读取其数据，因为这种引用不会指向已经回收过的对象。 unsafe_unretained 一词表明，属性值可能不安全，而且不归此实例所拥有。weak 和 unsafe_unretained 的作用一样，唯一的不同是，只要系统把属性回收，属性值就会自动设置为 nil。但是 unsafe_unretained 属性仍然指向那个已经回收的实例。 第34条：以“自动释放池”降低内存峰值 自动释放池排布在栈中，对象收到 autorelease 消息后，系统将其放入最顶端的池里。 合理运用释放池，可降低应用程序的内存峰值。 @autoreleasepool 这种新式写法能创建出更为轻便的自动释放池。 自动释放池用于存放那些需要在稍后某个时刻释放的对象。清空自动释放池时，系统会向其中的对象发送release 消息。 内存峰值 （high-memory waterline） 是指应用程序在某个特定时间段内的最大内存用量 （highest memory footprint）。 第35条：用“僵尸对象”调试内存管理问题 系统在回收对象时，可以不将其真的回收，而是把它转化为僵尸对象。通过环境变量 NSZombieEnabled 可开启此功能。 系统会修改对象的 isa 指针，令其指向特殊的僵尸类，从而使该对象变为僵尸对象。僵尸类能够响应所有的选择子，响应方式为：打印一条包含消息内容及其接收者的消息，然后终止应用程序。 第36条：不要使用retainCount 对象的保留计数看似有用，实则不然，因为任何给定时间点上的”绝对保留计数”（absolute retain count）都无法反应对象生命期的全貌。 引入 ARC 之后，retainCount 方法就正式废止了，在 ARC 下调用该方法会导致编译器报错。 第37条：理解Block这一概念 块是 C、C++、Objective-C 中的词法闭包。 块可接收参数，也可返回值。 块可以分配在栈或堆上，也可以是全局的。分配在栈上的块可拷贝在堆里。这样的话，就和标准的Objective-C 对象一样，具备引用计数了。 块的语法结构如下： 1return_type (^block_name)(parameters) 举个 🌰 ： 123int (^addBlock) (int a, int b) = ^(int a, int b) &#123; return a+b;&#125; 块的强大之处：在声明它的范围内，所有变量都可以为其捕获。如果要修改捕获的变量，那么，声明变量的时候需要加上 __block 关键词。 第38条：为常用的Block类型创建typedef 以 typedef 重新定义块类型，可令块变量用起来更加简单。 定义新类型时应遵守现有的命名习惯，勿使其名称与别的类型相冲突。 不妨为同一个块签名定义多个类型别名。如果要重构的代码使用了块类型的某个别名，那么只需修改相应的typedef 中的块签名即可，无需改动其他 typedef。 typedef 关键字用于给类型起个易读的别名。* 1typedef double NSTimeInterval; Block 的 typedef: 1typedef int (^XYJSomeBlock) (BOOL flag, int value); 第39条：用handle块降低代码分散程度 在创建对象时，可以使用内联的 handle 块将相关逻辑一并声明。 在有多个实例需要监控时，如果采用委托模式，那么经常需要根据传入的对象来切换，而若改用 handle 块来实现，则可直接将块与相关对象放在一起。 设计 API 时如果用到了 handle 块，那么可以增加一个参数，使调用者可通过此参数来决定应该把块安排在哪个队列上。 第40条：用块引用其所属对象时不要出现保留环 如果块所捕获的对象直接或间接地保留了块本身，那么就得当心保留环问题。 一定要找个适当的时机解除保留环，而不能把责任推给 API 的调用者。 第41条：多用派发队列，少用同步锁 派发队列可用来表述同步语义（synchronize semantic），这种做法要比使用 @synchronized 块或NSLock 对象更简单。 将同步和异步派发结合起来，可以实现与普通加锁机制一样的同步行为，而这么做却不会阻塞执行异步派发的线程。 使用同步队列及栅栏块，可以令同步更加高效。 第42条：多用 GCD，少用 performSelector 系列方法 performSelector 系列方法在内存管理方面容易有疏失。它无法确定将要执行的选择子具体是什么，因而 ARC 编译器也就无法插入适当的内存管理方法。 performSelector 系列方法所能处理的选择子太过局限了，选择子的返回值类型及发送给方法的参数个数都受到限制。 如果想把任务放到另一个线程上执行，那么最好不要用 performSelector 方法，而是应该把任务封装在块里，然后调用 GCD 的相关方法来实现。 第43条：掌握 GCD 及操作队列的使用时机 在解决多线程与任务管理问题时，派发队列并非唯一方案。 操作队列提供了一套高层的 Objective-C API ,能实现纯 GCD 所具备的绝大部分功能，而且还能完成一些更为复杂的操作，那些操作若改用 GCD 来实现，则需另外编写代码。 GCD是纯C的API，而操作队列则是 Objective-C 的对象。 使用NSOperation和NSOperationQueue的好处： 1、取消某个操作。 2、指定操作间的依赖关系。 3、通过键值观察机制监控 NSOperation 对象的属性。 4、指定操作的优先级。 5、重用 NSOperation 对象。 第44条：通过 Dispatch Group 机制，根据系统资源状况来执行任务 1、一系列任务可归入一个 dispatch group 之中。开发者可以在这组任务执行完毕时获得通知。 2、通过 dispatch group，可以在并发式派发队列里同时执行多项任务。此时GCD会根据系统资源状况来调度这些并发执行的任务。开发者若自己来实现此功能，则需编写大量代码。 第45条：使用dispatch_once来执行只需运行一次的线程安全代码 1、经常需要编写“只需执行一次的线程安全的代码”（thread-safe single-code execution）。通过GCD 所提供的 dispatch_once 函数，很容易就能实现此功能。 2、标记应该声明在 static 或 global 作用域中，这样的话，在把只需执行一次的块传给dispatch_once 函数时，传进去的标记也是相同的。 单例的使用：举个 🌰 1234567891011+ (FFHttpRequestManager *)shareManager&#123; static FFHttpRequestManager *shareInstance = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; shareInstance = [[FFHttpRequestManager alloc]init]; &#125;); return shareInstance;&#125; 第46条：不要使用dispatch_get_current_queue dispatch_get_current_queue 函数的行为常常与开发者所预期的不同。此函数已经废弃，只应做调试只用。 由于派发队列是按层级来组织的，所以无法单用某个队列对象来描述“当前队列这一概念”。dispatch_get_current_queue 函数用于解决由不可重入的代码所引发的死锁，然而能用此函数解决的问题，通常也能改用“队列特定数据”来解决。 第47条：熟悉系统框架 许多系统框架都可以直接使用。其中最重要的是 Foundation 与 CoreFoundation，这两个框架提供了构建应用程序所需的许多核心功能。 很多常见任务都能用框架来做，例如音频与视频处理、网络通信、数据管理等。 请记住：用纯C写成的框架与用 Objective-C 写成的一样重要，若想成为优秀的 Objective-C 开发者，应该掌握 C 语言的核心概念。 第48条：多用块枚举，少用for循环 遍历 collection 有四种方式。最基本的是 for 循环，其次是 NSEnumerator 遍历法及快速遍历法，最新最先进的方式则是“块枚举法”。 “块枚举法”本身就能通过 GCD 来并发执行遍历操作，无须另行编写代码。而采用其他遍历方式则无法轻易实现这一点。 若提前知道待遍历的 collection 含有何种对象，则应修改块签名，指出对象的具体类型。 for 循环数组的遍历 123456NSArray * anArray = @[@\"one\",@\"two\",@\"three\"];for (int i = 0; i &lt; anArray.count; i++) &#123; id object = anArray[i]; // Do something with 'object'&#125; 字典的遍历 12345678NSDictionary * aDictionary = @&#123;@\"one\":@\"1\",@\"two\":@\"2\",@\"three\":@\"3\"&#125;;NSArray * keys = [aDictionary allKeys];for (int i = 0; i &lt; keys.count; i++) &#123; id key = keys[i]; id value = aDictionary[key]; // Do something with 'key' and 'value'&#125; Set 的遍历 123456NSSet * aSet = /* ... */;NSArray * objects = [aSet allObjects];for (int i = 0; i &lt; objects.count; i++) &#123; id object = objects[i]; // Do something with 'Object'&#125; NSEnumerator 来遍历数组的遍历 123456NSArray * array = @[@\"apple\",@\"banana\",@\"orange\"];NSEnumerator * enumerator = [array objectEnumerator];id object;while ((object = [enumerator nextObject]) != nil) &#123; //Do something with 'object'&#125; 数组的反向遍历 1234NSArray * array = @[@\"apple\",@\"banana\",@\"orange\"];for (id object in [array reverseObjectEnumerator]) &#123; // Do something with 'object'&#125; 字典的遍历 12345678NSDictionary * aDictionary = @&#123;@\"one\":@\"1\",@\"two\":@\"2\",@\"three\":@\"3\"&#125;;NSEnumerator * enumerator = [aDictionary keyEnumerator];id key;while ((key = [enumerator nextObject]) != nil) &#123; id value = aDictionary[key]; // Do something with 'key' and 'value'&#125; Set 的遍历 1234567NSSet * aSet = /* ... */;NSEnumerator * enumerator = [aSet objectEnumerator];id object;while ((object = [enumerator nextObject]) != nil) &#123; // Do something with 'object'&#125; for-in 快速遍历数组的遍历 12345NSArray * anArray = @[@\"one\",@\"two\",@\"three\"];for (id object in anArray) &#123; // Do something with 'object'&#125; 字典的遍历 123456NSDictionary * aDictionary = @&#123;@\"one\":@\"1\",@\"two\":@\"2\",@\"three\":@\"3\"&#125;;for (id key in aDictionary) &#123; id value = aDictionary[key]; // Do something with 'key' and 'value'&#125; Set 的遍历 12345NSSet * aSet = /* ... */;for (id object in aSet) &#123; // Do something with 'object'&#125; 基于块的遍历方式数组的遍历 123456789NSArray * array = @[@\"apple\",@\"banana\",@\"orange\"]; [array enumerateObjectsUsingBlock:^(id _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123; //Do something with 'obj' //if stop *stop = YES; &#125;]; 字典的遍历 123456789NSDictionary * aDictionary = @&#123;@\"one\":@\"1\",@\"two\":@\"2\",@\"three\":@\"3\"&#125;; [aDictionary enumerateKeysAndObjectsUsingBlock:^(id _Nonnull key, id _Nonnull obj, BOOL * _Nonnull stop) &#123; //Do something with 'key' and 'obj' //if stop *stop = YES; &#125;]; Set 的遍历 12345678NSSet * aSet = /* ... */; [aSet enumerateObjectsUsingBlock:^(id _Nonnull obj, BOOL * _Nonnull stop) &#123; //Do something with 'obj' //if stop *stop = YES;&#125;]; 第49条：对自定义其内存管理语义的collection使用无缝桥接（toll-free bridging） 通过无缝桥接技术，可以在 Foundation 框架中的 Objective-C 对象与 CoreFoundation 框架中的 C 语言结构之间来回转换。 在 CoreFoundation 层面创建 collection 时，可以指定许多回调函数，这些函数表示此 collection 应如何处理其元素。然后，可运用无缝桥接技术，将其转换成具备特殊内容管理语义的 Objective-C collection。 __bridge ARC 仍然具备这个 Objective-C 对象的所有权。__bridge_retained ARC 将交出对象的所有权。__bridge_transfer 类似于想把 CFArrayRef 转换为 NSArray ，并且想让 ARC 获得对象所有权。 第50条：构建缓存时选用 NSCache 而非 NSDictionary 实现缓存时应选用 NSCache 而非 NSDictionary 对象。因为 NSCache 可以优雅的自动删减功能，而且是线程安全的，此外，它与字典不同，并不会拷贝键。 可以给 NSCache 对象设置上限，用以限制缓存中的对象总个数及总成本，而这些尺寸则定义了缓存删减其中对象的时机。但是绝对不要把这些尺度当成可靠的“硬限制”，他们仅对 NSCache 起指导作用。 将 NSPurgeableData 与 NSCache 搭配使用，可实现自动清除数据的功能，也就是说，当NSPurgeableData 对象所占内存为系统所丢弃时，该对象自身也会从缓存中移除。 如果缓存使用得当，那么应用程序的响应速度就能提高。只有那种“重新计算起来很费事”的数据，才值得放入缓存，比如那些需要从网络获取或从磁盘读取的数据。 第51条：精简 initialize 与 load 的实现代码 在加载阶段，如果类实现了 load 方法，那么系统就会调用它。分类里也可以定义此方法，类的 load 方法要比分类中的先调用。与其他方法不同，load 方法不参与覆写机制。 首次使用某个类之前，系统会向其发送 initialize 消息。由于此方法遵从普通的覆写规则，所以通常应该在里面判断当前要初始化的是哪个类。 load 与 initialize 方法都应该精简一些，这有助于保持应用的响应能力，也能减少引入“依赖环”的几率。 无法在编译期设定的全局常量，可以放在 initialize 方法里初始化。 第52条：别忘了 NSTimer 会保留其目标对象 NSTimer 会保留其目标，直到计时器本身失效为止，调用 invalidate 方法可令计时器失效，另外，一次性的计时器在触发完任务之后也会失效。 反复执行任务的计时器，很容易引入保留环，如果这种计时器的目标对象又保留了计时器本身，那肯定会导致保留环。这种环状保留关系，可能是直接发生的，也可能是通过对象图里的其他对象间接发生的。 可以扩充 NSTimer 的功能，用块来打破保留环。不过除非NSTimer将来在公共接口里提供此功能，否则必须创建分类，将相关的代码加入其中。 感谢您的阅读，一起学习，一起成长，加油！","tags":[{"name":"编写高质量iOS与OS X代码的52个有效方法","slug":"编写高质量iOS与OS-X代码的52个有效方法","permalink":"http://yoursite.com/tags/编写高质量iOS与OS-X代码的52个有效方法/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/tags/学习笔记/"}]},{"title":"zsh 的配置和 CocoaPods 的安装与使用","date":"2015-10-05T08:17:11.000Z","path":"2015/10/05/zsh-and-CocoaPods/","text":"版权声明：本文为 muhlenXi 原创文章，欢迎转载，转载请注明来源: http://muhlenxi.com/2015/10/05/zsh-and-CocoaPods 导语： 对于一个爱折腾的人是闲不住的，最近经常和终端(terminal)打交道，看着这普普通通的界面，实在在是人不可忍了，有一次网上查资料的时候，了解到zsh可以配制出高逼格的用户界面，就是配置有些复杂。但是程序猿都是一群聪明的家伙，研究出oh-my-zsh这个开源项目，让zsh配置降到了零门槛，而且完全兼容bash。 废话不多说，开整吧！ 通过oh-my-zsh配置zsh配置步骤 打开我们亲爱的终端：输入命令：cat /etc/shells 可以看到Mac内置了6中shell 1、安装 oh-my-zsh ，它会自动读取你的环境并帮你设置zsh oh-my-zsh 的地址是：http://github.com/robbyrussell/oh-my-zsh 在终端内输入以下命令clone oh-my-zsh： git clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh 2、替换zshrc文件： cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc 3、切换到zsh模式： chsh -s /bin/zsh 4、关闭并重新打开终端后，会发现变成zsh了，接下来是选择一款高逼格的主题！ oh-my-zsh 主题的主题和对应截图在在这里！ 我选择的是ys主题，在终端中打开oh-my-zsh的配置文件，设置主题为ys： vim ~/.zshrc //打开.zshrc文件 按字母i进入编辑模式，修改ZSH_THEME=&quot;ys&quot;后，按esc退出编辑模式，再按shift + ：，输入wq,就是保存并退出的意思。 5、打开终端的偏好设置，设置如下，就和我的一样了： zsh的配置到这里就结束了。 附上我的zsh最终效果图： 终端常用的命令：1、clear 清除屏幕或窗口内容 2、ls 显示当前目录的内容 3、ls -ah 全部显示当前目录的内容（包含隐藏的） 4、mkdir 创建一个目录 如：mkdir helloword 5、rmdir 删除一个目录 6、mvdir 移动或重命名一个目录 7、cd 改变当前目录 8、pwd 显示当前目录的路径名 9、dircmp 比较两个目录的内容 10、killall -KILL Finder 重启Finder 11、cd .. 返回上一级目录 12、cd ~ 返回主目录 显示mac中隐藏文件\u0010(需重启Finder) defaults write com.apple.finder AppleShowAllFiles -bool true 隐藏mac中隐藏文件(需重启Finder) defaults write com.apple.finder AppleShowAllFiles -bool false 后续会陆续添加… CocoaPods的安装与使用CocoaPods的安装 CocoaPods是一个第三方库的依赖管理工具，可以自动更新第三方库，自动添加系统依赖库，自动设置编译选项，总的来说，就是能自动配置第三个方库的运行环境。他是一个命令行工具！ 打开终端如下操作 1、移除默认的ruby源 gem sources --remove https://rubygems.org/ 移除后会提示：https://rubygems.org/ removed from sources 2、添加 taobao 的源 gem sources -a https://ruby.taobao.org/ 目前源已经更新为：https://gems.ruby-china.org 2017-03-21 修正 1、如果曾经添加过淘宝的源，请执行如下操作，确保只有一个源。 gem sources --add https://gems.ruby-china.org/ --remove http://ruby.taobao.org/ 2、如果没有添加过 taobao 的源，可直接 安装 ruby-china 的源 gem sources --add https://gems.ruby-china.org/ 添加后会提示相应的源已经 added to sources。 3、查看当前的源 gem sources -l 显示结果如图：（该图已经过期，现在应该显示的是 https://gems.ruby-china.org/） 4、安装CocoaPods sudo gem install -n /usr/local/bin cocoapods 安装完成如下图： 终端输入gem list查看CocoaPods的版本 由图知，目前CocoaPods的版本是1.0.1 CocoaPods 添加第三方库1、查看一个库是不是支持CocoaPods 以AFNetworking为例 pod search AFNetworking 出现如图信息则表示支持 2、在Podfile文件添加相应版本的库 cd到你的Xcode项目的目录下： vim Podfile 在里面添加 说明： Podfile升级之后到1.0.0版本，Pod里的内容必须明确指出所用第三方库的target 所以在podfile文件需要明确： target “YOUR_TARGRT_NAME” do ... end 3、安装第三方库 pod install --verbose --no-repo-update 安装完成显示如图： 4、CocoaPods更新第三方库 当我们拿到别人的项目，或者自己的项目要添加新的第三方库，需要更新第三方库。 pod update --verbose --no-repo-update 感谢阅读，有什么问题可以给我留言。","tags":[{"name":"zsh","slug":"zsh","permalink":"http://yoursite.com/tags/zsh/"},{"name":"CocoaPods","slug":"CocoaPods","permalink":"http://yoursite.com/tags/CocoaPods/"}]},{"title":"我为什么要开始写博客？","date":"2015-09-02T03:00:32.000Z","path":"2015/09/02/The-reason-of-write-blog/","text":"想满足好奇心就进来看看吧。 古人云：一分耕耘一分收获 1、记录自己学习、不断的思考总结的过程； 2、分享我的故事、所得、感想、经验； 3、持续学习，积累更多的知识； 4、整理思路、固话知识，获得更多更好的想法！ 5、提高自己将事情讲清楚的能力； 6、记录成长，不断修正自己的错误，如果能指引志同道合的人避免走弯 路，更好； 7、培养自己默默地持续做一件事情的能力！如健身、读书… 8、培养一个业余爱好。 9、结交一些志同道合的朋友！互相鼓励！一路前行！ 10、为自己的人生留下一点痕迹！ 给自己的忠告： 就算你觉得没人会看你写的东西，也要坚持写下去！","tags":[{"name":"写博客起因","slug":"写博客起因","permalink":"http://yoursite.com/tags/写博客起因/"}]},{"title":"ASIHTTPRequest 的简介和使用","date":"2015-08-15T06:08:37.000Z","path":"2015/08/15/ASIHTTPRequest/","text":"版权声明：本文为 muhlenXi 原创文章，欢迎转载，转载请注明来源: http://muhlenxi.com/2015/08/15/ASIHTTPRequest 导语： ASIHttpRequest 是一款及其强劲的 HTTP 访问开源项目，让简单的 API 完成复杂的功能，如：异步请求、队列请求、GZIP 压缩、缓存、断点续传、进度跟踪、上传文件、HTTP 认证，同时加入了 Objective-C 闭包 Block 的支持，让我们的代码更加灵活。 由于 ASIHTTPRequest 是开源项目旧版本的库，没有适配 ARC 项目。所以对于目前之前 ARC 的工程来说，需要做适配。 ASIHTTPRequest 的环境配置下载 ASIHTTPRequest 库 点击ASIHTTPRequest下载ASIHTTPResent库。 添加 ASIHTTPRequest 库 到项目组中 找到 ASIHTTPRequest-master 目录，将目录中的 ASIHTTPRequest 文件夹内的所有文件添加到项目中。 添加 系统依赖库【1】选择工程 -&gt; TARGETS -&gt; Building Phases -&gt; Link Binary With Libraries 【2】点击 “+” 号搜索添加。 1、CFNetwork.framework 2、SystemConfiguration.framework 3、MobileCoreServices.framework 4、CoreGraphics.framework 5、libz.1.2.5.tbd 【3】编译运行，会报错。这是ARC使用非ARC库导致的。所以要适配非ARC库，也就是说要在费ARC文件中添加 -fno-objc-arc 字段 ARC 环境下适配非 ARC 文件【1】选择工程 -&gt; TARGETS -&gt; Building Phases -&gt; Compile Source 【2】双击其中的 .m 文件，添加 -fno-objc-arc 字段。 适配完如图所示： ASIHTTPRequest 的使用异步网络请求【1】导入头文件 #import &quot;ASIHTTPRequest.h&quot; 【2】创建并启动异步网络请求 NSString * urlstr = @&quot;http://app.careeach.com:80/action/json_201411/userdata.jsp?action=userdata&amp;userid=22115195&amp;waibao_id=0&quot;; NSURL * url = [NSURL URLWithString:urlstr]; ASIHTTPRequest * request = [ASIHTTPRequest requestWithURL:url]; request.delegate = self; [request startAsynchronous]; 【3】实现请求回调方法 #pragma mark - ASIHTTPRequest-delegate - (void)requestFinished:(ASIHTTPRequest *)request { NSString *respondStr = [request responseString]; NSLog(@&quot;获取个人信息成功&quot;); if(respondStr != nil) { NSError *error; NSData *data = [respondStr dataUsingEncoding:NSUTF8StringEncoding]; NSDictionary * infoDic = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingMutableLeaves error:&amp;error]; NSLog(@&quot;inforDic == %@&quot;,infoDic); } } - (void) requestFailed:(ASIHTTPRequest *)request { NSLog(@&quot;获取个人信息错误,error = %@&quot;,request.error); } 编译并运行项目后，结果如下： 未使用到的会后续补充…,谢谢！","tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://yoursite.com/tags/Objective-C/"},{"name":"ASIHttpRequest","slug":"ASIHttpRequest","permalink":"http://yoursite.com/tags/ASIHttpRequest/"}]},{"title":"在 Mac 上如何搭建 Hexo 个人博客","date":"2015-08-01T03:11:17.000Z","path":"2015/08/01/How-to-make-a-blog-by-Hexo/","text":"版权声明：本文为 muhlenXi 原创文章，欢迎转载，转载请注明来源: http://muhlenxi.com/2015/08/01/How-to-make-a-blog-by-Hexo/ 导语： 在网上经常浏览技术牛人的博客来学习技术能力，突然有个念头闪现在脑海,为啥我不自己也弄个博客记录自己的学习收获和分享自己的掉坑经验，避免后来的人不像我一样掉坑，岂不更好！对于一个爱折腾的我，立马就开始各种搜索资料，各种踩坑。 更多详情请看我为什么开始写博客 对于不了解Hexo是什么的？可以去Hexo官网了解一下。Hexo简介 ,废话不扯了，开始正题! 安装Node.js（必须） 选择Node.js的安装的程序，进入到下载页面，选择Download for OSX(x64),左边的版本是建议大多数用户使用的版本，右边的则是最新版本，我选择了左边的那个版本，然后，下载，安装即可。 安装Git(必须) 由于我经常使用Xcode软件，所以这里不用安装Git,Xcoder软件自带Git,也许有些人不知道Git是什么以及怎么使用，可以看Git教程了解一下，这是我目前见到讲解的深入浅出的文章。 PS：后面需要配置站点和主题文件，需要打开其他格式的文本，个人建议用Xcode会好些。 Xcode for Mac 安装 Git 安装 注册Github账号（必须） 注册Github账号可以看Github的注册与使用（详细图解） 进一步想深入学习Github的可以看一下这个博客 从0开始学习Github系列汇总 Hexo 的安装与配置安装Hexo 以上三步，根据自己实际情况安装。安装完成后，可进行接下来这步。打开终端，cd到你想要存放Hexo配置的路径下进行如下操作： mkdir &quot;MyBlog&quot; //创建MyBlog文件夹 ls //查看当前目录下是否有MyBlog文件夹 cd cd MyBlog/ //进入到MyBlog目录下 sudo npm install-g hexo //安装Hexo hexo init //初始化Hexo 到这里为止，Hexo博客安装工作基本完成，MyBlog就是你博客的根目录，关于博客的所有操作均在MyBlog里面进行。 配置Github 【1】登录你的Github账号，创建一个Repository（仓库），仓库的名字必须是 你的github的用户名.github.io （这是固定写法） 在这里假设你的用户名是zhangsan，则你要创建的仓库名就是zhangsan.github.io 【2】用 终端 或者 Github Desktop软件 Clone zhangsan.github.io 仓库到本地你指定的目录下。 【3】进入到MyBlog文件夹，找到 _config.yml (站点配置文件)然后打开它，我用Xcode打开它，翻到最后面，进行如下操作 改成这个样子： deploy: type:git repository:git@github.com:zhangsan/zhangsan.github.io.git branch:master 【4】打开终端 输入 npm install hexo-deployer-git --save hexo generate 或 hexo g //生成静态界面 hexo server //本地启动 【5】打开浏览器 输入 http://localhost:4000/ 则可以看到你 本地生成的静态页面了 打开终端 使用快捷键 control + c 停止本地启动进程 【6】拷贝MyBlog目录下的Public文件夹里面的所有文件到你Clone到本地的zhangsan.github.io 文件夹 【7】使用 终端 或者 Github Desktop Commit、Push zhangsan.github.io 到远程Github仓库中 【8】使用 终端 进入到 MyBlog目录下，执行如下命令 hexo deploy //部署博客到Github 这样，就成功的将你的Hexo博客部署到了Github，你在浏览器中输入http://zhangsan.github.io 就可以了看到你的博客了。 常用的Hexo基本操作hexo clean //清理缓存 hexo generate //生成静态界面 hexo deploy //部署到Github hexo server //本地启动博客 hexo new “文章名” //新建一篇文章 hexo new page &quot;页面名&quot; //新建一个页面 hexo help //查看帮助 hexo version //查看Hexo的版本 给你的博客安装并配置 Next主题 Next主题的主旨在于简洁优雅并且易于使用，尤其是是精于心，简于形的里面深入我心，见到的第一眼，就深深的吸引住了，无法自拔。具体步骤如下： 【1】使用终端 进入到 MyBlog目录下，输入命令 git clone https://github.com/iissnan/hexo-theme-next themes/next 这样就把Next主题Clone到你的MyBlog/themes路径下了。 【2】进入到MyBlog文件夹，找到 _config.yml (站点配置文件)然后打开它，我用Xcode打开，找到theme字段，修改成 theme: next 【3】配置Next主题，进入到MyBlog/themes/next目录下，打开_config.yml (主题配置文件)然后打开它，我一般用Xcode打开，找到Schemes字段，next主题有三种形式，我中意Mist,修改如下 # Schemes #scheme: Muse scheme: Mist #scheme: Pisces 【4】打开终端进入到cd到MyBlog文件夹,输入命令 hexo clean hexo generate hexo server 这样，打开浏览器 输入 http://localhost:4000/ 就可以看到和我一样的主题了。 我的博客 mulenxi 更多的Next主题配置，可以参考Next官方文档。 搭建博客参考 1、购买域名，对域名解析和绑定Github，可以参考如何搭建一个独立博客 2、学习使用Markdown,可以参考认识与入门Markdown 3、Hexo搭建过程出现问题，可以参考Hexo—搭建","tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"},{"name":"Next","slug":"Next","permalink":"http://yoursite.com/tags/Next/"}]},{"title":"Hello World","date":"2015-07-26T03:00:55.000Z","path":"2015/07/26/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]