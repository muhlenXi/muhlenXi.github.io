[{"title":"聊聊 AVFoundation 视频编辑","date":"2019-07-24T00:21:41.000Z","path":"2019/07/24/talk-about-avfoundation-md/","text":"版权声明：本文为 muhlenXi 原创文章，未经博主允许不得转载，如有问题，欢迎指正。 ForewordAVFoundation 框架是一个用来播放和创建音视频的框架，它提供了一系列 Objective-C 接口让我们操作音视频的细节数据，比如测试、编辑、重编码视频文件和从设备中获取音视频数据等。 在 iOS 平台上，AVFoundation 的层级是这样的。 如果你想执行一些简单的任务，没必要使用 AVFoundation 框架。 比如播放视频，使用 AVKit framework 就可以了。 比如录音、获取相册中的照片、视频等，用 UIImagePickerController 类就可以了。 在 AVFoundation 中： 播放音频数据，你可以使用 AVAudioPlayer 类，如果你想配置音频的行为，你可以使用 AVAudioSession 类。 录音，你可以使用 AVAudioRecorder 类。 聊聊 Asset 和 Video 的播放AVAsset 是 AVFoundation 框架中最基础的代表视频资源的类。一个 AVAsset 的实例可以理解为是一种包含多种数据的一个集合。我们可以从文件、Photo library 或 iPod library 中生成这个实例。 可以通过一个 URL 来生成一个 AVURLAsset 的实例。其中第二个 options 参数，用来表示是否允许随机精确时间访问。如果你仅仅是为了播放 asset，这个参数可以传 nil，如果你想要加入 AVMutableComposition 中进行视频编辑，则需要传入一个包含 key 为 AVURLAssetPreferPreciseDurationAndTimingKey， value 为 @YES 的 dictionary。 123NSURL *url = &lt;#A URL that identifies an audiovisual asset such as a movie file#&gt;;NSDictionary *options = @&#123;AVURLAssetPreferPreciseDurationAndTimingKey : @YES &#125;;AVURLAsset *anAssetToUseInAComposition = [[AVURLAsset alloc] initWithURL:url options:options]; 【1】、如果想要访问用户相册中的 asset，可以通过 Photos framework 中的 PHPhotoLibrary 类来管理和访问 photo library，在相册中分别用 PHAsset 和 PHCollection 来表示相册和分组信息。 【2】、如果想要获取一个 video 中的任意时刻的 image，可以通过 AVAssetImageGenerator 来生成。有几个事项需要注意下： 1、确保这个视频的 AVAsset 中有视频轨数据，可以通过 [anAsset tracksWithMediaType:AVMediaTypeVideo] count] 是否大于 0 来判断。 2、当生成多张 image 时，generator 是一张一张异步生成的，我们需要对 generator 强引用，直到所有的 image 都创建完成。 如果想要对 video 编辑、截取等处理，可以通过 AVAssetExportSession 类来完成。底部有示例 demo 地址。 【3】、如果想要播放 video，根据播放源的不同，目前有两种视频播放方式，一种是基于文件（来源于本地资源）的，另一种是基于数据流（来源于互联网）的。 加载并播放一个本地视频可以简单概括为以下步骤： 1、用 AVURLAsset 创建一个 asset。 2、用 AVPlayerItem 创建一个以 asset 为参数的 playItem，然后添加状态的 KVO。 3、用 AVPlayer 创建一个以 palyItem 为参数的 player。 4、用 AVPlayerLayer 创建一个以 player 为参数的 playerLayer。 5、将 playerLayer 添加到当前视图的 layer 中，当 status 为 AVPlayerItemStatusReadyToPlay 时就可以播放了。 12// 添加状态观察[playerItem addObserver:self forKeyPath:@\"status\" options:0 context:&amp;ItemStatusContext]; 【4】、如果想要将播放点切到指定时间点，可以通过调用 player 的 seekToTime 来完成。 【5】、如果你想要在 video 播放结束的时候，重头开始播放。你可以对当前播放的 playItem 添加一个 name 为 AVPlayerItemDidPlayToEndTimeNotification 的 observer，这样在收到通知的时候将播放进度调整到 0 即可。 1[player seekToTime:kCMTimeZero]; 【6】、如果你想要获取当前播放的进度来刷新 UI 状态，你可以通过调用 player 的 addPeriodicTimeObserverForInterval:queue:usingBlock: 方法来实现， 在 block 回调中做你想做的事情。 【7】、想要播放多个 playItem 时，可以使用 AVQueuePlayer 来播放，调用 advanceToNextItem 来播放下一个资源。 【8】、如果想要对 video 编辑、截取等处理，可以通过 AVAssetExportSession 类来完成。底部有示例 demo 地址。 聊聊 Video 的编辑学习 video 编辑，我们要掌握一个概念 Composition, video 编辑的 API 都是基于 Composition 开展的。Composition 可以理解成一个 video 资源的集合。在这个集合中包含一个或多个 media assets。 一个 AVAsset 中通常包含一个音轨和视频轨。 用 AVMutableCompositionTrack 类来表示一个轨道。 AVMutableComposition 类可以用来组装、管理这些轨道，比如插入，删除等。 AVMutableAudioMix 类可以对 composition 中的音轨进行操作，比如设置音量、音阶等。 AVMutableVideoComposition 类可以对 composition 中的视频轨进行操作，比如设置输出视频的渲染尺寸、比例、帧率等。 AVMutableVideoCompositionInstruction 类可以修改视频的背景色、以及进行一些变换。 animationTool 可以将一些 Core Animation framework 的动画效果添加到视频中。 AVAssetExportSession 最终将这些音轨、视频轨、配置数据 合并成一个新的 video。 下图是一个简单的 export 示意图： 聊聊 Video 拼接举个 demo 中拼接两个 video 的例子，废话少说，直接上代码。 我们需要经历以下几个过程： 【1】生成 Composition 、音频轨、视频轨。 12345678// 创建可变集合对象 CompositionAVMutableComposition *mutableComposition = [AVMutableComposition composition];// 创建视频轨对象AVMutableCompositionTrack *videoCompositionTrack = [mutableComposition addMutableTrackWithMediaType:AVMediaTypeVideo preferredTrackID:kCMPersistentTrackID_Invalid];// 创建音频轨对象AVMutableCompositionTrack *audioCompositionTrack = [mutableComposition addMutableTrackWithMediaType:AVMediaTypeAudio preferredTrackID:kCMPersistentTrackID_Invalid]; 【2】添加 Asset 中的视频轨数据、音频轨数据。 123456789101112131415161718192021// 构建 视频1 视频2 的 assetNSDictionary *opts = [NSDictionary dictionaryWithObject:@(YES) forKey:AVURLAssetPreferPreciseDurationAndTimingKey];AVURLAsset *firstVideoAsset = [[AVURLAsset alloc] initWithURL:firstVideoPath options:opts];AVURLAsset *secondVideoAsset = [[AVURLAsset alloc] initWithURL:secondVideoPath options:opts];// 提取 视频1 视频2 的视频轨数据AVAssetTrack *firstVideoAssetTrack = [[firstVideoAsset tracksWithMediaType:AVMediaTypeVideo] objectAtIndex:0];AVAssetTrack *secondVideoAssetTrack = [[secondVideoAsset tracksWithMediaType:AVMediaTypeVideo] objectAtIndex:0];// 添加 视频1 视频2 的视频轨数据到 视频轨对象中[videoCompositionTrack insertTimeRange:CMTimeRangeMake(kCMTimeZero, firstVideoAssetTrack.timeRange.duration) ofTrack:firstVideoAssetTrack atTime:kCMTimeZero error:nil];[videoCompositionTrack insertTimeRange:CMTimeRangeMake(kCMTimeZero, secondVideoAssetTrack.timeRange.duration) ofTrack:secondVideoAssetTrack atTime:firstVideoAssetTrack.timeRange.duration error:nil];// 提取 视频1 视频2 的音频轨数据AVAssetTrack *firstVideoAudioTrack = [[firstVideoAsset tracksWithMediaType:AVMediaTypeAudio] firstObject];AVAssetTrack *secondVideoAudioTrack = [[secondVideoAsset tracksWithMediaType:AVMediaTypeAudio] firstObject]; // 添加 视频1 视频2 的音频轨数据到 音频轨对象中[audioCompositionTrack insertTimeRange:CMTimeRangeMake(kCMTimeZero, firstVideoAudioTrack.timeRange.duration) ofTrack:firstVideoAudioTrack atTime:kCMTimeZero error:nil];[audioCompositionTrack insertTimeRange:CMTimeRangeMake(kCMTimeZero, secondVideoAudioTrack.timeRange.duration) ofTrack:secondVideoAudioTrack atTime:firstVideoAssetTrack.timeRange.duration error:nil]; 【3】检查两个 video 的方向，方向不同的 video 不能拼接 1234567891011121314151617BOOL isFirstVideoPortrait = NO;CGAffineTransform firstTransform = firstVideoAssetTrack.preferredTransform;if (firstTransform.a == 0 &amp;&amp; firstTransform.d == 0 &amp;&amp; (firstTransform.b == 1.0 || firstTransform.b == -1.0) &amp;&amp; (firstTransform.c == 1.0 || firstTransform.c == -1.0)) &#123; isFirstVideoPortrait = YES;&#125; BOOL isSecondVideoPortrait = NO;CGAffineTransform secondTransform = secondVideoAssetTrack.preferredTransform;if (secondTransform.a == 0 &amp;&amp; secondTransform.d == 0 &amp;&amp; (secondTransform.b == 1.0 || secondTransform.b == -1.0) &amp;&amp; (secondTransform.c == 1.0 || secondTransform.c == -1.0)) &#123; isSecondVideoPortrait = YES;&#125; if ((isFirstVideoPortrait &amp;&amp; !isSecondVideoPortrait) || (!isFirstVideoPortrait &amp;&amp; isSecondVideoPortrait)) &#123; NSError *error = [self createNSErrorWithCode:400 errorReason:@\"视频方向不一致，无法拼接\"]; resultHandler(nil, error); return;&#125; 【4】添加视频处理命令 12345678910111213141516171819202122232425262728293031// 构建视频1 的操作命令AVMutableVideoCompositionInstruction *firstVideoCompositionInstruction = [AVMutableVideoCompositionInstruction videoCompositionInstruction];firstVideoCompositionInstruction.timeRange = CMTimeRangeMake(kCMTimeZero, firstVideoAssetTrack.timeRange.duration);AVMutableVideoCompositionLayerInstruction *firstVideoLayerInstruction = [AVMutableVideoCompositionLayerInstruction videoCompositionLayerInstructionWithAssetTrack:videoCompositionTrack]; // 微信拍摄的视频tx错位，需要修复CGRect firstRect = &#123;&#123;0, 0&#125;, naturalSizeFirst&#125;;CGRect firstTransformedRect = CGRectApplyAffineTransform(firstRect, firstTransform);firstTransform.tx -= firstTransformedRect.origin.x;firstTransform.ty -= firstTransformedRect.origin.y;[firstVideoLayerInstruction setTransform:firstTransform atTime:kCMTimeZero]; firstVideoCompositionInstruction.layerInstructions = @[firstVideoLayerInstruction]; // 构建视频2 的操作命令AVMutableVideoCompositionInstruction * secondVideoCompositionInstruction = [AVMutableVideoCompositionInstruction videoCompositionInstruction];secondVideoCompositionInstruction.timeRange = CMTimeRangeMake(firstVideoAssetTrack.timeRange.duration, CMTimeAdd(firstVideoAssetTrack.timeRange.duration, secondVideoAssetTrack.timeRange.duration));AVMutableVideoCompositionLayerInstruction *secondVideoLayerInstruction = [AVMutableVideoCompositionLayerInstruction videoCompositionLayerInstructionWithAssetTrack:videoCompositionTrack]; // 微信拍摄的视频tx错位，需要修复CGRect secondRect = &#123;&#123;0, 0&#125;, naturalSizeSecond&#125;;CGRect secondTransformedRect = CGRectApplyAffineTransform(secondRect, secondTransform);secondTransform.tx -= secondTransformedRect.origin.x;secondTransform.ty -= secondTransformedRect.origin.y; [secondVideoLayerInstruction setTransform:secondTransform atTime:firstVideoAssetTrack.timeRange.duration];secondVideoCompositionInstruction.layerInstructions = @[secondVideoLayerInstruction]; AVMutableVideoComposition *mutableVideoComposition = [AVMutableVideoComposition videoComposition];mutableVideoComposition.instructions = @[firstVideoCompositionInstruction, secondVideoCompositionInstruction]; 【5】添加渲染尺寸和帧率 12345float renderWidth = MAX(fixedSizeFirst.width, fixedSizeSecond.width);float renderHeight = MAX(fixedSizeFirst.height, fixedSizeSecond.height); mutableVideoComposition.renderSize = CGSizeMake(renderWidth, renderHeight);mutableVideoComposition.frameDuration = CMTimeMake(1,30); 【6】导出视频并保存到相册 12345678910111213141516AVAssetExportSession *exporter = [[AVAssetExportSession alloc] initWithAsset:mutableComposition presetName:AVAssetExportPresetHighestQuality];exporter.outputURL = videoURL;exporter.outputFileType = AVFileTypeMPEG4;exporter.shouldOptimizeForNetworkUse = YES;exporter.videoComposition = mutableVideoComposition; [exporter exportAsynchronouslyWithCompletionHandler:^&#123; dispatch_async(dispatch_get_main_queue(), ^&#123; if (exporter.status == AVAssetExportSessionStatusCompleted) &#123; resultHandler(exporter.outputURL, nil); &#125; else &#123; NSError *error = [self createNSErrorWithCode:200 errorReason:@\"视频导出失败\"]; resultHandler(nil, error); &#125; &#125;);&#125;]; 聊聊 Video 裁剪视频裁剪的 demo，这里就不聊了。感兴趣的可以自己下载底部 demo 研究。 参考资料 AVFoundation Programming Guide 示例代码 demo","tags":[]},{"title":"聊聊冒泡排序 （Bubble Sort）","date":"2019-06-19T14:22:53.000Z","path":"2019/06/19/talk-about-bubble-sort/","text":"版权声明：本文为 muhlenXi 原创文章，未经博主允许不得转载，如有问题，欢迎指正。 Foreword冒泡排序（Bubble Sort）的排序方法是在每一轮排序过程中，依次比较相邻元素的大小，如果顺序不满足排序的要求，则交换这两个元素。这样第一轮排序结束后，则值最大的元素放到最后。 一个 包含 n 个元素的数组在最坏的情况下，需要进行 n - 1 次排序过程，方能使数组中的元素变得有序。 算法分析整个算法由双层嵌套循环组成。 外面的循环控制冒泡的趟数，从 下标 0 开始跑趟，n 个元素总共需要 n - 1 趟。 内层循环控制单次冒泡过程。每趟中，从 下标 0 开始冒泡， 第 i 趟需要 n - 1 - i 次冒泡。 注意事项： 当数组中元素小于 2 时，则不需要排序。 当内层冒泡时，不再有元素交换时，则说明冒泡排序已经完成，此时应该跳出外层循环，终止排序。 算法实现1、用 Swift 实现的冒泡排序代码如下所示： 12345678910111213141516171819/// 冒泡排序 升序func bubbleSort(unsortedArray: inout [Int])&#123; guard unsortedArray.count &gt; 1 else&#123; return &#125; for i in 0 ..&lt; unsortedArray.count-1 &#123; var exchanged = false for j in 0 ..&lt; unsortedArray.count-1-i &#123; if unsortedArray[j] &gt; unsortedArray[j+1] &#123; unsortedArray.swapAt(j, j+1) exchanged = true &#125; &#125; if !exchanged &#123; break &#125; &#125;&#125; 2、用 Objective-C 实现的算法如下： 12345678910111213141516171819202122- (NSArray*) bubbleSort: (NSArray *) unsortedArray &#123; if (unsortedArray.count &lt;= 1) &#123; return unsortedArray; &#125; NSMutableArray *sortedArray = [unsortedArray mutableCopy]; for (int i = 0; i &lt; sortedArray.count-1; i++) &#123; BOOL exchanged = NO; for (int j = 0; j&lt; sortedArray.count-1-i; j++) &#123; if ([sortedArray[j] integerValue] &gt; [sortedArray[j+1] integerValue]) &#123; [sortedArray exchangeObjectAtIndex:j withObjectAtIndex:j+1]; exchanged = YES; &#125; &#125; if (!exchanged) &#123; break; &#125; &#125; return [sortedArray copy];&#125; 3、用 Java 实现的算法如下： 123456789101112131415161718192021222324static int[] bubbleSort(int[] array) &#123; if(array.length &lt; 2) &#123; return array; &#125; int[] result = array; for(int i = 0; i &lt; result.length-1; i++) &#123; boolean changed = false; for(int j = 0; j &lt; result.length-1-i; j++) &#123; if(result[j] &gt; result[j+1]) &#123; int temp = result[j]; result[j] = result[j+1]; result[j+1] = temp; changed = true; &#125; &#125; if(changed == false) &#123; break; &#125; &#125; return result;&#125; 验证算法1234567var list = [2, 3, 5, 7, 4, 8, 6 ,10 ,1, 9]// 将会打印 [2, 3, 5, 7, 4, 8, 6 ,10 ,1, 9]print(list) // 进行冒泡排序bubbleSort(unsortedArray: &amp;list)// 将会打印 [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]print(list) 算法总结稳定性 ：是稳定算法，因为排序过程中相邻会依次比较，不会打乱相同元素的相对位置。 空间复杂度：整个排序过程是在原数组上进行排序的，所以是 O(1)。 时间复杂度：排序算法包含双层嵌套循环，故为 O(n^2)。 参考资料 1、Backup &amp; Demo","tags":[]},{"title":"好代码是怎样练成的","date":"2019-05-12T07:08:42.000Z","path":"2019/05/12/how-to-write-code-well/","text":"版权声明：本文为 muhlenXi 原创文章，欢迎转载，转载请注明来源。 前言： 你的技术背景来源于对计算机科学的基本原理的理解，经验来自广泛的实际项目。理论与实践的结合将使你强大起来。 在几年的编程生涯中，编写了不少的代码，也阅读了一些别人的代码，从中发现，一份好的、优雅的代码，都包含如下的特征。 一份好代码有哪些特征？ 1、逻辑清晰，模块划分合理 2、可读性高 3、健壮性高 4、灵活，易扩展和易迁移 参考指南那么，怎样才能写出符合这些特征的代码呢？以下是一些建议和方法，希望能给你带来启发。 逻辑清晰，模块划分合理： 避免写太长的函数，控制在 40 行之内。 制造一些小的工具函数。 每个函数只做一个简单的事情。 避免使用全局变量和类成员来传递信息。 少用自增表达式。 永远不要省略花括号。 合理使用括号，不要盲目依赖操作符的优先级。 提防破窗理论，遇到糟糕的代码及时修正。 避免编写相似的函数。 可读性： 使用有意义的函数和变量名字。 局部变量声明靠近使用它的地方。 局部变量名字简短。 不要重用局部变量。 复杂的逻辑提取出去，做成帮助函数。 复杂表达式提取出去，做成中间变量。 合理的地方进行换行。 选择更加直接，更加清晰的代码。 健壮性： 注意边界值的判断 穷举所有情况，不漏掉任何一种情况。 不要提前预设立场。 灵活： 先写出可用的代码，反复推敲，思考是否进行重用。 先写出可用、简单、没有 bug 的代码，再考虑测试的问题。 熟悉代码设计原则，编码的时候注意遵循这些原则。 熟悉设计模式，然后合理的使用模式。 后记能不能让正确的原则指导正确的行动，其实就是区分是否是高手的一个显著标志。 本篇博文，随着作者的编程经验增加会不定时更新，敬请关注。如果你有更好的建议，欢迎留言交流。","tags":[]},{"title":"永远不要靠巧合编程","date":"2018-11-30T05:37:29.000Z","path":"2018/11/30/Do-not-Program-by-Coincidence/","text":"版权声明：本文为 muhlenXi 原创文章，欢迎转载，转载请注明来源。 前言： 作为一个软件开发者，我们犹如奔赴雷区的士兵。每天有成百的地雷等着我们去趟。那么怎样才能避开地雷，不被 bug 折磨呢？ 避雷的关键技术之一就是不要靠巧合编程，而是要深思熟虑地编程。 趟雷原因为什么不能靠运气和偶然的成功来编程呢，请容我慢慢道来。 在心理学上有一个著名的心理学定律 - 『墨菲定律』。该定律表明，如果一件事情有变坏的可能，不管这种可能性多小，它总会发生。这种现象在编程领域也普遍存在，该发生的 bug 还是会发生，不管你见或者不见。 靠巧合编程，虽然代码能够运行出你想要的结果，但是你不知道为什么会运行成功。所以，当出问题的时候，你自然不知道原因所在，自然会花上大量时间检查调试， 费心又费力。 靠巧合编程，会让你陷入无尽的 bug 深渊，随着业务和代码量的增加，系统会变得更加复杂，导致某个 bug 的原因往往不是特定的。如果你没有良好的思路，无尽的调试会严重消耗你的精力和耐心，直到人生崩溃。 避雷方法那怎样才能不靠巧合编程呢，有以下几点建议可以参考借鉴，如果你能做到这些建议，那么你在编程的路上将会少很多绊脚石和折磨。 保持模块解耦，封装合理。 编写给别人调用的代码，比如公共基础组件的开发，要有良好的模块化，并把实现隐藏在良好的接口之后。 尽可能少制造人为错误。如果我们想要让编写代码和调试 bug 的时间减少。就要尽可能在开发周期的早期抓住并修正错误，在一开始就要尽可能少的制造错误。 动手编码前要理清思路。思路不清楚的情况，此时往往在本子上画画图，写写流程，往往会起到意想不到的效果。毕竟磨刀不误砍柴工，遇到复杂问题时，要勇敢的亮出三把刀，画图、举例和分解。 编码中总是意识到你在做什么。写代码的时候，要意识到每行代码的作用。对于你概念模糊的代码一定要搞懂，不能不清不楚的就敲上去。虽然提倡要多 Google 不重复造轮子，但是粘贴代码的前提是你要彻底搞懂才行。 依靠可靠的前提和边界条件，对可能出现的错误提前预防。不要去猜测，要用程序去验证。计算机是不会骗你的，对于情况不清的情景，一律做最坏打算，在代码中恰当的使用断言可以提前规避可能发生的错误。 提前想好自测用例。可以从规范性、完整性 和 鲁棒性三个方面去考虑和扩展。规范性意味着你的代码要命名达意、布局清晰。完整性意味着自测用例要覆盖功能测试、边界测试和负面测试。鲁棒性也就是健壮性，意味着你的代码能够判断输入是否规范，并能够对不合理的输入进行恰当处理。 保持谦虚的态度。多和编程经验比你丰富的同事交流，三人行，必有我师。没事多听听它们的想法和建议，你会有意想不到的收获的。如果你的同事技术很牛，但是沉默寡言，那就多看看它们的代码，然后想想，如果该业务功能由你来做，你会如何实现。 后记最后分享我最喜欢的一句话与大家共勉： 编程是一种技艺，一种用心去学习的技艺。","tags":[]},{"title":"如何准确计算 UILabel or UITextView 的高度？","date":"2018-08-17T23:55:53.000Z","path":"2018/08/18/calculate/","text":"版权声明：本文为 muhlenXi 原创文章，欢迎转载，转载请注明来源。 在 项目中有时会需要根据文本内容来动态改变控件的高度约束，常用的一般有 UILabel 和 UITextView，那如何准确根据文本内容计算该控件的高度呢？ 如何精确计算 UITextView 的高度想要根据 String 来精确的计算 UITextView 的高度的前提是准确的确认 UITextView 中文本内容实际显示的宽度。那么就要从 UITextView 的视图结构入手，通过查阅 Apple 的官方文档得知，UITextView 中的 text 是存放在一个名为 textContainer 的容器中，通过 textContainerInset 属性可以得到该容器与 UITextView 的内边距，除此之外，还有一个属性影响内容显示的宽度，那就是容器的 lineFragmentPadding 属性，该属性用来控制文字的实际显示区域与容器左右两边的边距。 综上，UITextView 的文本内容实际显示区域宽度为： 1let textContentWidth = textViewWidth-leadingOffset-trailingOffset-lineFragmentPading*2 所以，我们可以通过以下方法精确计算 UITextView 的宽度： 123456789101112131415161718extension String &#123; /// 根据字符串 获取 TextView 字符串的高度 func getTextViewStringHeightFrom(textViewWidth: CGFloat, font: UIFont, textView: UITextView) -&gt; CGFloat &#123; let lineFragmentPading = textView.textContainer.lineFragmentPadding let textContainerInset = textView.textContainerInset let topOffset = textContainerInset.top let bottomOffset = textContainerInset.bottom let leadingOffset = textContainerInset.left let trailingOffset = textContainerInset.right let textContentWidth = textViewWidth-leadingOffset-trailingOffset-lineFragmentPading*2 let normalText: NSString = self as NSString let size = CGSize(width: textContentWidth, height: 1000) let attributes = [NSAttributedStringKey.font: font] let stringSize = normalText.boundingRect(with: size, options: .usesLineFragmentOrigin, attributes: attributes, context:nil).size return CGFloat(ceilf(Float(stringSize.height)))+topOffset+bottomOffset &#125;&#125; 如何精确计算 UILabel 的高度由于 Label 的实际文本显示的宽度和 UILabel 控件显示的宽度是一致的。因此，我们很方便的通过下面的代码就能算出 UILabel 的高度了。 12345678910111213extension String &#123; /// 根据字符串 获取 Label 控件的高度 func getLabelStringHeightFrom(labelWidth: CGFloat, font: UIFont) -&gt; CGFloat &#123; let topOffset = CGFloat(0) let bottomOffset = CGFloat(0) let textContentWidth = labelWidth let normalText: NSString = self as NSString let size = CGSize(width: textContentWidth, height: 1000) let attributes = [NSAttributedStringKey.font: font] let stringSize = normalText.boundingRect(with: size, options: .usesLineFragmentOrigin, attributes: attributes, context:nil).size return CGFloat(ceilf(Float(stringSize.height)))+topOffset+bottomOffset &#125;&#125; 本文完整 demo ExploreUILabelUITextView 在这里，有需要的可自行下载。 如果有不对的地方欢迎指正！谢谢！","tags":[]},{"title":"Vim 使用小记","date":"2018-08-14T13:20:38.000Z","path":"2018/08/14/vim/","text":"版权声明：本文为 muhlenXi 原创文章，欢迎转载，转载请注明来源。 Vim 是什么 Vim 是从 vi 发展出来的一个文本编辑器。 Vim 是从 vi 发展出来的一个文本编辑器。它有许多强大的功能，如代码补全、编译及错误跳转等，在程序员中被广泛使用。和 Emacs 并列成为 类Unix系统 用户最喜欢的编辑器。关于 Vim 的更多详情请查阅 Vim wiki。 Vim 的简单实用可以终端使用 vimtutor 命令打开完整教程。 1 - 光标移动光标在屏幕文本中的移动既可以用箭头键，也可以使用 h j k l 字母键。 按 e 命令可以使光标移动到单词末尾。 按 数字 0 可以移动光标到行首。 h (左移) j (下移) k (上移) l (右移) 2 - 进入/退出 Vim 编辑器 终端进入 Vim 编辑器，请输入：vim 文件名 &lt;回车&gt; 退出 Vim 编辑器，请按 esc ，然后输入以下命令之一： :q! &lt;回车&gt; 放弃所有改动。 :wq &lt;回车&gt; 保存改动。 3 - 删除文本 在正常模式下删除光标所在位置的字符，请按： x 欲从当前光标删除至下一个单词，请输入：dw 欲从当前光标删除至当前行末尾，请输入：d$ 欲删除整行，请输入：dd 4 - 插入文本 输入小写的 i 可以在光标前插入文本 输入小写的 o 可以在光标下方打开新的一行并进入插入模式。输入大写的 O 可以在光标上方打开新的一行。 输入小写的 a 可以在光标所在位置之后插入文本。输入大写的 A 可以在光标所在行的行末之后插入文本。 特别提示：按下 esc 会带您回到正常模式或者撤消一个不想输入或部分完整的命令。 5 - 撤销操作 撤消以前的操作，请输入：u (小写)。 撤消在一行中所做的改动，请输入：U (大写)。 撤消以前的撤消命令，恢复以前的操作结果，请输入：CTRL-R 6 - 更改文本 操作符 y 复制文本，p 粘贴先前复制的文本。 粘贴已经删除的文本内容，请按小写字母 p 。该操作可以将已删除的文本内容置于光标之后。如果最后一次删除的是一个整行，那么该行将粘贴到当前光标所在行的下一行。 要替换光标所在位置的字符，请输入小写的 r 和要替换掉原位置字符的新字符即可。 输入大写的 R 将进入替换模式，直至按 esc 键回到正常模式。 输入 ce 可以替换当前光标到单词的末尾的内容； 输入 c$ 可以替换当前光标到行末的内容。 在一行内替换头一个字符串 old 为新的字符串 new，请输入 :s/old/new 在一行内替换所有的字符串 old 为新的字符串 new，请输入 :s/old/new/g 在两行内替换所有的字符串 old 为新的字符串 new，请输入 :#,#s/old/new/g 在文件内替换所有的字符串 old 为新的字符串 new，请输入 :%s/old/new/g 进行全文替换时询问用户确认每个替换需添加 c 标志，请输入 :%s/old/new/gc 7 - 文本搜索 输入 / 然后紧随一个字符串是在当前所编辑的文档中正向查找该字符串。 输入 ? 然后紧随一个字符串则是在当前所编辑的文档中反向查找该字符串。 完成一次查找后按 n 键是重复上一次的命令，可在同一方向上查找下一个匹配字符串；或者按大写 N 向相反方向查找下一匹配字符串所在。 CTRL-O 带您跳转回较旧的位置，CTRL-I 则带您到较新的位置。 输入 :set xxx 可以设置 xxx 选项。一些有用的选项如下： ‘ic’ ‘ignorecase’ 查找时忽略字母大小写‘is’ ‘incsearch’ 查找短语时显示部分匹配‘hls’ ‘hlsearch’ 高亮显示所有的匹配短语 在选项前加上 no 可以关闭选项： 如 :set noic 8 - 光标全文跳转CTRL-G 用于显示当前光标所在位置和文件状态信息。 G 将光标跳转至文件最后一行。 gg 用于将光标跳转至文件第一行。 跳转到指定行，先输入行号然后输入 G 则是将光标移动至该行号代表的行。 9 - 保存文本:!command 用于执行一个外部命令 command。 :!ls 用于显示当前目录的内容。 :!rm filename 用于删除名为 filename 的文件。 :w filename 将当前 VIM 中正在编辑的文件保存到名为 filename 的文件中。 v motion :w filename 可将当前编辑文件中可视模式下选中的内容保存到文件filename 中。 :r filename 可提取磁盘文件 filename 并将其插入到当前文件的光标位置后面。 :r !dir 可以读取 dir 命令的输出并将其放置到当前文件的光标位置后面。 10 - 其他操作 重复一个动作，请在它前面加上一个数字：2w 如果光标当前位置是括号 (、)、[、]、{、}，按 % 会将光标移动到配对的括号上。 11 - 获取帮助 输入 :help 可以打开帮助窗口。 输入 :help cmd 可以找到关于 cmd 命令的帮助。 输入 :q 以关闭帮助窗口 您可以创建一个 vimrc 启动脚本文件用来保存您偏好的设置。 当输入 : 命令时，按 CTRL-D 可以查看可能的补全结果。按 Tab 可以使用一个补全。 后记与君共勉：编程是一种技艺，一种需要用心学习的技艺！","tags":[{"name":"Tool","slug":"Tool","permalink":"http://yoursite.com/tags/Tool/"}]},{"title":"objc 与 objcMembers 的区别是什么？","date":"2018-08-08T10:08:37.000Z","path":"2018/08/08/objcmembers/","text":"版权声明：本文为 muhlenXi 原创文章，欢迎转载，转载请注明来源。 在 Swift 与 Objective-C 混编的项目中一般会用到 @objc 和 @objcMembers 这两个关键字。那它们有什么不同呢？ 1 - Objective-C 访问 Swift在 Swift4 中，如果我们想要在 Objective-C 中访问 Swift 文件中声明的属性和方法，我们声明的类只需要继承 NSObject 基类 即可。这种情况下，在 Objective-C 中无法访问该类的属性和调用该类的方法，也就是说在编译成生成的 项目名-Swift.h 文件中找不到该类的桥接属性和方法，自然你也无法使用。 如果你只想暴露个别的属性和方法给 Objective-C 访问和调用，你只需要在要暴露的属性和方法前添加 @objc 关键字即可。 举例如下： 12345678910111213class Person: NSObject&#123; /// 只暴露性别属性 @objc var sex: Int = 0 var name = \"anoymous\" func sayhello() &#123; print(\"I like \\(sex)\") &#125; @objc func sayByebye() &#123; print(\"Good bye\") &#125;&#125; 我们看一下生成的 Objective-C 桥接文件： 1234567SWIFT_CLASS(\"_TtC11ExAttribute6Person\")@interface Person : NSObject/// 只暴露性别属性@property (nonatomic) NSInteger sex;- (void)sayByebye;- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;@end 如果你想暴露该类的全部方法和属性给 Objective-C 访问和调用，你则需要在声明类的时候添加 @objcMembers 关键字即可。 举例如下： 12345678@objcMembers class Boy: NSObject &#123; var name: String = \"\" var age = 0 func sayHello() &#123; print(\"Hello, I am \\(name). I am \\(age) yearsold.\") &#125;&#125; 同样我们也看一下生成的 Objective-C 桥接文件： 1234567SWIFT_CLASS(\"_TtC11ExAttribute3Boy\")@interface Boy : NSObject@property (nonatomic, copy) NSString * _Nonnull name;@property (nonatomic) NSInteger age;- (void)sayHello;- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;@end 通过以上示例，我们可以得出结论，@objc 与 @objcMembers 的关键区别在于暴露给 Objective-C 的属性、方法的范围。如果我们想要保护业务实现的细节，就需要合理的使用 @objc 与 @objcMembers 关键字。 2 - Swift 访问 Objective-C如果我们想要访问 Objective-C 文件中声明的类、属性和方法，我们只需要在 项目名-Bridging-Header.h 桥接头文件中导入我们想访问的类即可。 举例如下： 1#import \"OCViewController.h\" 如需要本文完整示例 demo，请访问 ExploreAttribute。 后记写代码和做学问类似，要时刻保持严谨的态度。对于关键的知识点一定要理解透彻，不能懵懵懂懂，这样写出的代码才会可靠。 编码寄语：编程是一种技艺，一种需要用心学习的技艺！","tags":[]},{"title":"Swift-Array","date":"2018-07-23T07:44:49.000Z","path":"2018/07/23/Swift-Array/","text":"Array 一种有序、随机访问的集合。 Array 是 app 开发中经常使用的数据类型。一般用 array 来组织 app 中的数据，比如保存多个相同类型。一个 array 可以存储任何类型的元素，从整型到字符串再到类。 创建 Array在 Swift 中创建 array 的方式比较简单，一般通过方括号包含用逗号分隔的多个元素，Swift 可以自动推断 array 中的元素类型。如： 12345// 一个包含 Int 类型的数组let oddNumbers = [1, 3, 5, 7, 9, 11, 13, 15]// 一个包含 String 类型的数组let fruits = [\"apple\", \"banana\", \"grape\"] 也可以通过显示指定元素类型来创建空数组，如： 123var emptyDoubles: [Double] = []var emptyFloats: Array&lt;Float&gt; = Array() 如果需要为数组指定默认值，可以通过 Array(repeating:count:) 方法来创建，如： 1var zeros = Array(repeatElement(0, count: 10)) 访问 Array 的元素1、可以通过 for-in 循环来访问数组中的元素。 2、可以直接通过下标来访问数组的元素。第一个元素的下标永远是 0 ，一个包含 n 个元素的数组，它的元素的下标以为为 0 ~ n-1。 123456for fruit in fruits &#123; print(\"I like eat \\(fruit).\")&#125;fruits[0]fruits[1] 用 isEmpty 来判断一个数组是否为空 用 count 获取数组包含的元素的个数 用 first 和 last 获取数组的第一个和最后一个元素 增加和删除元素 通过 append(_:) 追加单个元素到数组末尾 通过 append(contentsOf:) 追加多个（其他数组中的）元素到数组末尾 通过 insert(_:at:) 方法插入单个元素到数组指定位置 通过 insert(contentsOf:at:) 方法插入多个元素（其他数组的）到数组末尾 通过 remove(at:) 方法删除指定位置的元素 通过 removeLast() 方法删除数组末尾元素 通过 removeSubrange(_:) 方法删除数组指定区间的元素 1234567891011121314var charates: [String] = []charates.append(\"A\")charates.append(contentsOf: [\"B\", \"C\"])charates.insert(\"D\", at: 0)charates.insert(contentsOf: [\"E\", \"F\"], at: 1)charates.remove(at: 0)charates.removeFirst()charates.removeLast()let range = 0 ... 1charates.removeSubrange(range) 也可以通过下标来修改数组中的元素。如： 123if let index = charates.index(of: \"B\") &#123; charates[index] = \"BBB\"&#125; 增加数组的大小每个数组都持有特定大小的内存来保存内容。当你往数组中添加元素并超过他的预留容量时，数组会分配更大的内存区域，然后拷贝其中的元素到新区域。新存储一般是旧存储的几倍。这种指数增长策略的意义在于添加元素时会恒定时间重新分配内存，从而平均了许多添加操作的性能。添加操作触发重新分配内存会消耗性能，但是在数组变大的过程中，重新分配内存的操作不是很频繁的。 如果你知道要存储的元素个数，可以通过 reserveCapacity(_:) 方法在添加元素之前指定容量大小从而避免重新分配内存的情况。使用 capacity 和 count 属性来确定 array 能存储的元素数量而不是分配更大的内存空间。 对于元素类型是常见类型的数组，该存储是连续的内存块。如果元素类型是 类 或 遵循 @objc 协议的对象，该存储可能是连续的内存块。因为任何 NSArray 的子类都能变成 Array，所以在这种情况下无法表示和保证效率。 Array 拷贝元素的修改每个数组都有一个包含元素值的独立值。对于简单类型比如 interger 和其他 struct，这意味着当你改变 array 中一个值时，该 array 副本中的值不会发生改变。如： 12345var numbers = [1, 2, 3, 4, 5]var numbersCopy = numbersnumbers[0] = 100print(numbers)print(numbersCopy) 如果数组中的元素是类的实例时，则语义是相同的，尽管最初可能看起来不同。在这种情况下，array 中存储的值是对象的引用地址。如果你改变一个数组中对象的引用地址，只有该数组才有新对象的引用地址。如果两个数组中都包含同一个对象的引用地址，你能在两个数组中都看到对象属性的变化。如： 1234567891011121314class IntegerReference &#123; var value = 10&#125;var firstIntegers = [IntegerReference(), IntegerReference()]var secondIntegers = firstIntegersfirstIntegers[0].value = 100print(secondIntegers[0].value)// print 100firstIntegers[0] = IntegerReference()print(firstIntegers[0].value)// print 10print(secondIntegers[0].value)// print 100 Array 像 Swift 标准库中能改变大小的集合一样，采用 copy-on-write 机制。array 的拷贝和 array 共享相同的存储空间，直到你改变其中的一个数组。","tags":[]},{"title":"Swift 数据结构之 Set","date":"2018-07-23T07:20:38.000Z","path":"2018/07/23/Swift-Set/","text":"版权声明：本文为 muhlenXi 原创文章，欢迎转载，转载请注明来源。 基本概念 Set 是包含唯一元素的无序集合。 使用场景： 不考虑集合中元素排列顺序 确保集合中的元素是唯一的 集合运算 Set 的基础操作你可以创建包含任意元素的 Set，只要该元素遵循 Hashable 协议。Swift 标准库中的元素默认的都遵循 Hashable 协议，包括 String，数值类型，Bool ，无关联类型的枚举，以及 Set 本身。 可以通过类似创建 Array 的方式创建 Set 可以通过 contains 判断 Set 是否包含指定元素 可以通过 == 判断两个 Set 是否相等 可以通过 isSubset 判断一个 Set 是否是另一个 Set 的子集 可以通过 isStrictSuperset 判断一个 Set 是否是另一个 Set 的严格子集 可以通过 isSuperset 判断一个 Set 是否是另一个 Set 的超集 可以通过 isStrictSuperset 判断一个 Set 是否是另一个 Set 的严格超集 可以通过 isDisjoint 判断两个 Set 是非相交的（即是否不包含相同元素） 以下是示例代码，自己动手在 playground 中敲一遍会印象深刻的，编程之路没有捷径。 123456789101112131415161718192021let fruits: Set = [\"apple\", \"banana\", \"grape\"]let fruits1: Set = [\"grape\", \"banana\"]let fruits2: Set = [\"watermelon\"]fruits.contains(\"apple\")fruits.contains(\"mango\")fruits == fruits1fruits1.isSubset(of: fruits)fruits.isSuperset(of: fruits1)fruits1.isStrictSubset(of: fruits1)fruits1.isSubset(of: fruits1)fruits1.isStrictSuperset(of: fruits1)fruits1.isSuperset(of: fruits1)fruits.isDisjoint(with: fruits1)fruits.isDisjoint(with: fruits2) Set 与 Set 之间的操作 可以通过 union 获取两个 Set 的并集 可以通过 intersection 获取两个 Set 的交集 可以通过 subtracting 获取两个 Set 的差集 可以通过 symmetricDifference 获取两个 Set 的对称差集( 并集 - 交集) 示例如下： 123456789let fruits3 = fruits1.union(fruits2)let intersection = fruits3.intersection(fruits2)let fruits4: Set = [\"apple\", \"banana\"]let fruits5: Set = [\"banana\", \"watermelon\"]let fruits6 = fruits4.symmetricDifference(fruits5)let fruits7 = fruits3.subtracting(fruits1)let fruits8 = fruits4.subtracting(fruits5) Set 的集合操作 对于集合的操作， Set 也有。 通过 isEmpty 判断 Set 是否为空 通过 for-in 循环遍历 Set 中的元素 执行 map 、 reduce、 filter 等操作。 Set 和 NSSet 的转换 通过 as 操作符可以在 Set 和 NSSet 之间转换，需满足如下条件： Set 中的元素类型是 Foundation 类型。 Set 中的元素是遵循 @objc 协议的类型。 从 Set 转换成 NSSet 的时间复杂度是 o(1)。当 Set 中的元素类型不是遵循 @objc 协议的类型时，在首次访问其中每个元素的时候会进行转换。所以对 Set 的操作的时间复杂度是 o(n)。 从 NSSet 转换 Set 时，会首先调用 copy(with:) 方法获取一份不可变拷贝，然后执行时间复杂度为 o(1) 的 Swift bookkeeping 操作。NSSet 的实例一直是不可变的， copy(with:) 方法会返回相同实例。NSSet 和 Set 的实例都使用 copy-on-write 机制，也就是说两个 Set 是共享存储的。 后记 本文的 demo 在这里，下载后运行可体验本文所描述的效果。*关于 Set 的更多详细信息请访问 Set 。 哇，读到这里了，真棒！每天进步一点点！为你的专注点赞！我们下篇见","tags":[]},{"title":"关于 App 中的启动广告页","date":"2018-07-01T13:23:56.000Z","path":"2018/07/01/Advertisement/","text":"版权声明：本文为 muhlenXi 原创文章，欢迎转载，转载请注明来源。 导语： 当我们在手机上单击一些主流 App 的 Icon 时，首先映入眼帘的是加载页，加载页也奠定了一个 App 的主题风格，稍后会淡入一个广告页，然后停留几秒，最后淡出，这是怎么做到的呢？ 实现思路其实要实现这样的效果，思路也不难，大体如下： 1、在 App 加载完成的时候，在界面的最上面覆盖一个自定义 View，该 view 中的图片显示为加载页的图片。 2、同时开启一个 n 秒的定时器和子线程，在子线程中去获取后台服务器或者本地的数据，获取到广告数据后，停止第一个定时器，再开一个跳过按钮的倒计时定时器，然后用数据填充刷新 View。 3、移除该 view，进入主页面的操作主要分为以下三种情况： 第一个定时器倒计时完成终止。 因为网络 API 或读本地数据出现错误时。 当用户点击跳过按钮或者点击广告页时。 关键点关键点如下： 1、广告 View 的实现，该 View 中有两个 ImageView，其中 ImageView1 用来显示启动页的图片，ImageView2 用来展示广告页，当获取到广告图片后，填充 ImageView2后，然后做一个动画，动画执行的动作为 Imageview1 的 alpha 从 1 -&gt; 0 , ImageView2 的 alpha 从 0 -&gt; 1, 跳过按钮的 alpha 从 0 -&gt; 1。这样的用户体验会更佳。 2、移除广告View 不能太突兀，应该做一个 Transition 动画。 完整的 demo 在这里，下载后运行可体验本文所描述的效果。 哇，读到这里了，真棒！每天进步一点点！为你的专注点赞！我们下篇见。 如果你还有更好的思路，欢迎留言一起探讨。","tags":[]},{"title":"如何判断对象相同？","date":"2018-05-06T02:25:30.000Z","path":"2018/05/06/Equal-Object/","text":"版权声明：本文为 muhlenXi 原创文章，欢迎转载，转载请注明来源。 导语： 在编程中，如果两个对象中的所有属性分别相等，则我们可以认为这两个对象是同一个对象。那么在 Swift 和 Objective-C 中，是怎样的情况呢？ 在 Swift 中对于一个自定义的类（如 People 类），如果要判断两个对象相同，需要 遵循 Equatable 协议，并实现 public static func ==(lhs: People, rhs: People) -&gt; Bool方法, 示例代码如下: 12345678910111213141516/// 没有父类class People &#123; var name: String var ID: Int init(name: String, id: Int) &#123; self.name = name self.ID = id &#125;&#125;extension People: Equatable &#123; public static func ==(lhs: People, rhs: People) -&gt; Bool &#123; return lhs.ID == rhs.ID &amp;&amp; lhs.name == rhs.name &#125;&#125; 当我们需要判断两个对象的时候，只需要需要用到 == 操作符即可。 注意：当 People 类继承自 NSObject 类时，由于 NSObject 类已经遵循 Equatable 协议，我们只需实现协议方法就可以了。许多人在这里就实现如上所示的协议方法了。其实这样是行不通的！（当然你也可以尝试，实践出真知。）正确的做法是覆写 override func isEqual(_ object: Any?) -&gt; Bool 方法。示例代码如下: 12345678910111213141516/// 父类是 NSObjectclass Person: NSObject &#123; var name: String var ID: Int init(name: String, id: Int) &#123; self.name = name self.ID = id &#125; /// 父类 NSObject 已经遵循 Equatable 协议，在这里要实现如下方法： override func isEqual(_ object: Any?) -&gt; Bool &#123; let person = object as! Person return self.name == person.name &amp;&amp; self.ID == person.ID &#125;&#125; 在上述中的两种情况下，当我们判断一个班级名单中是否有这个人时，就可以用 contains 方法来判断了。 完整 Demo 哇，读到这里了，真棒！每天进步一点点！为你的专注点赞！我们下篇见。","tags":[]},{"title":"如何分享 Python 代码到 PyPI 社区","date":"2017-11-06T14:58:15.000Z","path":"2017/11/06/Python-shared/","text":"版权声明：本文为 muhlenXi 原创文章，欢迎转载，转载请注明来源。 导语： Python 是一个高级、通用、强大的开源编程语言，然而 Python 的流行和强大离不开开源社区的代码共享，所以，我们应该积极向 Python 社区开放你的代码 … 共享总是一件好事，不是吗？本文将教你如何向 PyPI 社区共享代码。 经过以下的 7 个步骤，即可成功的向 PyPI 社区提交代码模块。 准备发布为了共享代码模块，需要准备一个发布（distribution），也就是一个允许你构建、打包、发布模块的一个文件集合。 1、首先为模块创建一个文件夹。复制 python 代码文件到该文件夹中。 2、在该文件夹中创建一个名为 setup.py 的文件，打开，并增加如下代码： 123456789101112from distutils.core import setup # 从 Python 发布工具导入 setup 函数setup( name=\"mlx_nester\", # 模块名 version=\"1.3.0\", # 模块版本号 py_modules=['mlx_nester'], # 关联模块的元数据 author=\"muhlenXi\", # 作者 author_email=\"muhlenxi@gmail.com\", # 作者邮箱 url=\"http://www.muhlenxi.com\", # 作者的主页 description=\"A simple printer of nested lists\", # 模块的简单功能描述) 构建发布3、打开 终端 ，cd 到新建的文件夹目录下，输入如下命令： 1python3 setup.py sdist 4、将发布安装到你的 Python 本地副本中，继续输入以下命令： 1sudo python3 setup.py install 注：该过程需要输入电脑密码。 发布预览5、使用 Python 关键字 import 导入已经安装的模块，然后测试模块代码能否正常运行，如果没问题的话，执行第六步。 向 PyPI 上传代码如果第一次上传代码的话，需要先注册一个 PyPI 社区的账号，注册流程如下： 1、 浏览器中输入 https://pypi.python.org/pypi 打开 PyPI 网站。 2、点击最右侧的 Register 按钮，然后在界面上一次输入用户名、密码、确认密码、Email，然后勾选 I agree，最后点击 register 选项，PyPI 会向你邮箱发一份确认邮件。 3、打开邮箱中的 PyPI 邮件，点击确认链接来完成 PyPI 注册就可以了。 6、给上传工具配置你的 PyPI 的账户名和密码。（本步骤只需操作一次） 打开 终端,cd 到新建的文件夹目录下，输入如下命令： 1python3 setup.py register 运行后，输入 1 ,然后依次输入 用户名 和 密码。 正常情况下会返回 Server response (200): OK 等信息。 如果返回来的信息是： 1urlopen error [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:748) 此时在终端输入： /Applications/Python\\ 3.6/Install\\ Certificates.command 执行后，再次执行步骤6，直到返回 OK 为止。 7、上传模块到 PyPI。 打开 终端,cd 到新建的文件夹目录下，输入如下命令： 1python3 setup.py sdist upload 如果上传成功的话，会返回 Server response (200): OK 等信息。","tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"PyPI","slug":"PyPI","permalink":"http://yoursite.com/tags/PyPI/"}]},{"title":"iOS 多线程详细总结","date":"2017-08-22T06:21:46.000Z","path":"2017/08/22/multithreading/","text":"本文是 muhlenXi 原创文章，欢迎转载，转载请注明出处。 Overview 本文主要是关于 iOS 多线程开发中的知识总结，以及在实际项目中的用法和注意事项。 Stay Hungry, Stay Foolish. iOS 多线程通过本文，你可以学到以下知识： 1、进程、线程 是什么？ 2、多线程实现原理 3、多线程在 iOS 开发中的优缺点 4、多线程实现技术方案一 – pThread 5、多线程实现技术方案二 – NSThread 6、多线程实现技术方案三 – GCD 7、多线程实现技术方案四 – NSOperation 8、线程池的相关知识 本文中使用的 Demo 已经传到 GitHub 上了，有需要的话，可以 Star 进行收藏。 传送门 下图所示是本文 demo 以及简介： 如图： 蓝色区域是 pThread 相关概念的实践。 橙色区域是 NSThread 相关概念的实践。 绿色区域是 Grand Central Dispatch 相关概念的实践。 红色区域是 NSOperation 相关概念的实践。 项目中用到多线程的场景 网络请求 图片加载 文件处理 数据存储 其他任务的执行 任务执行方式 串行，多个任务顺序执行。 并行，多个任务并发执行，也就是同时执行。 进程是什么？进程 指的就是系统中正在运行的一个应用程序，它有新建、就绪、运行、阻塞和终止五种状态。 线程是什么？线程 是进程中的基本执行单元，进程中的所有任务都是在线程中执行的。 多线程实现原理？采用的是 时间片轮转调度 的方式来实现的。更多了解 多线程在 iOS 开发中的优缺点优点： 简化了编程模型 更加的轻量级 提高了执行效率 提高了资源利用率 缺点： 增加了程序设计复杂性 占用内存空间 增大 CPU 调度开销 多线程技术方案pThread描述：是基于 C 语言实现的框架，是一套通用的多线程 API，适用于 Unix/Linux/Windows 等系统，可以跨平台、移植，使用难度大，一般几乎不用。 使用语言：C 语言 线程生命周期：由程序员进行管理。 NSThread描述：对 C 语言框架进行了封装，完全是面向对象的，可直接操作线程对象。 使用语言：Objective-C 线程生命周期：由程序员进行管理。 对象初始化主要有 3 种方式来实现多线程： 方式1：通过 alloc 方式创建 NSThread 对象 方式2：通过 detachNewThreadSelector 方式 方式3：通过 performSelectorInBackground 方式 Set name其中 方式1 创建的 thread 对象，可以设置线程的 name ,用来作为线程的标识，一般有以下用途： 1、用于 Debug 调试。 2、可以根据不同的线程来执行不同的业务逻辑。 设置优先级thread 对象还可以通过 setThreadPriority方法来设置不同的优先级。 终端多线程输出如下图所示： 在图中，我们不难发现： 红色箭头指的是 App 的进程 ID 2422 绿框中的指的是 主线程的 ID 120606 蓝色的框分别是新建的子线程，他们线程ID 依次是 120987，120988 不同线程之间的资源竞争问题在实际项目中经常有以下场景：多个线程同时设置或读取同一个 property 的值。这样会导致资源竞争，数据不准确的问题。 在 Demo 中我们通过抢红包游戏来模拟资源竞争问题，一共有3个红包，四个人同时开抢，如下图是没有做任何处理的情况下，四个线程同时抢红包，导致红包数量出错，因为他们几乎同时修改了红包的数量。 我们可以通过 线程加锁 的方式来解决资源冲突问题。常用的有三种加锁方式，分别是 @synchronized (self) { 在这里修改数据 } 通过 NSCondition 对象，修改数据前加锁，修改数据后解锁。 通过 NSLock 对象，修改数据前加锁，修改数据后解锁。 加锁后的数据如图所示，这次正常了，可怜的 muhlenXi 同学没抢到红包。 GCD描述：Grand Central Dispatch 是 Apple 公司针对多核并行运算提出的一套线程机制，GCD 会自动的管理线程的生命周期，使用起来比较方便和灵活。 使用语言：C 语言 生命周期管理：自动管理 进程同步 和 进程异步 进程同步：进程中的多个任务必须一个一个来处理，前一个任务处理完毕，才会进行下一个任务。同步会阻塞当前线程。 进程异步：不用等待任务处理完毕，就可以执行下一个任务了。异步不会阻塞当前线程。 dispatch_get_global_queuedispatch_get_global_queue(0, 0) 方法获取的是全局并发队列，第一个参数用于设置队列的优先级，使用场景如下： 异步执行不同任务 dispatch_get_main_queuedispatch_get_main_queue() 方法获取的是 主线程队列，使用场景如下： 刷新 UI 注意事项 1、当有多个任务异步执行时，给 dispatch_get_global_queue 设置优先级，并不能准确保证每个任务的执行顺序，优先级高的线程仅仅说明在该线程执行任务的概率大些而已。 2、自定义一个同步线程队列(SERIAL)，然后把多个任务放入同一个线程中执行，方可保证任务的执行顺序。 dispatch_group_tdispatch_group_t 使用场景如下： 在 同一个同步子线程 (即自定义 serial queue) 中，多个任务异步执行处理后，需要统一的回调通知来得知所有的任务都处理完了，然后再执行相应的业务处理。 dispatch_group_enter 和 dispatch_group_leave 使用场景： 在 同一个异步子线程 (即自定义 concurrent queue) 中发送多个异步数据请求，多个数据请求完成后，统一回调刷新 UI 等场景。 注意事项dispatch_group_notify 方法中，回调回来的数据是在异步线程中执行的，需要回到主线程中刷新 UI。 dispatch_oncedispatch_once 使用场景： 单例，App 声明周期中只会实例化一次。 整个生命周期只需要执行一次的代码块。 dispatch_afterdispatch_after 使用场景： 延迟执行某个任务。 注意事项当 ViewController 被 dealloc 后，如果时间到了，block 中的代码还会执行，会引起闪退问题，我们应该加以判断。 NSOperation描述: NSOperation 是针对 GCD 封装的一个多线程抽象基类，不能直接被使用，需要使用其子类。子类主要有以下三种使用方式： 使用 NSInvocationOperation ,系统封装的。 使用 NSBlockOperation, 系统封装的。 自定义 Operation,需继承于 NSOperation。 使用语言：Objective-C线程生命周期：自动管理 NSOperation 子对象NSOperation 子对象有 5 种状态，分别是： ready (就绪)、 cancelled（取消）、 executing（执行)、finished（完成） 和 asynchronous（是否并发）。 实际项目中应该根据不同状态来执行不同业务逻辑。 添加依赖NSOperation 子对象之间可以通过 addDependency 方法来添加依赖关系，注意别导致依赖环。 比如：A 依赖于 B，表明 B 任务执行完，才会执行 A 任务。 1[blockOperA addDependency:blockOperB]; 注意事项：NSOperation 子对象的 start 方法使任务都会在当前线程中同步执行，会阻塞当前线程。 NSOperationQueue 是什么？NSOperationQueue 指的是操作队列，我们可以理解为线程池，我们可以将 Operation 对象加入到线程池中，操作系统会根据资源来调度。对于 NSOperationQueue ： 可以通过 addOperation 方法添加对象。 可以通过 setMaxConcurrentOperationCount 方法来设置线程池的最大并发数。 注意事项当我们自定义 Operation 执行异步网络请求任务时，如果此时有依赖，会导致依赖失效，因为异步请求会新开辟一个线程去执行任务，Operation 此时会认为，该任务已经完成，就会按照依赖关系去执行下一个任务。针对这种情况，解决办法就是： 第一步：在 自定义Operation 类中声明一个属性，用来表示线程是否结束； 1@property (nonatomic,assign) BOOL isOver; //!&lt; 线程是否结束 第二步：在 main 方法中使用 NSRunLoop 的方式使线程一直执行，直到异步网络请求任务完成后，再改变 isOver。 123456789101112131415161718192021// 重写 main 方法执行自定义的任务- (void)main &#123; // 模拟网络请求 dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; NSLog(@\"执行模拟网络请求任务\"); [NSThread sleepForTimeInterval:1]; if (self.isCancelled) &#123; return; &#125; NSLog(@\"%@\",self.name); self.isOver = YES; &#125;); // 使线程一直运行 while (!self.cancelled &amp;&amp; !self.isOver) &#123; [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]]; &#125;&#125; iOS 多线程到此就完结了。 Ending如果觉得本文不错的话，不妨赞助一罐百事可乐，支持作者后期产出更多优质内容！ 欢迎留言一起交流…","tags":[{"name":"GCD","slug":"GCD","permalink":"http://yoursite.com/tags/GCD/"},{"name":"pThread","slug":"pThread","permalink":"http://yoursite.com/tags/pThread/"},{"name":"NSThread","slug":"NSThread","permalink":"http://yoursite.com/tags/NSThread/"},{"name":"NSOperation","slug":"NSOperation","permalink":"http://yoursite.com/tags/NSOperation/"}]},{"title":"对 BLE 外设（Peripheral）自动重连机制的逻辑梳理","date":"2017-07-07T06:37:36.000Z","path":"2017/07/07/About-Ble-Auto-Connecting/","text":"版权声明：本文为 muhlenXi 原创文章，欢迎转载，转载请注明来源。 导语： 近期一直在做 BLE 蓝牙手环的一些项目，也积累了一些经验，为了不再被这些问题劳生伤神，还是记录下来比较靠谱。目前，CoreBluetooth 与有手环（Peripheral）两种连接方式，一种是连接后就可以直接通信了，另一种则是，连接后需要配对，配对后就可以通信了。本文会针对两种不同的机制的自动重连方式进行探索和记录。 到目前为止，感受最深的是，敲代码跟写作文有点类似，有思路的时候，行云流水，一气呵成。没思路的时候，就跟挤牙膏似得，还问题不断。为了提高以后行云流水的能力，就把一些比较绕的逻辑记录下来。 【1】直接连接通信（无需配对的情况）这种情况，就是每次都得 Scan Peripheral ，找到你想要的 peripheral 后，然后进行 connect 操作，connect 成功后，就可以为所欲为了。 这种情况下，当 peripheral 因为一些原因断开连接或者用户主动断开连接导致连接中断，CoreBluetooth 会调用 - (void)centralManager:(CBCentralManager *)central didDisconnectPeripheral:(CBPeripheral *)peripheral error:(NSError *)error 代理方法，你若你想要自动重连的话，需要进行以下操作。 步骤 1创建一个 断开原因 标志位，用于标识断开的原因，用于判断断开原因是用户主动断开的？还是其他原因断开的？ 比如： 1@property (nonatomic,copy) NSString * disConnectedState; //!&lt; 1-其他原因断开，自动重连 3-手动断开，不重连 当然，这种情况 enum 是最合理的方式。 步骤 2创建一个 连接方式 标志位，用于标识连接的方式，用于判断连接方式是用户点击 Peripheral 列表连接的？还是自动重连以前连接过的 Peripheral ？ 比如： 1@property (nonatomic,copy) NSString * connectedMethod; //!&lt; 1 - 自动重连, 2 - 点击连接 当然，这种情况 enum 是最合理的方式。 步骤 3通过 NSUserDefaults 记录曾经连接过的 Peripheral 的名字，前提是这个名字可以唯一标识这个 peripheral。 比如，在连接成功的代理方法中保存 peripheral 的名字。 12// 保存外设名字[[NSUserDefaults standardUserDefaults] setObject:peripheral.name forKey:@\"PeripheralName\"]; 步骤 4在 - (void)centralManagerDidUpdateState:(CBCentralManager *)central 代理方法中决定是否要调用 60秒重连方法自动重连方法，并且在自动重连方法中需要将连接方式标志位设为自动重连方式。 1234567891011121314151617181920212223242526272829303132- (void)centralManagerDidUpdateState:(CBCentralManager *)central&#123; switch (central.state) &#123; case CBCentralManagerStateUnknown: NSLog(@\"&gt;&gt;&gt; CBCentralManagerStateUnknown\"); break; case CBCentralManagerStateResetting: NSLog(@\"&gt;&gt;&gt; CBCentralManagerStateResetting\"); break; case CBCentralManagerStateUnsupported: NSLog(@\"&gt;&gt;&gt; CBCentralManagerStateUnsupported\"); break; case CBCentralManagerStateUnauthorized: NSLog(@\"&gt;&gt;&gt; CBCentralManagerStateUnauthorized\"); break; case CBCentralManagerStatePoweredOff: NSLog(@\"&gt;&gt;&gt; CBCentralManagerStatePoweredOff\"); break; case CBCentralManagerStatePoweredOn: &#123; NSLog(@\"&gt;&gt;&gt; CBCentralManagerStatePoweredOn\"); // 其他原因断开 并且 peripheral 的名字不为 nil NSString * existName = [[NSUserDefaults standardUserDefaults] objectForKey:@\"PeripheralName\"]; if ([self.disConnectedState isEqualToString:@\"1\"] &amp;&amp; existName != nil) &#123; [self autoScanAndConnectedToExistPeripheralOnOneMinutes]; &#125; &#125; break; default: break; &#125;&#125; 以下为60S自动重连方法 123456789101112131415161718192021222324252627282930313233343536373839// 自动去搜索之前连过的外设并尝试一分钟重连- (void) autoScanAndConnectedToExistPeripheralOnOneMinutes&#123; // 如果之前连接的 peripheral 为 nil，则需要先搜索到这个 peripheral 后再连接，如果不为 nil ，则直接连接处理。 if (self.peripheral == nil) &#123; [self.centralManager scanForPeripheralsWithServices:nil options:nil]; &#125; else &#123; [self.centralManager connectPeripheral:self.peripheral options:nil]; &#125; // 正在连接的加载动画 [self.centralManager scanForPeripheralsWithServices:nil options:nil]; [SVProgressHUD setDefaultMaskType:SVProgressHUDMaskTypeBlack]; [SVProgressHUD setDefaultStyle:SVProgressHUDStyleCustom]; [SVProgressHUD setBackgroundColor:[UIColor blackColor]]; [SVProgressHUD setForegroundColor: [UIColor whiteColor]]; [SVProgressHUD showWithStatus:NSLocalizedString(@\"In the connection...\", @\"连接中\")]; // 连接方式为自动重连 self.connectedMethod = @\"1\"; // 60秒后超时处理 dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(60 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; // 如果 60 S后还未找到连接过的 peripheral 则取消搜索和连接。 if (self.peripheral == nil ) &#123; // 停止搜索 [self.centralManager stopScan]; // 取消连接，为了避免死循环，该取消连接方式为主动断开连接 self.disConnectedState = @\"3\"; [self.centralManager cancelPeripheralConnection:self.peripheral]; [SVProgressHUD dismiss]; &#125; &#125;);&#125; 如果是用户点击连接的话，需要在 Cell 的 didSelectRowAtIndexPath 代理方法中进行连接并设置连接方式标志。 12345678910111213141516171819//点击方法- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath&#123; // 取消连接 [[AppDelegate mainDelegate] cancelScanPeripherals]; // 保存用户指定的 Peripheral CBPeripheral * per = [AppDelegate mainDelegate].bleArray[indexPath.row]; [AppDelegate mainDelegate].peripheral = per; [SVProgressHUD showWithStatus:NSLocalizedString(@\"Linking Bluetooth devices...\", @\"name\")]; // 设置连接方式为用户点击连接方式 [AppDelegate mainDelegate].connectedMethod = @\"2\"; // 连接外设 [[AppDelegate mainDelegate] connectToPeripheralOnOneMinutes]; &#125; 步骤 5在 - (void)centralManager:(CBCentralManager *)central didDiscoverPeripheral:(CBPeripheral *)peripheral advertisementData:(NSDictionary&lt;NSString *, id&gt; *)advertisementData RSSI:(NSNumber *)RSSI 扫描外设代理方法中区别对待不同连接方式的Peripheral，如果是自动重连模式下的，发现 Peripheral 后直接连接，如果仅仅是搜索模式下的，仅仅添加到外设列表数组就可以了。 1234567891011121314151617181920212223- (void)centralManager:(CBCentralManager *)central didDiscoverPeripheral:(CBPeripheral *)peripheral advertisementData:(NSDictionary&lt;NSString *, id&gt; *)advertisementData RSSI:(NSNumber *)RSSI&#123; // 自动重连发现设备直接连接 if ([self.connectedMethod isEqualToString:@\"1\"]) &#123; NSString * name = [[NSUserDefaults standardUserDefaults] objectForKey:@\"PeripheralName\"]; if ([peripheral.name isEqualToString:name]) &#123; NSLog(@\"自动重连搜索到了 %@ ,正在重连。。。\",name); self.peripheral = peripheral; [central connectPeripheral:peripheral options:nil]; &#125; &#125; // 不是自动重连，则将满足条件的 peripheral 加入到外设列表数组中 if ([peripheral.name hasPrefix:@\"SMART_\"]) &#123; NSLog(@\"DiscoverPeripheral--%@\",peripheral.name); if (![self.bleArray containsObject:peripheral] ) &#123; [self.bleArray addObject:peripheral]; [[NSNotificationCenter defaultCenter] postNotificationName:@\"BleArrayChanged\" object:nil]; &#125; &#125;&#125; 步骤 6在 - (void)centralManager:(CBCentralManager *)central didConnectPeripheral:(CBPeripheral *)peripheral 连接成功代理方法中分别执行对应操作，如果是自动重连，不需要执行相应的界面跳转操作，如果是用户点击 Peripheral 列表连接成功，则需要进行相应界面跳转操作。 1234567891011121314151617181920212223- (void)centralManager:(CBCentralManager *)central didConnectPeripheral:(CBPeripheral *)peripheral&#123; NSLog(@\"--连接成功--%@\",peripheral.name); // 保存外设名字 [[NSUserDefaults standardUserDefaults] setObject:peripheral.name forKey:@\"PeripheralName\"]; // 这是重连成功，不进行页面跳转 if ([self.connectedMethod isEqualToString:@\"1\"]) &#123; // 更新外设状态信息 &#125; else if ([self.connectedMethod isEqualToString:@\"2\"]) &#123; // 用户点击点击Peripheral 列表连接成功 // 执行相应界面跳转操作 &#125; self.peripheral.delegate = self; [self.peripheral discoverServices:nil]; &#125; 步骤 7在 - (void)centralManager:(CBCentralManager *)central didDisconnectPeripheral:(CBPeripheral *)peripheral error:(NSError *)error 断开连接代理方法中执行对应操作，如果是用户断开连接，则不需要自动重连，如果是其他原因断开连接的，则需要断开连接。 123456789101112131415// 外设断开连接- (void)centralManager:(CBCentralManager *)central didDisconnectPeripheral:(CBPeripheral *)peripheral error:(NSError *)error&#123; NSLog(@\"--断开连接 -- %@\",peripheral.name); // 更新 外设状态信息 // 用户主动断开连接 if ([self.disConnectedState isEqualToString:@\"3\"]) &#123; // do nothing return; &#125; [self connectToPeripheralOnOneMinutes];&#125; 步骤 8在用户主动断开连接的方法中，保存断开方式标志，并断开连接。 123456789//断开连接- (void)StopConnectedButtonDidClicked:(id) sender&#123; // 手动断开方式 [AppDelegate mainDelegate].disConnectedState = @\"3\"; [[AppDelegate mainDelegate].centralManager cancelPeripheralConnection:[AppDelegate mainDelegate].peripheral]; &#125; 经过以上这些步骤，一个自动重连机制就理清了。 【2】连接后需要配对的情况思路：当你与 Peripheral 配对后，只要你的 Peripheral 在手机的连接范围内，系统会去自动连接你的手环，因此，你需要在连接成功后，保存 Peripheral 的UUIDString。如果想要在 APP 启动后能自动连接之前配对的 Peripheral，你需要执行以下操作。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869- (void)centralManagerDidUpdateState:(CBCentralManager *)central&#123; switch (central.state) &#123; case CBCentralManagerStateUnknown: NSLog(@\"&gt;&gt;&gt; CBCentralManagerStateUnknown\"); break; case CBCentralManagerStateResetting: NSLog(@\"&gt;&gt;&gt; CBCentralManagerStateResetting\"); break; case CBCentralManagerStateUnsupported: NSLog(@\"&gt;&gt;&gt; CBCentralManagerStateUnsupported\"); break; case CBCentralManagerStateUnauthorized: NSLog(@\"&gt;&gt;&gt; CBCentralManagerStateUnauthorized\"); break; case CBCentralManagerStatePoweredOff: NSLog(@\"&gt;&gt;&gt; CBCentralManagerStatePoweredOff\"); [[NSNotificationCenter defaultCenter] postNotificationName:DisconnectPeripheral object:nil]; break; case CBCentralManagerStatePoweredOn: &#123; NSLog(@\"&gt;&gt;&gt; CBCentralManagerStatePoweredOn\"); // 1、获取之前配对设备的 UUID String NSString * uuidStr = [[NSUserDefaults standardUserDefaults] objectForKey:BleBindUUID]; NSLog(@\" bind uuidStr == %@\",uuidStr); // 2、如果 UUID String 为 nil，说明之前没有配对过任何外设，则外设进行扫描操作，如果不为 nil 且不等于空，则根据 NSUUID 恢复之前配对的 Peripheral if (uuidStr != nil &amp;&amp; ![uuidStr isEqualToString:@\"nil\"] &amp;&amp; ![uuidStr isEqualToString:@\"\"]) &#123; // 根据 UUID String 生成 NSUUID 对象 NSUUID * uuid = [[NSUUID alloc] initWithUUIDString:uuidStr]; // 根据 NSUUID 恢复曾经配对过的设备 NSArray * peripherals = [central retrievePeripheralsWithIdentifiers:@[uuid]]; // 数组不为空，说明找到之前配对过的设备 if (peripherals.count &gt; 0) &#123; // 之前配对的 对象 CBPeripheral *peripheral = [peripherals firstObject]; self.peripheral = peripheral;//**关键**需要转存外设值，才能发起连接 self.peripheral.delegate = self; NSLog(@\"self.peripheral == %@\",self.peripheral); // 60秒自动重连方法 [self connectingPeripheralDuringOneMinute]; &#125; &#125; else &#123; // 开始搜索外设 [central scanForPeripheralsWithServices:nil options:nil]; // 4s 后停止扫描 dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(4 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; // 停止搜索外设 &#125;); &#125; &#125; break; default: break; &#125; &#125; 注意：当手环与外设配对连接后，通过 cancelPeripheralConnection 方法是有时是无法断开与外设的连接。你需要到系统设置里去忽略这个外设，方可消除配对状态。 结束语欢迎在本文下面留言一起交流心得… 如果本文能给你带来一定的帮助，在自己有能力的情况下，不妨赞助一下，表示对博主辛勤耕作的支持！","tags":[{"name":"BLE","slug":"BLE","permalink":"http://yoursite.com/tags/BLE/"},{"name":"Auto Connecting","slug":"Auto-Connecting","permalink":"http://yoursite.com/tags/Auto-Connecting/"}]},{"title":"iOS BLE 开发小记[7] - 与小米手环 2 进行数据交互","date":"2017-05-08T07:45:00.000Z","path":"2017/05/08/iOS-Bluetooth-Low-Energy-Develop-Chapter7/","text":"版权声明：本文为 muhlenXi 原创文章，欢迎转载，转载请注明来源。 导语： 根据前面学到的知识，在这一篇将以小米手环2为硬件，对前面的知识点进行实践操作。实践是检验真理的唯一标准！ 关于 BLE 开发，有一款很要用的 APP 可以协助开发，它就是 LightBlue ,有需要的小伙伴可以去 App Store 下载。 本文的 Demo 可以在 GitHub 下载，欢迎一起交流和学习！传送门在这里 开发环境 Xcode：8.3.1 Language： Swift 3.0 Device：MI Band 2 开始实践由于小米手环有配对机制，其他的 APP 连接后，过段时间，小米手环就会断开连接，解决这个问题的办法是先用小米手环官方的 APP 小米运动 配对后，然后退出。再开始本篇的文章的实践之路。 恢复配对数组我们通过 retrievePeripherals 方法传入该手环的 UUID 来恢复系统过去曾经配对的 Peripheral 数组，如果数组不为空，则连接这个 Peripheral，示例代码如下： 1234567891011121314// retrieve Peripherallet uuid = UUID(uuidString: \"32CDD66A-659D-8449-3F9A-ACCF201C8660\")let peripheralArray = self.centralManager.retrievePeripherals(withIdentifiers: [uuid!])if peripheralArray.count &gt; 0 &#123; self.peripheral = peripheralArray.first! self.peripheral?.delegate = self // connecting peripheral self.centralManager .connect(self.peripheral!, options: nil) &#125; else &#123; // begin discover peripherals self.centralManager.scanForPeripherals(withServices: nil, options: nil)&#125; Discover Services连接成功后，我们调用 discoverServices 方法来查找 Peripheral 的 Services，通过遍历 peripheral.services 数组打印，总共有以下几个 Service： Discover Characteristic接下来，我们分别调用 discoverCharacteristics 方法来分别查找每个 Service 的 Characteristic。通过遍历 service.characteristics 的数组，我们可以获取到每个 service 的 Characteristic。 通过查看 CBCharacteristicProperties 的声明信息，可以了解到，这是一个 struct。我们需要获取到每个属性的 rawValue，以便与下面对 Characteristic 的属性进行分析,通过打印，我们获取到的 rawValue 分别为，转为十六进制分别为： 属性 rawValue 16进制0x表示 broadcast 1 0x 0000 0001 read 2 0x 0000 0010 writeWithoutResponse 4 0x 0000 0100 write 8 0x 0000 1000 notify 16 0x 0001 0000 indicate 32 0x 0010 0000 authenticatedSignedWrites 64 0x 0100 0000 extendedProperties 128 0x 1000 0000 180A 服务的特征：该服务共有 5 个特征，uuidString 分别为 2A25、2A27、2A28、2A23、2A50。该服务的特征大部分是一个硬件设备的信息。 2A25：设备序列号 &lt;CBCharacteristic: 0x1740a3b40, UUID = Serial Number String, properties = 0x2, value = &lt;62356663 36626433 61623464&gt;, notifying = NO&gt; 2A27：固件版本号 &lt;CBCharacteristic: 0x1700a5ac0, UUID = Hardware Revision String, properties = 0x2, value = &lt;56302e31 2e332e32&gt;, notifying = NO&gt; 2A28：固件版本号 &lt;CBCharacteristic: 0x1700a5b20, UUID = Software Revision String, properties = 0x2, value = &lt;56312e30 2e312e34 37&gt;, notifying = NO&gt; 2A23：系统 ID &lt;CBCharacteristic: 0x1700a5b80, UUID = System ID, properties = 0x2, value = &lt;d36c4aff fe4fb38f&gt;, notifying = NO&gt; 2A50：PnP ID &lt;CBCharacteristic: 0x1740a3c60, UUID = PnP ID, properties = 0x2, value = &lt;01570104 000001&gt;, notifying = NO&gt; 00001530-0000-3512-2118-0009AF100700 服务的特征：该服务一共有 2 个特征，uuidstring 分别为 00001531-0000-3512-2118-0009AF100700 、00001532-0000-3512-2118-0009AF100700。 00001531-0000-3512-2118-0009AF100700： &lt;CBCharacteristic: 0x1700a5c40, UUID = 00001531-0000-3512-2118-0009AF100700, properties = 0x18, value = (null), notifying = NO&gt; 00001532-0000-3512-2118-0009AF100700： &lt;CBCharacteristic: 0x1700a5ca0, UUID = 00001532-0000-3512-2118-0009AF100700, properties = 0x4, value = (null), notifying = NO&gt; 1811 服务的特征：该服务一共有 2 个特征，uuidstring 分别为 2A46 、2A44。 2A46： &lt;CBCharacteristic: 0x1700a5d00, UUID = 2A46, properties = 0x8, value = (null), notifying = NO&gt; 2A44： &lt;CBCharacteristic: 0x1740a3120, UUID = 2A44, properties = 0x1A, value = &lt;01&gt;, notifying = NO&gt; 1802 服务的特征：2A06： &lt;CBCharacteristic: 0x1740a4b00, UUID = 2A06, properties = 0x4, value = (null), notifying = NO&gt; 180D 服务的特征：2A37： &lt;CBCharacteristic: 0x1740a4860, UUID = 2A37, properties = 0x10, value = (null), notifying = NO&gt; 2A39： &lt;CBCharacteristic: 0x1740a4bc0, UUID = 2A39, properties = 0xA, value = (null), notifying = NO&gt; FEE0 服务的特征：该服务一共有 11 个特征，uuidstring 分别为2A2B、00000001-0000-3512-2118-0009AF100700、00000002-0000-3512-2118-0009AF100700、00000003-0000-3512-2118-0009AF100700、2A04、00000004-0000-3512-2118-0009AF100700、00000005-0000-3512-2118-0009AF100700、00000006-0000-3512-2118-0009AF100700、00000007-0000-3512-2118-0009AF100700、00000008-0000-3512-2118-0009AF100700、00000010-0000-3512-2118-0009AF100700 2A2B：当前时间 &lt;CBCharacteristic: 0x1740a4aa0, UUID = Current Time, properties = 0x1A, value = &lt;e1070508 0e341801 000020&gt;, notifying = NO&gt; 00000001-0000-3512-2118-0009AF100700： &lt;CBCharacteristic: 0x1700a5d60, UUID = 00000001-0000-3512-2118-0009AF100700, properties = 0x14, value = (null), notifying = NO&gt; 00000002-0000-3512-2118-0009AF100700： &lt;CBCharacteristic: 0x1740a47a0, UUID = 00000002-0000-3512-2118-0009AF100700, properties = 0x10, value = (null), notifying = NO&gt; 00000003-0000-3512-2118-0009AF100700： &lt;CBCharacteristic: 0x1740a4560, UUID = 00000003-0000-3512-2118-0009AF100700, properties = 0x14, value = &lt;10060700 01&gt;, notifying = NO&gt; 2A04：周边首选连接参数 &lt;CBCharacteristic: 0x1740a4680, UUID = Peripheral Preferred Connection Parameters, properties = 0x16, value = &lt;27002700 0000f401&gt;, notifying = NO&gt; 00000004-0000-3512-2118-0009AF100700： &lt;CBCharacteristic: 0x1740a46e0, UUID = 00000004-0000-3512-2118-0009AF100700, properties = 0x14, value = (null), notifying = NO&gt; 00000005-0000-3512-2118-0009AF100700： &lt;CBCharacteristic: 0x1740a4500, UUID = 00000005-0000-3512-2118-0009AF100700, properties = 0x10, value = (null), notifying = NO&gt; 00000006-0000-3512-2118-0009AF100700： &lt;CBCharacteristic: 0x1740a40e0, UUID = 00000006-0000-3512-2118-0009AF100700, properties = 0x12, value = &lt;0f4f00e1 07041b02 050720e1 07041b06 320a2064&gt;, notifying = NO&gt; 00000007-0000-3512-2118-0009AF100700： &lt;CBCharacteristic: 0x1700a5dc0, UUID = 00000007-0000-3512-2118-0009AF100700, properties = 0x12, value = &lt;0ccc0000 008a0000 00040000 00&gt;, notifying = NO&gt; 00000008-0000-3512-2118-0009AF100700： &lt;CBCharacteristic: 0x1700a5e20, UUID = 00000008-0000-3512-2118-0009AF100700, properties = 0x18, value = (null), notifying = NO&gt; 00000010-0000-3512-2118-0009AF100700： &lt;CBCharacteristic: 0x1700a5e80, UUID = 00000010-0000-3512-2118-0009AF100700, properties = 0x10, value = (null), notifying = NO&gt; FFE1 服务的特征：该服务一共有 9 个特征，uuidstring 分别为 00000009-0000-3512-2118-0009AF100700、FEDD、FEDE、FEDF、FED0、FED1、FED2、FED3、0000FEC1-0000-3512-2118-0009AF100700。 00000009-0000-3512-2118-0009AF100700： &lt;CBCharacteristic: 0x1740a45c0, UUID = 00000009-0000-3512-2118-0009AF100700, properties = 0x16, value = &lt;100301&gt;, notifying = NO&gt; FEDD： &lt;CBCharacteristic: 0x1740a4260, UUID = FEDD, properties = 0x8, value = (null), notifying = NO&gt; FEDE： &lt;CBCharacteristic: 0x1740a4020, UUID = FEDE, properties = 0x2, value = (null), notifying = NO&gt; FEDF： &lt;CBCharacteristic: 0x1700a5be0, UUID = FEDF, properties = 0x2, value = (null), notifying = NO&gt; FED0： &lt;CBCharacteristic: 0x1740a4200, UUID = FED0, properties = 0xA, value = (null), notifying = NO&gt; FED1： &lt;CBCharacteristic: 0x1740a4d40, UUID = FED1, properties = 0xA, value = (null), notifying = NO&gt; FED2： &lt;CBCharacteristic: 0x1740a4da0, UUID = FED2, properties = 0x2, value = (null), notifying = NO&gt; FED3： &lt;CBCharacteristic: 0x1740a4e00, UUID = FED3, properties = 0xA, value = (null), notifying = NO&gt; 0000FEC1-0000-3512-2118-0009AF100700： &lt;CBCharacteristic: 0x1740a4e60, UUID = 0000FEC1-0000-3512-2118-0009AF100700, properties = 0x1A, value = (null), notifying = NO&gt; 结束语欢迎在本文下面留言一起交流心得… 如果本文能给你带来一定的帮助，在自己有能力的情况下，不妨赞助一下，表示对博主辛勤耕作的支持！","tags":[{"name":"BLE","slug":"BLE","permalink":"http://yoursite.com/tags/BLE/"}]},{"title":"iOS BLE 开发小记[6] - 设置本地设备为 Peripheral 的最佳实践","date":"2017-05-07T04:45:00.000Z","path":"2017/05/07/iOS-Bluetooth-Low-Energy-Develop-Chapter6/","text":"版权声明：本文为 muhlenXi 原创文章，欢迎转载，转载请注明来源。 导语： 在这篇文章中，主要是将你的本地设备设置为一个广播数据的 Peripheral 的最佳实践，以及实际开发过程中应该注意的事项。 正如许多 Central 端的处理一样，CoreBluetooth 框架允许你控制 Peripheral 各方面的实现。这一篇将会给你提供一些准则和以负责的方式给你提供一些使用的最佳实践。 留意广播的数据广播 Peripheral 的数据是实现设备本地设备为 Peripheral 的重要部分。接下来的小节将会帮助你以一些合理的方式来广播数据。 遵守广播数据长度的限制广播 Peripheral 的数据是通过调用 CBPeripheralManager 类的 startAdvertising: 方法时传入广播数据的字典来完成的。当你创建一个广播数据字典时，需要注意你能广播数据的内容和长度限制。 尽管通常的广播数据包可以各种各样 Peripheral 设备的信息。也许你仅仅想广播设备的 Local Name和你想要广播的服务的 UUID，也就是说，当你创建广播数据字典的时候，你仅仅能够指定以下两种 Key：CBAdvertisementDataLocalNameKey 和 CBAdvertisementDataServiceUUIDsKey,如果你指定其他的 Key，你将会收到错误提醒。 对广播数据的空间大小也有限制。当你的 APP 在前台运行状态时，你可以有 28 字节的空间用来初始化广播数据字典，该字典包含两个支持的 key。如果空间用尽，作为搜索响应将会额外增加 10 个字节的空间仅仅用于 Local name。任何服务的 UUID 不允许加入到这个专用的 “overflow” 空间。当用户设备显式搜索的时候才可以发现这个专用空间的内容。当你的 APP 在后台运行状态时，则不会广播 Local name，并且所有服务的 UUID 将会被放到这个特别空间里。 注意：这些空间不包含每个新数据类型的 2 个字节的头部信息，广播数据和响应数据的正确格式在 Bluetooth 4。0 规范，第3卷，C部分，11章节有定义。 为了在使空间大小在这些约束之内，仅允许广播主要的 Service UUID。 仅仅广播你需要的数据因为广播数据需要用到设备的 Radio ，会影响电池续航时间，因此当你想要别的设备连接你时，再广播数据。连接后，这些设备可以直接与 Peripheral 的数据进行交互，不需要其他广播数据包。因此，想要促进 BLE 的处理，应停止广播来最小化 Radio 的使用，进而增加 APP 的性能和保留设备的电量。通过调用 CBPeripheralManager 类的 stopAdvertising 方法即可。 1[myPeripheralManager stopAdvertising]; 让用户来决定什么时候来广播知道什么时候来广播通常用户比较清楚。举个例子，当你知道附近没有任何 BLE 设备时，在你的设备上 用 APP 广播服务是没有意义的。因为你的 APP 经常感知不到什么设备在附近，应在 APP 中提供一个 UI 界面来让用户选择何时广播。 配置你的 Characteristic当你创建一个 mutable Characteristic，然后你设置它的属性，值，权限等。这些设定决定着 Central 如何连接和如何与 Characteristic 的值交互。虽然你可能基于你的 APP 的不同需要来配置 不同的Characteristic 属性、值、权限。当你需要执行以下的两种任务时，下面的小节将会提供一些指导： 允许 Central 连接来订阅 Characteristic 保护 Characteristic 的敏感信息不被未配对的 Central 访问 配置你的 Characteristic 支持通知在之前文章的描述中，我们知道对于经常改变值的 Characteristic，建议 Central 订阅该 Characteristic。 只要可能，应允许连接的 Central 来订阅你的 Characteristic 的值。 当你创建一个 mutable Characteristic 时，通过设置 Characteristic 的 properties 属性为 CBCharacteristicPropertyNotify 来支持订阅。就像这样： 1234myCharacteristic = [[CBMutableCharacteristic alloc] initWithType:myCharacteristicUUID properties:CBCharacteristicPropertyRead | CBCharacteristicPropertyNotify value:nil permissions:CBAttributePermissionsReadable]; 示例中，Characteristic 的值是可读的，它可以被连接的 Central 订阅。 需要一个配对的连接来访问敏感数据根据使用情况，你可能想要发布一个服务，这个服务的一个或多个 Characteristic 的值是敏感的。举个例子，你可能想要发布一个 社交服务描述 服务，这个服务可能包含一些代表用户描述信息的 Characteristic，比如姓，名字，和 email 地址等。很有可能，你想要允许受信任的设备来获取用户的 email 地址。 你可以确保只有受信任的设备才能访问敏感 Characteristic 的值，你可以通过恰当的设置 Characteristic 的属性和权限来达到目的。继续上面提到的例子，只允许受信任的设备来获得用户的 email 地址，恰当的设置 Characteristic 的 properties 和 permissions，像这样： 12345emailCharacteristic = [[CBMutableCharacteristic alloc] initWithType:emailCharacteristicUUID properties:CBCharacteristicPropertyRead | CBCharacteristicPropertyNotifyEncryptionRequired value:nil permissions:CBAttributePermissionsReadEncryptionRequired]; 示例代码中，Characteristic 配置的只允许受信任的设备来读和订阅它的值。当连接后，Remote Central 尝试读取或订阅这个 Characteristic 的值时， CoreBluetooth 将尝试将 Central 和本地设备配对来创建安全连接。 举个例子，如果 Central 和 Peripheral 都是 iOS 设备，双方都会弹出一个表示有设备想要配对的弹框。你需要将 Central 设备上弹框的配对码填入到 Peripheral 设备上弹框的文本框里来完成配对处理。 完成配对后，Peripheral 会认为该 Central 是个受信任的设备，并允许 Central 来访问它的加密Characteristic 的值。 参考文献1、Best Practices for Setting Up Your Local Device as a Peripheral 结束语欢迎在本文下面留言一起交流心得… 如果本文能给你带来一定的帮助，在自己有能力的情况下，不妨赞助一下，表示对博主辛勤耕作的支持！","tags":[{"name":"BLE","slug":"BLE","permalink":"http://yoursite.com/tags/BLE/"}]},{"title":"iOS BLE 开发小记[5] - 与 Remote Peripheral 交互的最佳实践","date":"2017-05-05T03:45:00.000Z","path":"2017/05/05/iOS-Bluetooth-Low-Energy-Develop-Chapter5/","text":"版权声明：本文为 muhlenXi 原创文章，欢迎转载，转载请注明来源。 导语： 在这一节，主要是与 Remote Peripheral 交互的最佳实践，以及实际开发过程中应该注意的事项。 CoreBluetooth 框架使 Central 端的工作变得容易透明、容易理解。也就是说，你的 APP 可以控制和负责 Central 的大部分方面，比如搜索设备、建立连接、与 Remote Peripheral 进行数据交互。本章将以负责的方式来提供一些规范和最佳实践，尤其是当你为 iOS 设备开发 APP 的时候。 要留意 Radio 的使用和电量的消耗当开发一个 APP 与 BLE 设备交互时，需要铭记：BLE 通信会通过你的设备向空中发射 Radio 信号。其他形式的无线通信也可能需要使用设备的 Radio，比如，Wi-Fi，传统蓝牙以及使用 BLE 的其他 APP。因此要减少 Radio 的使用。 当开发 iOS 设备的 APP 时，最少次数使用 Radio 很重要，因为 Radio 的使用会对 iOS 设备电池的续航时间有不利影响。以下的这些规范将会帮助你更好的使用 Radio。作为回报，你的 APP 会良好运行和你设备电池的续航时间将会延长。 只在需要的时候搜索周边设备当你调用 CBCentralManager 类的 scanForPeripheralsWithServices:options: 方法来搜索正在广播数据的 Remote Peripheral 时，你设备的 Radio 会一直监听正在广播的设备，直到你停止搜索为止。 除非你需要搜索更多的设备，否则当你找到你想要连接的设备后就应该停止搜索，前几篇提到过，用 CBCentralManager 类的 stopScan 方法来停止搜索设备。 必要的时候再指定 CBCentralManagerScanOptionAllowDuplicatesKey 选项Remote Peripheral 设备可能会每秒发送多个广播数据包给监听的 Central，当你调用 scanForPeripheralsWithServices:options: 方法搜索设备时，该方法默认的行为是将一个 Peripheral 的多个发现事件合并成一个发现事件，也就是说，Central Manager 每找到一个新的 Peripheral 时才会调用 centralManager:didDiscoverPeripheral:advertisementData:RSSI: 代理方法，不管收到多少广播数据包都不会调用该方法。当已发现的 Peripheral 的广播数据发生变化时也会调用这一代理方法。 如果你想改变默认行为，调用 scanForPeripheralsWithServices:options: 方法时你可以指定 scan option 为 CBCentralManagerScanOptionAllowDuplicatesKey,这样每当 Central 收到来自 Peripheral 的数据包就会创建一个发现事件。对于某些情况关闭默认行为会很有用，比如基于 Peripheral 的 Proximity （靠近程度）来进行连接交互。Proximity 可以通过 Peripheral 的 接收信号强度指示（RSSI）的值来判断，也就是说，指定这个扫描选项会对电源的续航和 APP 的运行造成不利影响。因此，只在必要的情况下再指定该方法的 scan option。 明智地获取 Peripheral 的数据当你开发 APP 的时候，对于特定的使用情景，一个 Peripheral 设备可能拥的大量的 Service 和 Characteristic 已经超过了你需要的数量 ，搜索 Peripheral 全部的 Service 和 Characteristic 对电源的续航和 APP 的性能带来不利影响。因此。你应该只搜索你的 APP 需要的 Service 和 Characteristic。 举个例子，假如你连接的 Peripheral 有许多可用的 Service，但是你的 APP 只需要用到其中的两个。你只需要搜索这两个 Service 就可以了，只需要调用 CBPeripheral 类的 discoverServices: 方法时传入 Service UUID（用 CBUUID 对象表示） 数组就可以了。如下所示： 1[peripheral discoverServices:@[firstServiceUUID, secondServiceUUID]]; 当你搜索到这两个需要的 Service 后，你可以用相似的方式来搜索你需要的 Characteristic，同样地，在调用 CBPeripheral 类的 discoverCharacteristics:forService: 方法时传入你想要的 Characteristic UUID（用 CBUUID 对象表示） 数组就可以了。 订阅值频繁变化的 Characteristic通过前面的文章，我们了解到，获取一个 Characteristic 值的方式有两种： 你可以在每次需要值的时候明确的调用 readValueForCharacteristic: 方法来读取 Characteristic 的值。 你可以调用 setNotifyValue:forCharacteristic: 方法来订阅 Characteristic 的值，这样当值发生改变后就会收到来自 Peripheral 的通知。 对于值可能变化的 Characteristic 来说，订阅是最佳实践方式，尤其是对于值频繁改变的 Characteristic，关于如何订阅一个 Characteristic 的值，可以查阅 Subscribing to a Characteristic’s Value. 当你得到你需要的数据后断开与设备的连接当不再需要连接的时候与设备断开连接可以帮助你减少 Radio 的使用，你应该在以下的情景中断开与 Peripheral 设备的连接： 你所有订阅的 Characteristic 的值已经不再通知，你可以通过 Characteristic 的 isNotifying 属性来判断 Characteristic 的值是否通知。 你从 Peripheral 设备中得到了所有的数据。 在上述的场景中，取消一些订阅并与 Peripheral 断开连接，你可以通过调用 setNotifyValue:forCharacteristic: 方法来取消订阅一个 Characteristic 的值，设置第一个参数为 NO 。你可以通过调用 CBCentralManager 类的 cancelPeripheralConnection: 方法来断开与 Peripheral 设备的连接。像这样： 1[myCentralManager cancelPeripheralConnection:peripheral]; 提示：cancelPeripheralConnection:方法是 nonblocking（非阻塞）的，一些 CBPeripheral 类的命令仍然等待 Peripheral，当你尝试断开连接可能没有完成执行.因为可能其他 APP 还在连接 Peripheral，取消一个本地连接不能保证设备物理连接立刻断开。从 APP 的角度来看，认为 Peripheral 是断开的，Central Manager 会调用 centralManager:didDisconnectPeripheral:error: 代理方法进行回调。 重新连接 Peripheral使用 CoreBluetooth 框架，你有三种方式可以重新连接 Peripheral： 通过调用 retrievePeripheralsWithIdentifiers: 方法来恢复一个已知的 Peripheral 列表 — Peripheral 是你发现的或者过去连接的。如果你要找的 Peripheral 在列表中，尝试去连接它。这种重连方式在 恢复已知的 Peripheral 列表 小节中有描述。 通过调用 retrieveConnectedPeripheralsWithServices: 方法来恢复系统当前已经连接的 Peripheral 列表，如果你要找的在列表中，则与它创建一个本地连接，这种重连方式在 恢复当前已连接的 Peripheral 列表 小节中有描述。 通过调用 scanForPeripheralsWithServices:options: 方法扫描和搜索 Peripheral，如果找到它，则连接。这种方式在 iOS BLE 开发小记[2]中有描述。 根据使用情况，每次重连 Peripheral ，你可能不想扫描和搜索同样的 Peripheral，你可能首先想用其他方式来重连。如图所示，一个可能的重连工作流程可能是按照上面的提到的顺序依次尝试这些方式。 提示：你决定尝试的重连方式的个数取决于 APP 的使用情况，举个例子，你可能决定不使用第一种方式，或者你可能并行使用第一种和第二种方式。 恢复已知的 Peripheral 列表当你第一次发现一个 Peripheral 时候，系统会创建一个标识符（用 NSUUID 对象表示的一个 UUID）来标识这个 Peripheral，你可以使用 NSUserDefaults 来保存这个标识符。过后你可以尝试调用CBCentralManager 类的 retrievePeripheralsWithIdentifiers: 方法来恢复并重新连接这个 Peripheral，下面描述的一种方式就是使用这个方法来重新连接以前的 Peripheral。 当 APP 启动时，调用 retrievePeripheralsWithIdentifiers: 方法，传入一个包含 Peripheral 标识符的数组来发现和重连先前的 Peripheral，像这样： 12knownPeripherals = [myCentralManager retrievePeripheralsWithIdentifiers:savedIdentifiers]; Central Manager 尝试在先前发现的 Peripheral中去匹配你提供的标识符，然后返回一个包含 CBPeripheral 对象的数组，如果没有匹配的对象，数组将会是空的。你应该去尝试其余的两种方式中的一种。如果数组不是空的，在界面中让用户去选择要重连哪一个。 当用户选择 Peripheral 后，调用 CBCentralManager 类的 connectPeripheral:options: 方法去连接 Peripheral。如果 Peripheral 设备被连接后， Central Manager 会调用 centralManager:didConnectPeripheral: 代理方法，此时 Peripheral 重连成功。 提示：Peripheral 可能因为一些原因不能连接，举个例子，设备不在 Central 附近，此外，一些 BLE 设备使用周期变化的随机设备地址。因此，即使设备在附近，从上次系统发现 Peripheral，设备的地址也可能发生改变，在这种情况下，你尝试连接的 CBPeripheral 对象与实际的 Peripheral 不相符。如果你不能重新连接 Peripheral，因为它的设备地址已经变了，你必须重新调用 scanForPeripheralsWithServices:options: 方法来搜索连接。 关于设备随机地址的详细信息，请查阅 Bluetooth 4.0 规范，第3卷，C部分，10.8 章节和 Bluetooth Accessory Design Guidelines for Apple Products. 恢复当前已连接的 Peripheral 列表另一种重连 Peripheral 的方式就是检查你要连接的 Peripheral 是否一直被系统连接（举例，被另一个 APP 连接），你可以调用 CBCentralManager 类的 retrieveConnectedPeripheralsWithServices: 方法，它返回一个 CBPeripheral 对象的数组，数组中包含当前系统已经连接的 Peripheral。 因为系统当前可能连接超过一个以上的 Peripheral，你可以传入一个 CBUUID 对象的数组来恢复你指定 Service的 Peripheral，如果当前连接的 Peripheral 中没有你指定的 Peripheral，数组将是空的，你应该尝试其余两种方式中的一种。如果数组不为空，在界面中让用户去选择要重连哪一个。 假设用户选择了期望的 Peripheral，通过调用 CBCentralManager 类的 connectPeripheral:options: 方法来本地化连接。即使系统一直连接着设备，你必须本地化连接后再进行交互。当建立了本地连接后，Central Manager 会调用 centralManager:didConnectPeripheral: 代理方法，此时设备重连成功。 参考文献1、Best Practices for Interacting with a Remote Peripheral Device 结束语欢迎在本文下面留言一起交流心得… 如果本文能给你带来一定的帮助，在自己有能力的情况下，不妨赞助一下，表示对博主辛勤耕作的支持！","tags":[{"name":"BLE","slug":"BLE","permalink":"http://yoursite.com/tags/BLE/"}]},{"title":"iOS BLE 开发小记[4] - 如何实现 CoreBluetooth 后台运行模式","date":"2017-05-03T02:45:00.000Z","path":"2017/05/03/iOS-Bluetooth-Low-Energy-Develop-Chapter4/","text":"版权声明：本文为 muhlenXi 原创文章，欢迎转载，转载请注明来源。 导语： 在这一节，主要是 iOS APP 关于蓝牙后台处理方面的知识和经验。 对于 iOS APP 来说，知道你的 APP 是运行在前台还是运行在后台很重要。一个 APP 在后台运行状态下的行为表现必须不同于前台，因为 iOS 设备的系统资源是有限的。关于 iOS 后台运行处理的更多论述 请查阅 Background Execution. 默认情况下，当你的 APP 在 background（后台运行）或者处于 suspended state（暂停状态）时，无论是 Central 端还是 Peripheral 端，许多常见的 CoreBluetooth 任务是不能被执行的。也就是说，你可以声明你的 APP 支持 CoreBluetooth 后台运行模式来允许你的 APP 进入 suspended state 后依然能够唤醒来处理一些蓝牙的事件。即使你的 APP 不需要全面的后台处理支持，但是当有重要事件发生的时候也需要系统给你发出弹框提醒。 即使你的 APP 不管支持哪一个 CoreBluetooth 后台运行模式，它也不能一直在后台运行。在某个时刻，系统会终止你的 APP 来为处于前台的其他 APP 提供内存空间，从而导致一些活动或者连接丢失。比如，对于 iOS 7， CoreBluetooth 支持 Central Manager 和 Peripheral Manager 对象状态信息的保存和在 APP 启动时恢复该状态信息，你可以使用这个功能来支持蓝牙设备的长期操作。 只能前台运行的 APP除非你请求允许执行特定的后台任务，否则对于大多数 iOS APP 来说，当你的 APP 进入 background state（后台状态）不久后就会处于 suspended state（暂停状态）。当你的 APP 处于 suspended state 时是不能执行蓝牙相关的任务，也不能感知到任何蓝牙事件直到重新进入 foreground（前台）。 在 Central 端，没有声明支持 CoreBluetooth 后台运行模式的 APP，也就是只能前台运行的 APP，在 background 和 suspended 状态时，是不能搜索正在广播数据的 Peripheral。在 Peripheral 端，则是不能进行广播数据。此时如果一个 Central 尝试获取 Peripheral Characteristic 的值会收到一个错误。 根据使用情况，这种默认行为可能会以多种方式影响你的 APP，举个例子，试想一下，当你正在与刚连接的 Peripheral 进行数据交互时，此时你的 APP 进入 suspended 状态（当用户切换到另一个 APP时）中，如果 Peripheral 此时失去连接，你是不能感知到已经发生 disconnection（断开连接）事件了，直到你的 APP 重新进入 foreground 为止。 使用 Peripheral Connection options（选项）只在前台运行的 APP 处于 suspended 状态时，系统会将发生的所有蓝牙事件加入队列，只有当 APP 重新进入前台时，才会将事件传递给 APP，也就是说，当 Central 产生事件时，CoreBluetooth 通过弹框提醒的方式通知用户。用户可以通过这个提醒来决定是否将 APP 重新打开来处理这个特定事件。 当调用 CBCentralManager 类的 connectPeripheral:options: 方法连接 Remote Peripheral 时,你可以利用下面这些 Peripheral 连接选项来设置弹框提醒。 CBConnectPeripheralOptionNotifyOnConnectionKey – 如果建立了一个成功的连接，此时 APP 进入 suspended 状态时，如果你想要系统为给定 Peripheral 显示一个弹框，你可以在 options 选项中包含这个键。 CBConnectPeripheralOptionNotifyOnDisconnectionKey – 如果发生了 disconnection 事件，此时 APP 进入 suspended 状态时，如果你想要系统为给定 Peripheral 显示一个弹框，你可以在 options 选项中包含这个键。 CBConnectPeripheralOptionNotifyOnNotificationKey – 如果收到了 Peripheral 的通知，此时 APP 进入 suspended 状态时，如果你想要系统显示一个来自 Peripheral 的通知弹框，你可以在 options 选项中包含这个件。 关于 Peripheral 连接参数的更多信息可以查阅 Peripheral Connection Options 常量。 CoreBluetooth 后台运行模式如果你的 APP 在后台运行状态下也需要执行蓝牙任务，你必须在 Info.plist (Infomation property list) 文件中声明你的 APP 支持 CoreBluetooth 后台运行模式。当你声明后，系统会唤醒 suspended 状态中的 APP 来处理蓝牙事件。这对于和每隔一段时间就传递数据的 BLE 设备进行交互的 APP 来说很重要，比如一个心率监测器。 APP 可能会声明的 CoreBluetooth 后台运行模式有两种。一种是 APP 扮演了 Central 的角色，另一种则是 APP 扮演了 Peripheral 的角色。如果你的 APP 同时扮演了这两种角色，你可以同时声明这两种后台运行模式。声明 CoreBluetooth 后台运行模式的方式就是在 Info.plist 文件中加入一个 UIBackgroundModes 的 Key，Value 则是包含以下提到的两种字符串的数组： bluetooth-central – APP 使用 CoreBluetooth 框架与其他 BLE 设备进行通信。 bluetooth-peripheral – APP 使用 CoreBluetooth 框架来分享数据。 提示：Xcode 的属性列表编辑器默认显示的 Key 是人类易读的字符，而不是实际的 Key 的名字，要在 Info.plist 文件中显示实际 Key 名，按住 Control键并单击编辑器窗口中的任意 Key，并在弹出的上下文窗口中启用 Show Raw Keys/Values 项。比如 UIBackgroundModes 的易读 Key 名则是 Required background modes,如图所示 关于如何配置 Info.plist 文件内容的更多信息请查阅 Xcode help bluetooth-central 后台运行模式当扮演一个 Central 角色的 APP 在 Info.plist 文件中包含了 UIBackgroundModes bluetooth-central 键值对时，CoreBluetooth 框架允许你的 APP 在后台运行时执行蓝牙任务。当你的 APP 在后台运行时，你仍旧可以搜索和连接 Peripheral，然后与之进行数据交互。此外，当 CBCentralManagerDelegate 或者 CBPeripheralDelegate 的代理方法进行回调时，系统会唤醒你的 APP 允许你来处理这些 Central 端的重要事件。比如，成功建立了连接，连接中断，Peripheral 发送了一个更新值的通知，或者 Central Manager 的状态发生改变。 尽管你的 APP 在后台运行时可以执行许多蓝牙任务，但是你要注意这些，在后台运行状态下，当你搜索 Peripheral 的操作是不同于前台运行状态的。特别是当你 APP 在后台运行状态下搜索设备： 搜索参数 CBCentralManagerScanOptionAllowDuplicatesKey将会被忽略，多个广播数据的 Peripheral 发现事件将合并成一个发现事件。 如果所有的都在后台运行中搜索 Peripheral，则 Central 搜索广播数据包的时间间隔将会增加，你发现一个广播数据的 Peripheral 将会需要很长时间。 这种策略对降低 Radio 的使用频率和提高 iOS 设备的续航时间有帮助。 bluetooth-peripheral 后台运行模式Peripheral 想要在后台执行蓝牙任务，你必须在 Info.plist 文件中包含了 UIBackgroundModes bluetooth-peripheral 键值对，这样系统会唤醒你的 APP 来处理读、写和订阅事件。 除了允许你的 APP 唤醒来处理读、写和来自 Central 的订阅请求外，CoreBluetooth 框架还允许你的 APP 在后台运行状态下广播数据。也就是说，你应该注意到，在后台状态下广播数据与在前台状态下的操作是不同的。特别是后台状态下广播数据： 广播的 CBAdvertisementDataLocalNameKey Key 将被忽略，Peripheral 的 local name 也不会广播。 广播中 CBAdvertisementDataServiceUUIDsKey 的值的所有服务 UUID 都被放置在 “overflow” 区域中。只有当 iOS 设备进行显式搜索才会被发现。 如果所有 APP 都在后台运行状态下广播数据，你的 Peripheral 广播数据包的频率将会降低。 谨慎使用后台运行模式对于一般用户情况，可能不需要声明 APP 支持其中一个或两个 CoreBluetooth 后台运行模式，你应该对后台进程负责，因为执行蓝牙的任务需要使用用户设备的 onboard radio（板载广播），使用广播会影响用户设备的续航时间，应尽量减少在后台执行蓝牙任务。APP 被蓝牙时间唤醒后应迅速处理该事件然后尽可能快速的进入 suspended 状态。 声明支持 CoreBluetooth 后台运行模式的 APP 必须遵守一些基本准则： APP 应该提供一个基于会话的界面来允许用户决定什么时候开始和结束发送蓝牙事件。 一个 APP 被唤醒时有 10秒 来完成一个任务，理想地，APP 应该尽快的完成任务然后再次进入 suspended 状态。APP 在后台运行时间太长会被系统限制或杀死。 APP 不应该一直处于唤醒状态来处理与系统唤醒无关的额外任务。 在后台运行状态下，你的 APP 应该如何操作的详情请查阅 Being a Responsible Background App. 在后台执行长期操作一些 APP 可能需要使用 CoreBluetooth 框架来在后台运行状态下执行长期操作，比如，你想要为 iOS 设备开发一个 安全家庭 APP 来与配备 BLE 技术的门锁进行通信。APP 与门锁交互来自动锁门（当用户离开家的时候）和开锁（当用户回家的时候），整个期间 APP 一直在后台运行状态下。当用户离家的时候，iOS 设备终会超出门锁的有效范围，导致与门锁的连接中断。在这种情况下，APP 可以通过调用 CBCentralManager 类的 connectPeripheral:options:该方法来建立连接，因为连接请求不会超时，这样当用户到家的时候就会与门锁重新连接。 现在试想一种情况，当用户离家有一些天了，如果此时 APP 被系统给终止了。这样当用户回家的时候，APP 将不能与门锁重新连接，用户也不能打开门锁了。类似这样的 APP，使用 CoreBluetooth 来执行长期操作至关重要，例如监视活动和挂起连接。 状态保存和恢复因为状态保存和恢复已经内置于 CoreBluetooth，你的 APP 可以选择加入这个功能来要求系统保存 APP 的 Central Manager 和 Peripheral Manager 的状态，并继续代表他们执行蓝牙任务，即使你的 APP 不在运行，当这些任务完成后，系统会重新让你的 APP 进入后台运行状态并给予一定的时间来保存状态和处理一些蓝牙事件。对于上述描述的安全家庭 APP 这种情况来说，系统将会监听连接请求，当用户回家的时候，系统将会重新启动 APP 来处理 centralManager:didConnectPeripheral: 代理回调和完成连接请求。 CoreBluetooth 对 扮演 Central 角色，Peripheral 角色，或者同时都扮演的 APP 都提供状态保存和恢复支持。当扮演 Central 角色的 APP 增加状态保存和恢复时，当系统释放内存空间需要终止你的 APP 时，会保存你的 Central Manager 的状态，如果你的 APP 拥有多个 Central Manager，你可以选择你想要系统跟踪的 Central Manager，尤其，对于给定的 CBCentralManager 对象，系统会跟踪： Central Manger 搜索的 Service（和一些一开始指定搜索参数选项的） Central Manager 尝试连接或者已经连接的 Peripheral Central Manager 订阅的 Characteristic 扮演 Peripheral 角色的 APP 同样可以使用状态保存与恢复。对于 CBPeripheralManager 对象,系统会跟踪： Peripheral Manager 广播的数据 Peripheral Manager 发布到设备库中的 Services 和 Characteristics 被 Central 订阅的 Characteristic 的值 当你的 APP 被系统置入后台运行状态时，你可以重新实例化 APP 的 Central Manager 和 Peripheral Manager 并恢复他们的状态。下面的章节会详细的描述如何在你的 APP 中使用状态保存和恢复。 添加状态保存和恢复支持CoreBluetooth 的状态保存和恢复是选择性加入的功能，需要以下步骤来让 APP 这一功能生效，你可以参考下面的步骤来给你的 APP 增加状态保存和恢复功能： 1、（必须的）当你 allocate 和 initialize 一个 Central Manager 或 Peripheral Manager 对象时需要加入状态保存和恢复。这一步在 选择加入状态与恢复 小节有详细描述。 2、（必须的）当系统启动 APP 的时候需要重新实例化一些 Central Manager 或 Peripheral Manager 对象。这一步在 重新实例化你的 Central Manager 和 Peripheral Manager 小节有详细描述。 3、（必须的） 实现恰当的代理方法。这一步在 实现恰当的 Restoration Delegate 方法 小节有详细描述。 4、（可选的）更新你的 Central Manager 或 Peripheral Manager 的初始化进程。这一步在 更新你的初始化进程 小节中有详细描述。 选择加入状态保存与恢复选择加入状态保存和恢复功能后，当你 allocate 和 initialize 一个 Central Manager 或者 Peripheral Manager 的时候，你需要提供一个唯一的恢复标识符。恢复标识符是一个标识 Central Manager 或者 Peripheral Manager 的字符串，字符串的值对你的代码很重要，它将会告诉 CoreBluetooth 需要保存使用该标记的对象，CoreBluetooth 只保存这些拥有恢复标识符的对象。 举个例子，为你的 APP （只有一个 CBCentralManager 对象的 Central ）选择加入状态保存和恢复，当你初始化 Central Manager 的时候需要指定 options（初始化选项），选项是一个以 CBCentralManagerOptionRestoreIdentifierKey 为 key，Value 是 恢复标识符 的字典。示例代码如下： 1234567891011121314151617181920212223242526myCentralManager = [[CBCentralManager alloc] initWithDelegate:self queue:nil options:@&#123; CBCentralManagerOptionRestoreIdentifierKey: @\"myCentralManagerIdentifier\" &#125;];``` 虽然上述例子没有证明这一点，当你给使用 Peripheral Manager 对象的 APP 选择加入状态保存与恢复时应使用类似的方式：在你初始化 Peripheral Manager 的时候指定 options（初始化选项），参数是一个以 `CBCentralManagerOptionRestoreIdentifierKey` 为 key，以 *恢复标识符*字符串为 value 的字典。提示：*因为一个 APP 可能拥有多个 CBCentralManager 和 CBPeripheralManager 对象的实例，你应该确保他们的恢复标识符是唯一的，这样系统就能正确地区分它们。*##### 重新实例化你的 Central Manager 和 Peripheral Manager当你的 APP 被系统从后台启动时，你需要做的第一件事就是用状态恢复标识符重新实例化合适的 Central Manager 和 Peripheral Manager,恢复标识符要跟它们第一次被创建的一样。如果你的 APP 仅仅用到了一个 Central Manager 或者 Peripheral Manager，并且该 Manager 在你的 APP 生命周期中还存活着，则你就不需要做这一步。如果你的 APP 使用超过一个以上的 Central Manager 或者 Peripheral Manager，或者使用的 Manager 在 APP 的生命周期中已经死亡了。当你的 APP 被系统启动时，它需要知道要恢复哪一个 Manager 。你可以通过 APP 终止时保存的 Manager 对象的恢复标识符列表，使用合适的 launch option（启动选项）参数（`UIApplicationLaunchOptionsBluetoothCentralsKey` 或者 ` UIApplicationLaunchOptionsBluetoothPeripheralsKey`）在 `application:didFinishLaunchingWithOptions:` 代理方法回调中来获取恢复标识符数组。举个例子，当系统启动 APP 时，你可以恢复所有 Central Manager 的恢复标识符，示例代码如下：```objc- (BOOL)application:(UIApplication *)applicationdidFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; NSArray *centralManagerIdentifiers = launchOptions[UIApplicationLaunchOptionsBluetoothCentralsKey]; // ...&#125; 当你获得恢复标识符列表后，遍历这个数组来重新实例化合适的 Central Manager 对象。 提示：当 APP 启动时，系统只会提供要执行一些蓝牙任务（此时 APP 没有在运行）的 Central Manager 和 Peripheral Manager 的恢复标识符。关于启动选项参数 Keys 的详情可以参考 UIApplicationDelegate Protocol Reference. . 实现恰当的 Restoration Delegate 方法当你恢复合适的 Central Manager 和 Peripheral Manager 后，然后将他们的状态与蓝牙系统的状态同步。为了使你的 APP 达到系统处理的速度，你必须实现恰当的 Restoration Delegate 方法，对 Central Manager ，需要实现 centralManager:willRestoreState: 代理方法，而对于 Peripheral Manager,则需要实现 peripheralManager:willRestoreState: 代理方法。 重要提示：对于选择添加 CoreBluetooth 的状态保存与恢复的 APP，当 APP 从后台启动来完成一些蓝牙任务时，会第一个调用 centralManager:willRestoreState: 和 peripheralManager:willRestoreState: 代理方法，对于没有加入状态与恢复的 APP，会第一个调用 centralManagerDidUpdateState: 和 peripheralManagerDidUpdateState: 代理方法。 以上提到的这些代理方法，最后一个参数是一个字典，该字典包含 APP 终止时系统保存的 Manager 的信息。字典中可用的 Keys，可以查阅 Central Manager State Restoration Options 和 Peripheral_Manager_State_Restoration_Options 常量。 用 centralManager:willRestoreState: 代理方法提供的字典的 Key 来恢复 CBCentralManager 对象的状态。举个例子，如果你的 Central Manager 拥有激活的或者中断的连接（APP 终止时），系统会继续监视 APP 的行为，如下所示，你可以通过 CBCentralManagerRestoredStatePeripheralsKey Key 去得到 Central Manager 连接的或者尝试连接的 Peripheral 列表（用 CBPeripheral 对象表示）。 1234567- (void)centralManager:(CBCentralManager *)central willRestoreState:(NSDictionary *)state &#123; NSArray *peripherals = state[CBCentralManagerRestoredStatePeripheralsKey]; // ...&#125; 当你获得 Peripheral 列表后然后干什么取决于使用情况。举个例子，如果 APP 有一个 Central Manager 搜索的 Peripheral 列表，你可能想把恢复的 Peripheral 加入该列表中。此时确保要设置 Peripheral 的 Delegate 以保证能收到合适的代理回调。 你可以通过类似的方法利用 peripheralManager:willRestoreState: 代理方法提供的字典的 keys 来恢复 CBPeripheralManager 的状态。 更新你的初始化进程当你实现前面必须的步骤后，你可能想要查看 Central Manager 和 Peripheral Manager 的初始化进程。尽管这是一个可选的步骤，但对确保 APP 稳定运行很重要。举个例子，当正与连接的 Peripheral 数据传输到一半时，APP 终止了。当你的 APP 恢复这个 Peripheral 时，你不知道 APP 终止时数据处理到哪一步，你想要确定从哪里继续开始处理。 举个例子，当在 centralManagerDidUpdateState: 代理方法中初始化 APP 时，如果你能够成功的从一个恢复的 Peripheral中找出指定的 Service（在 APP 终止之前），就像这样 12345678910NSUInteger serviceUUIDIndex = [peripheral.services indexOfObjectPassingTest:^BOOL(CBService *obj, NSUInteger index, BOOL *stop) &#123; return [obj.UUID isEqual:myServiceUUIDString]; &#125;]; if (serviceUUIDIndex == NSNotFound) &#123; [peripheral discoverServices:@[myServiceUUIDString]]; // ...&#125; 以上示例中，如果系统在你调用 discoverServices: 方法完成 Service 搜索之前终止。如果 APP 搜索 Service 成功，你可以稍后查看是否发现合适的 Characteristic（一直订阅的） ，用这种方式来更新初始化进程，你需要在正确的时间调用正确的方法。 参考文献1、Core Bluetooth Background Processing for iOS Apps 结束语欢迎在本文下面留言一起交流心得… 如果本文能给你带来一定的帮助，在自己有能力的情况下，不妨赞助一下，表示对博主辛勤耕作的支持！","tags":[{"name":"BLE","slug":"BLE","permalink":"http://yoursite.com/tags/BLE/"}]},{"title":"iOS BLE 开发小记[3] - 如何实现一个 Local Peripheral","date":"2017-05-01T02:45:00.000Z","path":"2017/05/01/iOS-Bluetooth-Low-Energy-Develop-Chapter3/","text":"版权声明：本文为 muhlenXi 原创文章，欢迎转载，转载请注明来源。 导语： 在这一节，你将会学到，如何通过 CoreBluetooth 框架来实现 Local Peripheral 方面的功能和代理方法。 在 iOS BLE 开发小记[2]中，你已经学到了如何在 Central 方面去调用 BLE 的常用方法。在这一节中，你将学习用 CoreBluetooth 框架来调用 Peripheral 方面 BLE 的常用方法。通过本文的示例代码，将会引导你开发一个将你的 Local 设备实现为 Local Peripheral。你将会从中学到： 如何创建一个 Peripheral Manager 对象 如何为你的 Local Peripheral 设置 Services 和 Characteristics 如何发布你的 Services 和 Characteristics 数据 如何广播你的设备 如何对连接的 Central 做读写请求响应 如何发送更新后的值给订阅的 Central 或许你发现示例代码过于简单和抽象，你需要在你的 App 中做些恰当的练习来掌握这些内容。更高级的技巧和最佳实践在后续的文章中将会讲解。 Peripheral 实现详情创建一个 Peripheral Manager 对象在 Local Device（当前设备）实现 Peripheral 规范的第一步是分配（allocate）和初始化（initialize）一个周边管理（Peripheral Manager），（用 CBPeripheralManager 对象表示），通过调用 CBPeripheralManager 的 initWithDelegate:queue:options: 方法来创建管理对象，如下所示 12myPeripheralManager = [[CBPeripheralManager alloc] initWithDelegate:self queue:nil options:nil]; 在示例代码中，设置 Delegate 为 self 是为了接收 Peripheral 的事件响应，将参数 dispatch queue 置为 nil。意味着 Peripheral Manager 将会在主队列中分发事件。 当你创建一个 Peripheral Manger 对象时，Peripheral Manager 会通过 peripheralManagerDidUpdateState: 方法来代理回调，你必须实现这个代理方法来确保当前设备是否支持 BLE 技术，关于代理方法的详情可以查阅 CBPeripheralManagerDelegate Protocol Reference. 设置你的 Services 和 Characteristics在第一节中，我们了解到，一个 Local Peripheral 采用树形结构来组织 Services 和 Characteristics 的数据。因此必须采用树形结构方式来设置 Local Peripheral 的 Services 和 Characteristics。你第一步要做的是搞清和理解 Service 和 Characteristic 是如何标识的。 通过 UUID 标识 Services 和 CharacteristicsPeripheral 的 Service 和 Characteristic 是通过 128 位的特定蓝牙 UUID（通用唯一识别码）来标识的，在 CoreBluetooth 中是用 CBUUID 对象来表示的。并不是所有的 UUID 都是通过 Bluetooth Special Interest Group （蓝牙特别兴趣小组）预定义的。为了方便起见，Bluetooth SIG 定义和发布了许多通用的 16位 UUID。举个例子，Bluetooth SIG 事先定义了一个16位的 UUID 用来标识一个心率 Service，该 UUID 是 128位 UUID 0000180D-0000-1000-8000-00805F9B34FB 进行缩减而来的，这是基于蓝牙 4.0 规范中，第 3 卷 F 部分第 3.2.1 节定义的蓝牙基础 UUID。 CBUUID 提供了一个处理比较长的 UUID 的工厂方法，举个例子，生成一个表示心率 Service 的 UUID，可以调用 UUIDWithString 方法来通过预定义的 16位 UUID来创建 CBUUID 对象。 1CBUUID *heartRateServiceUUID = [CBUUID UUIDWithString: @\"180D\"]; 当你通过预定义的 16位 UUID 来创建 CBUUID 对象时，CoreBluetooth 会基于128位Bluetooth Base UUID 填充剩下的的 UUID 位。 为你定制的 Services 和 Characteristics 生成 UUID你的 Service 和 Characteristic 的UUID也许可能没有被 Bluetooth UUIDs 预定义，如果没有被预定义，你需要手动生成你自己的 128位 UUID 来表示 Service 和 Characteristic。 通过命令行命令 uuidgen 可以生成 128位的 UUID，打开你的 Terminal（终端），通过这种方式依次为你的 Services 和 Characteristics 生成一个 UUID （用连字符连接起来的字符串）来标识。举例如下： 12$ uuidgen71DA3FD1-7E10-41C1-B16F-4430B506CDE7 你可以用上面方法生成的 UUID 调用 UUIDWithString 方法来创建一个 CBUUID 对象。 12CBUUID *myCustomServiceUUID = [CBUUID UUIDWithString:@\"71DA3FD1-7E10-41C1-B16F-4430B506CDE7\"]; 构建你的 服务特征树当你为每个 Service 和 Characteristic 创建 CBUUID 对象后，你可以创建 mutable Service（可变服务） 和 mutable Characteristic（可变特征），然后以树形的方式组织它们。举个例子，如果你现在有一个 Characteristic 的 UUID，你可以通过调用 CBMutableCharacteristic 类的 initWithType:properties:value:permissions: 方法生成一个 mutable Characteristic。 1234myCharacteristic = [[CBMutableCharacteristic alloc] initWithType:myCharacteristicUUID properties:CBCharacteristicPropertyRead value:myValue permissions:CBAttributePermissionsReadable]; 当你创建 mutable Characteristic 的时候，你可以指定它的 properties（属性）、value（值）和 permissions（权限许可），你指定的 properties 和 permissions 决定这个 Characteristic 的值是否可以读或者写，或者连接的 Central 能否订阅该 Characteristic 的值。下面的示例中，Characteristic 的值是被指定为可读的。关于 mutable Characteristic 的 properties 和 permissions 详情可以查阅 CBMutableCharacteristic Class Reference. 提示：如果你指定了 Characteristic 的值，那么该值将被缓存并且该 Characteristic 的 properties 和 permissions 将被设置为可读的。因此，如果你需要 Characteristic 的值是可写的，或者你希望在 Service 发布后，Characteristic 的值在 lifetime（生命周期）中依然可以更改，你必须将该 Characteristic 的值指定为 nil。通过这种方式可以确保 Characteristic 的值,在 Peripheral Manager 收到来自连接的 Central 的读或者写请求的时候，能够被动态处理。 既然你创建了一个 mutable Characteristic，你也能通过调用 CBMutableService 类的 initWithType:primary: 方法创建一个 mutable Service。如下所示： 1myService = [[CBMutableService alloc] initWithType:myServiceUUID primary:YES]; 在示例代码中，第二个参数被指定为 YES，用来表明该 Service 是 Primary（主要的），而不是 secondary（次要的）。一个 Primary Service 用来描述这个设备的主要功能，还可以用来引用其他的 Service。一个 Secondary Service 用来描述的是上下文中相关的或者被引用的 Service。举个例子，从心率传感器中获取心率的服务是 primary Service，而获取传感器电量的服务就可以被视为 secondary Service 。 当你创建完 Service 后。你需要设置 Service 的 Characteristic 数组属性，如下： \u00101myService.characteristics = @[myCharacteristic]; 发送你的 Services 和 Characteristics当你构建好服务特征树后，下一步就是按照 BLE 的规范发布到设备的服务特征库中，用 CoreBluetooth 可以很轻松的完成这一步，只需要调用 CBPeripheralManager类 的 addService: 方法就可以了。 示例代码如下： 1[myPeripheralManager addService:myService]; 当你调用该方法发布服务时，Peripheral Manager 会调用 peripheralManager:didAddService:error: 方法进行代理回调，实现这个代理方法可以获取到产生的错误，示例代码如下： 123456789- (void)peripheralManager:(CBPeripheralManager *)peripheral didAddService:(CBService *)service error:(NSError *)error &#123; if (error) &#123; NSLog(@\"Error publishing service: %@\", [error localizedDescription]); &#125; // ...&#125; 提示：当你发布 Service 和相关的 Characteristic 到 Peripheral 的数据库中后，设备已经将数据缓存，你不能再改变它了。 广播你的 Service当你发布你的 Service 和 Characteristic 到设备的服务特征库时，你可以广播一些服务给正在监听的 Central，你可以通过调用 CBPeripheralManager 类的 startAdvertising: 方法来开始广播，传入的字典是要广播的数据。 12[myPeripheralManager startAdvertising:@&#123; CBAdvertisementDataServiceUUIDsKey : @[myFirstService.UUID, mySecondService.UUID] &#125;]; 在示例代码中，传入的字典中唯一的 key 是 CBAdvertisementDataServiceUUIDsKey,用一个包含 CBUUID 对象的数组来表示你想要广播的服务的 UUID。你在字典中可以指定的其他 key 在 Advertisement Data Retrieval Keys 中有详细说明。也就是说，仅有 CBAdvertisementDataLocalNameKey 和 CBAdvertisementDataServiceUUIDsKey 这两个 key 支持 Peripheral Manager 对象。 当你在本地设备中广播一些数据时，Peripheral Manager 会通过 peripheralManagerDidStartAdvertising:error: 方法来代理回调。如果你的设备不能广播而发生错误时，实现这个代理方法可以获取产生的错误： \u001012345678- (void)peripheralManagerDidStartAdvertising:(CBPeripheralManager *)peripheral error:(NSError *)error &#123; if (error) &#123; NSLog(@\"Error advertising: %@\", [error localizedDescription]); &#125; // ...&#125; 提示：广播数据方法会被尽力执行，因为空间是有限的和多个 APP 可能同时需要广播数据，更多详情可以查阅关于 startAdvertising: 方法的讨论。 当你的 APP 在后台运行时也会影响广播的行为，这一内容将会在下一篇中进行讨论。 响应 Central 的读写请求当你连接一个或多个 Central 后，你可能会收到读或者写的请求，对这些请求作出响应需要采取恰当的方式，下面的示例代码将会描述如何处理这些请求。 当一个连接的 Central 发送读取某个 Characteristic 数据的请求时，Peripheral Manager 会调用 peripheralManager:didReceiveReadRequest: 方法进行代理回调。代理方法以 CBATTRequest 对象的方式来传递请求，它包含一些请求的属性。 比如，当你收到一个读取 Characteristic 值的简单请求时，可以通过代理方法回调的 CBATTRequest 对象来判断 Central 指定要读取的 Characteristic 是否和设备服务库中的 Characteristic 是否相匹配。你可以开始实现这个代理方法，示例代码如下： 1234567- (void)peripheralManager:(CBPeripheralManager *)peripheral didReceiveReadRequest:(CBATTRequest *)request &#123; if ([request.characteristic.UUID isEqual:myCharacteristic.UUID]) &#123; // ... &#125;&#125; 如果 Characteristic 的 UUID 能够匹配，下一步就是确保读取请求的位置没有超出 Characteristic 的值的边界。如下面代码所示，你可以通过使用 CBATTRequest 对象的 offset 属性来确保读取请求没有尝试读取范围之外的数据。 12345if (request.offset &gt; myCharacteristic.value.length) &#123; [myPeripheralManager respondToRequest:request withResult:CBATTErrorInvalidOffset]; return;&#125; 假如读取请求的 offset（偏移）已经确认，现在就可以设置请求的 Characteristic 的属性（默认值为 nil）为你设备中的 Characteristic 的值了，你应该重视读取请求的偏移： 123request.value = [myCharacteristic.value subdataWithRange:NSMakeRange(request.offset, myCharacteristic.value.length - request.offset)]; 设置完值后，通过调用 respondToRequest:withResult: 方法并传入 request（更新值后的）和 请求的结果参数来对 Remote Central 的请求作出响应表示请求已经被成功处理。示例代码如下： 12[myPeripheralManager respondToRequest:request withResult:CBATTErrorSuccess];// ... 只要代理方法 peripheralManager:didReceiveReadRequest: 方法被回调，就需要准确的调用 respondToRequest:withResult: 方法。 提示：如果 Characteristic 的 UUID 不匹配，或者因为某种原因不能完全读取，不必去填充请求，直接调用 respondToRequest:withResult: 方法并提供一个表示失败的结果即可。你可能指定的结果列表见 CBATTError Constants 常量枚举。 处理连接的 Central 写入请求也比较易懂。当 Central 发送一个写入请求给一个或多个你的 Characteristic 时，Peripheral Manager 会通过 peripheralManager:didReceiveWriteRequests: 方法来代理回调。这是，代理方法会传递一个包含一个或多个 CBATTRequest 对象的数组给你，数组中的每个对象都代表一个写入请求。当你确定写入请求能够处理时，你可以设置 Characteristic 的值，示例代码如下： \u00101myCharacteristic.value = request.value; 虽然上述例子没有证明这一点，但当你给 Characteristic 写数据的时候，你应该确保请求的 offset 属性的范围有效。 就像你响应读取请求一样，只要代理方法 peripheralManager:didReceiveWriteRequest: 方法被回调，就需要准确无误的调用 respondToRequest:withResult: 方法。也就是说，respondToRequest:withResult: 方法期望有一个 CBATTRequest 对象，即使你可能通过 peripheralManager:didReceiveWriteRequests: 代理方法接收到一个包含 CBATTRequest 对象的数组，你也应该传入数组中的第一个对象，示例代码如下： 12[myPeripheralManager respondToRequest:[requests objectAtIndex:0] withResult:CBATTErrorSuccess]; 提示：将多请求视为单一请求来对待，如果个别的请求不能被填充，你就不必填充其余的请求了，直接调用 respondToRequest:withResult: 方法并提供一个表示失败的结果即可。 发送更新 Characteristic 的通知给订阅的 Central连接的 Central 经常会订阅一个或多个 Characteristic 的值，当这些值发生变化时，你应该发送通知给订阅的 Central 。 当一个连接的 Central 订阅一个或多个你的 Characteristic 值时，Peripheral Manager 会通过 peripheralManager:central:didSubscribeToCharacteristic: 方法来代理回调。示例代码如下： 1234567- (void)peripheralManager:(CBPeripheralManager *)peripheral central:(CBCentral *)centraldidSubscribeToCharacteristic:(CBCharacteristic *)characteristic &#123; NSLog(@\"Central subscribed to characteristic %@\", characteristic); // ...&#125; 将上述的代理方法作为一个线索来开始给 Central 发送更新后的值。 接着，获取更新后的 Characteristic 的值，通过调用 CBPeripheralManager类的 updateValue:forCharacteristic:onSubscribedCentrals: 方法来给 Central 发送通知。示例代码如下： 123NSData *updatedValue = // fetch the characteristic's new valueBOOL didSendValue = [myPeripheralManager updateValue:updatedValue forCharacteristic:characteristic onSubscribedCentrals:nil]; 当你调用这个方法给订阅的 Central 发送通知时，你可以通过最后的那个参数来指定要发送的 Central，示例代码中的参数为 nil，表明将会发送通知给所有连接且订阅的 Central，没有订阅的 Central 则会被忽略。 updateValue:forCharacteristic:onSubscribedCentrals: 方法会返回一个 Boolean 类型的值来表示通知是否成功的发送给订阅的 Central 了，如果 base queue （基础队列）满载，该方法会返回 NO，当传输队列存在更多空间时，Peripheral Manager 则会调用 peripheralManagerIsReadyToUpdateSubscribers: 代理方法进行回调。你可以实现这个代理方法，在方法中再次调用 updateValue:forCharacteristic:onSubscribedCentrals: 方法发送通知给订阅的 Central。 提示：用通知发送单个数据包给订阅的 Central，就是说，一旦订阅的 Central 发生更新时，你就应该调用 updateValue:forCharacteristic:onSubscribedCentrals: 方法用单一通知发送全部的更新值。 并不是所有的数据都是通过通知来传输的，这主要取决于你的 Characteristic 的值的大小，只有当 Central 调用CBPeripheral类的 readValueForCharacteristic: 方法时，你可以检索全部的值。 参考文献1、Performing Common Peripheral Role Tasks 结束语欢迎在本文下面留言一起交流心得… 如果本文能给你带来一定的帮助，在自己有能力的情况下，不妨赞助一下，表示对博主辛勤耕作的支持！","tags":[{"name":"BLE","slug":"BLE","permalink":"http://yoursite.com/tags/BLE/"}]},{"title":"iOS BLE 开发小记[2] - 如何实现一个 Local Central","date":"2017-04-29T02:45:00.000Z","path":"2017/04/29/iOS-Bluetooth-Low-Energy-Develop-Chapter2/","text":"版权声明：本文为 muhlenXi 原创文章，欢迎转载，转载请注明来源。 导语： 在这一节，你将会学到，如何通过 CoreBluetooth 框架来实现 Local Central 方面的功能和代理方法。 在 BLE 通信中，实现了 Central 规范的设备，能够调用许多常用的方法，比如搜索和连接可用的 Peripheral，然后与 Peripheral 提供的数据进行交互。但是实现了 Peripheral 规范的设备同样能够调用许多常见的方法，但是也有一些不同。比如，发布和广播 Service，对 Central 的读写请求进行响应以及 响应Central 的订阅请求。 在这个章节中，你将会学习在 Central 端如何使用 Core Bluetooth 框架来执行通用的 BLE 方法。基于代码的示例将会引导和协助你在你的本地设备上实现 Central 的角色。尤其，你将会学到： 如何创建一个 Central Manager 对象 如何搜索和连接一个正在广播信息的 Peripheral 连接成功后如何与 Peripheral 的数据进行交互 如何发送读取或写入请求给 Peripheral Service 的 Characteristic 如何订阅一个当数据更新时就会发出通知的 Characteristic 在下个章节，你将会学习如何在你的本地设备上实现 Peripheral 的角色。 你也许会发现本章节中的代码有点简单和抽象，在你的真实 App 中，你需要做些恰当的改变。更高级的开发技能可以参考后续的章节。 Central 实现详情在本文中，你的 ViewController 需要遵循 CBCentralManagerDelegate 和 CBPeripheralDelegate 代理协议。 创建 Central Manager因为在 CoreBluetooth 中是通过面向对象的思想用一个 CBCentralManager（中心管理） 对象来表示一个 Local Central 设备，所以在调用该对象的方法之前需要先 allocate（分配）和 initialize（初始化）一个 Central Manager 实例。可以通过 initWithDelegate:queue:options: 方法来初始化一个 Central Manager 对象。 12myCentralManager = [[CBCentralManager alloc] initWithDelegate:self queue:nil options:nil]; 在示例代码中，设置 Central Manager 的 Delegate 为 self，是为了接收 Central 的事件响应。 参数 dispatch queue（调度队列）设置为 nil，表示 Central Manager 是在 main queue（主队列）中分发响应事件。 当你创建一个 Central Manager 对象时，Central Manager 会调用 centralManagerDidUpdateState: 方法来代理回调。因此你必须实现这个代理方法来确保 Central 设备能够使用 BLE 技术,代理方法的详情见 CBCentralManagerDelegate Protocol Reference。 搜索正在广播数据的 Peripheral 设备初始化 Central Manger 对象后，第一个任务就是搜索周围的 Peripheral，上一篇曾提到过， Peripheral 通过广播数据的方式来显示它们的存在，你可以通过 scanForPeripheralsWithServices:options: 方法来搜索周围正在广播数据的 Peripheral 设备。 1[myCentralManager scanForPeripheralsWithServices:nil options:nil]; 关于参数说明：如果第一个参数置为 nil 时，Central Manager 会返回所有正在广播数据的 Peripheral 设备。在实际 APP 开发中，通过指定一个包含 CBUUID 对象的数组来获取指定的 Peripheral，其中用一个 UUID（通用唯一识别码）来表示 Peripheral 正在广播的一个服务。关于 CBUUID 对象的详情见 Services and Characteristics Are Identified by UUIDs. 每当 Central Manager 搜索到一个 Peripheral 设备时，就会通过 代理方法 centralManager:didDiscoverPeripheral:advertisementData:RSSI: 进行回调，新发现的 Peripheral 会以 CBPeripheral 对象的方式返回。如果你后面需要连接这个 Peripheral，需要用一个 CBPeripheral 类型的 Strong Reference（强引用）来指向这个对象，这样系统暂时就不会释放这个对象了。 123456789- (void)centralManager:(CBCentralManager *)central didDiscoverPeripheral:(CBPeripheral *)peripheral advertisementData:(NSDictionary *)advertisementData RSSI:(NSNumber *)RSSI &#123; NSLog(@\"Discovered %@\", peripheral.name); self.discoveredPeripheral = peripheral; // ...&#125; 当你需要连接多个 Peripheral 设备时，需要使用一个 NSArray 来保存这些搜索到的 Peripheral，不管怎样，为了减少电量损耗，增加续航时间，只要搜索到你需要连接的 Peripheral 时，就可以停止搜索了。通过下面的方法可以停止搜索了。 1[myCentralManager stopScan]; 连接刚发现的 Peripheral 设备可以调用 connectPeripheral:options: 方法来连接你想要连接的 Peripheral 设备。 1[myCentralManager connectPeripheral:peripheral options:nil]; 如果连接成功，Central 会通过 centralManager:didConnectPeripheral: 方法进行代理回调。在你与 Peripheral 进行交互时，你需要设置 Peripheral 的 Delegate 为 self 来确保能收到 Peripheral 的代理回调。 1234567- (void)centralManager:(CBCentralManager *)central didConnectPeripheral:(CBPeripheral *)peripheral &#123; NSLog(@\"Peripheral connected\"); peripheral.delegate = self; // ...&#125; 搜索刚连接 Peripheral 的 Service当与 Peripheral 成功建立连接后，你就可以获取 Peripheral 的 Service 数据了，第一步就是搜索 Peripheral 提供的可用 Service。因为 Peripheral 对广播的数据包大小有限制，所以你可能会搜索到除了广播的 Service 之外的 其他 Service，你可以通过 discoverServices: 方法搜索 Peripheral 提供的所有的 Service。 1[peripheral discoverServices:nil]; 提示：在实际开发中，传入的参数一般不为 nil，传入 nil 会返回全部的可用 Service，为了节省电量以及一些不必要的时间浪费，通过指定一个 Service Array（包含 UUID 对象）为参数，来获取你想要了解的 Service 的信息，详情见 Explore a Peripheral’s Data Wisely. 当搜索到指定的 Service 时，Peripheral 对象会通过 peripheral:didDiscoverServices: 方法进行代理回调。CoreBluetooth 会生成一个数组用来保存 CBService 对象，你指定的 Service 就被包含在这个数组中。你可以通过实现下面这个代理方法来获取 Service 数组。 123456789- (void)peripheral:(CBPeripheral *)peripheraldidDiscoverServices:(NSError *)error &#123; for (CBService *service in peripheral.services) &#123; NSLog(@\"Discovered service %@\", service); // ... &#125; // ...&#125; 搜索 Service 的 Characteristic当你找到指定的 Service 之后，你下一步要做的就是搜索这个 Service 中提供的所有的 Characteristic，通过调用 discoverCharacteristics:forService: 方法来搜索指定的 Service 的 Characteristic。 1[peripheral discoverCharacteristics:nil forService:interestingService]; 提示：在实际开发中，第一个参数一般不传入 nil，因为你需要的 Characteristic 也许是所有 Characteristic 的一部分，为了节省电量以及一些不必要的时间浪费，通常指定一个 Characteristic Array（包含 UUID 对象）为参数，来获取你想要了解的 Characteristic 的信息。 当搜索到指定的 Characteristic 后， Peripheral 会通过 peripheral:didDiscoverCharacteristicsForService:error: 方法进行代理回调，CoreBluetooth 会创建一个包含 CBCharacteristic 对象的数组用来保存指定的 Characteristic，如下是遍历数组中的 Characteristic。 12345678910- (void)peripheral:(CBPeripheral *)peripheraldidDiscoverCharacteristicsForService:(CBService *)service error:(NSError *)error &#123; for (CBCharacteristic *characteristic in service.characteristics) &#123; NSLog(@\"Discovered characteristic %@\", characteristic); // ... &#125; // ...&#125; 检索 Characteristic 的值读取某个 Characteristic 的值当你找到 Service 指定的 Characteristic，可以通过 readValueForCharacteristic: 方法来读取这个 Characteristic 的值。 12NSLog(@\"Reading value for characteristic %@\", interestingCharacteristic);[peripheral readValueForCharacteristic:interestingCharacteristic]; 当你尝试去读取一个 Characteristic 的值时， Peripheral 会通过 peripheral:didUpdateValueForCharacteristic:error: 代理回调来返回结果，你可以通过 Characteristic 的 value 属性来得到这个值。 12345678- (void)peripheral:(CBPeripheral *)peripheraldidUpdateValueForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error &#123; NSData *data = characteristic.value; // parse the data as needed // ...&#125; 提示：并不是所有的 Characteristic 的值都是可读的，决定一个 Characteristic 的值是否可读是通过检查 Characteristic 的 Properties 属性是否包含 CBCharacteristicPropertyRead 常量来判断的。当你尝试去读取一个值不可读的 Characteristic 时，Peripheral 会通过 peripheral:didUpdateValueForCharacteristic:error: 给你返回一个合适的错误。 订阅一个 Characteristic 的值通过 readValueForCharacteristic: 方法读取一个 Characteristic 的静态值是有效的，但是，对于动态的值，就不是一个有效的方法，因为 Characteristic 的值在实时改变，比如你的心率数据。只有通过订阅才能获取实时的改变值，当你订阅一个 Characteristic 的值时，每当这个值发生改变时，你就会收到一个通知。 通过 \u0010setNotifyValue:forCharacteristic: 方法可以订阅指定 Characteristic 的值，该方法的第一个参数需要指定为 YES。 1[peripheral setNotifyValue:YES forCharacteristic:interestingCharacteristic]; 当你订阅或取消订阅一个 Characteristic 的值时，Peripheral 会通过调用 peripheral:didUpdateNotificationStateForCharacteristic:error: 方法进行代理回调，如果订阅失败了，你可以通过这个方法获取到发生错误的原因。 12345678910- (void)peripheral:(CBPeripheral *)peripheraldidUpdateNotificationStateForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error &#123; if (error) &#123; NSLog(@\"Error changing notification state: %@\", [error localizedDescription]); &#125; // ...&#125; 提示：并不是所有的 Characteristic 都提供订阅功能，决定一个 Characteristic 是否能订阅是通过检查 Characteristic 的 properties 属性是否包含 CBCharacteristicPropertyNotify 或者 CBCharacteristicPropertyIndicate 常量来判断的。 写数据到 Characteristic 中有时需要写入一个数据到 Characteristic 中，比如，如果你的 APP 与数字恒温器进行交互。你或许想要给数字恒温器提供一个值，使得房间的室温能保持在这个温度左右。如果一个 Characteristic 的值是可写的，你可以通过调用 writeValue:forCharacteristic:type: 方法将一个 data 类型（NSData 对象）的值写入到 Characteristic 中。 123NSLog(@\"Writing value for characteristic %@\", interestingCharacteristic);[peripheral writeValue:dataToWrite forCharacteristic:interestingCharacteristic type:CBCharacteristicWriteWithResponse]; 当你写一个数据到 Characteristic 中时，你可以指定写入类型，上面代码中的写入类型是 CBCharacteristicWriteWithResponse ，此类型时，Peripheral 会通过 peripheral:didWriteValueForCharacteristic:error: 方法来代理回调告知你是否写入数据成功，可以实现下面这个代理方法进行错误处理。 12345678910- (void)peripheral:(CBPeripheral *)peripheraldidWriteValueForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error &#123; if (error) &#123; NSLog(@\"Error writing characteristic value: %@\", [error localizedDescription]); &#125; // ...&#125; 如果你指定写入类型为 CBCharacteristicWriteWithoutResponse 时，不能保证写入操作是否有效的执行了。这时 Peripheral 不会调用任何代理方法，如果想了解 CoreBluetooth 提供的写入类型详情，可以查阅 CBCharacteristicWriteType. 提示：有的 Characteristic 的值可能仅仅是可写的，或者不是可写的。决定 Characteristic 的值是否可写，需要通过查看 Characteristic 的 properties 属性是否包含 CBCharacteristicPropertyWriteWithoutResponse 或者 CBCharacteristicPropertyWrite 常量来判断的。 参考文献1、Performing Common Central Role Tasks 结束语欢迎在本文下面留言一起交流心得… 如果本文能给你带来一定的帮助，在自己有能力的情况下，不妨赞助一下，表示对博主辛勤耕作的支持！","tags":[{"name":"BLE","slug":"BLE","permalink":"http://yoursite.com/tags/BLE/"}]},{"title":"iOS BLE 开发小记[1] - CoreBluetooth 是什么","date":"2017-04-27T07:45:00.000Z","path":"2017/04/27/iOS-Bluetooth-Low-Energy-Develop-Chapter1/","text":"版权声明：本文为 muhlenXi 原创文章，欢迎转载，转载请注明来源。 导语： 不知不觉从事 iOS 低功耗蓝牙开发也很长一段时间了，一直没时间来的及把自己关于这方面的学习和收获写下来，最近项目迭代更新上线完，有点业余时间，抓紧时间总结一下，说这是与同阶段的小伙伴们之间的交流也好，是给后来的小伙伴的掉坑经验也好。毕竟时间是挤出来的！做技术的人一般都有一个很开放的心态！ 现在我们都知道，很多智能硬件设备都已经集成了低功耗蓝牙模块，这样我们就可以开发一个 iOS 或者 Mac APP 与它们进行交互。从 macOS 10.9 和 iOS 6 以后，Mac 和 iOS 设备就支持 低功耗蓝牙技术了，我们可以通过 CoreBluetooth 这个框架与底层的各种蓝牙协议栈进行交互，比如 GATT、ATT 和 L2CAP 等。 与底层交互的过程如下图所示： 开始下文之前，我们需要了解几个概念。对蓝牙不够了解的可以看一下维基百科关于蓝牙的简介。 Bluetooth 4.0: 蓝牙 4.0 是 Bluetooth SIG 于2010年7月7日推出的新的规范，其最重要的特性是功耗低，省电！ BLE: Bluetooth low energy wireless technology,也就是低功耗无线蓝牙技术。 简单了解 CoreBluetoothBLE 是什么？BLE 是关于蓝牙4.0 的详细说明，它定义了一套用于低功耗设备之间通信的协议。而CoreBluetooth 则是对 BLE 协议栈的抽象。也就是说，它隐藏了许多底层的详细实现细节，这样对我们开发者来说，开发一个 APP 与 BLE 设备进行交互将会很便捷。 两个核心角色 Central 和 PeripheralCoreBluetooth 中最关键的两个角色就是 Central(中心) 和 Peripheral（周边）, Peripheral 一般是提供数据的一方，而 Central 一般获取 Peripheral 提供的数据然后来完成特定的任务。举个例子，一个集成 BLE 的数字室温计可能提供房间中的实时温度，我们通过 APP 就可以读取、分析和显示房间中的温度。 Peripheral 通过向空中广播数据的方式来使我们能感知到它的存在。Central 通过扫描搜索来发现周围正在广播数据的 Peripheral, 找到指定的 Peripheral 后，发送连接请求进行连接，连接成功后则与 Peripheral 进行一些数据交互， Peripheral 则会通过合适的方式对 Central 进行响应。 CoreBluetooth 简化常见蓝牙任务CoreBluetooth 对通用的蓝牙任务进行了简化处理，你在 App 中通过 CoreBluetooth 来集成 BLE 功能将会变得简单，如果你开发的 APP 遵循了 Centrals 的开发规范，CoreBluetooth 将会帮你处理与 Peripheral 的扫描、连接以及数据交互的过程，除此之外，通过 CoreBluetooth 将你的设备设置为 本地 Peripheral 也会很便捷。 iOS APP 的状态影响蓝牙的行为iOS APP 的状态也会影响蓝牙的行为，当你的 APP 在后台运行或者处于暂停状态中，蓝牙的行为将会受到影响。默认情况下，当你的 APP 在后台运行时或者处于暂停状态中，你的 APP 是不能与 BLE 进行数据通信的，也就是说，当 APP 后台运行时，你需要与 BLE 进行数据通信，你需要声明你的 APP 支持蓝牙后台运行模式，即使你声明了支持后台运行模式，蓝牙在后台运行模式下的数据处理方式也会变得不同，当开发你的 BLE APP 时，你需要注意这些不同点。 即使 APP 在后台运行时，当系统内存过低时也会杀掉 APP 的后台进程，对于 iOS 7，CoreBluetooth 支持 Central 和 Peripheral 的状态信息的保存和恢复。可以通过这个功能来实现与 BLE 设备的长期交互。 通过恰当的方式提高用户体验CoreBluetooth 框架为你的 APP 与许多常见的 BLE 设备进行交互提供了交互接口，通过合理的利用和实践将会提高用户的体验。 举个例子，当你实现 Central 或 Peripheral 的功能时，会利用设备携带的无线电广播设备（Radio）向空中广播信号，这样就会影响到电池的续航时间，因此当你设计 APP 时，需要尽可能的减少 Radio 的使用频率。 深入 CoreBluetooth重要提醒： 在 iOS 10以后，通过 CoreBluetooth 与 BLE 设备进行数据通信时，必须在项目的Info.plist文件中包含关于NSBluetoothPerpheralUsageDescription的描述,否则会导致 APP 闪退，详情见NSBluetoothPerpheralUsageDescription。 Central 和 Peripheral 的通信方式在 BLE 通信中主要包含两种角色：Central（中心）和 Peripheral（周边），基于传统的客户-服务器架构，Peripheral 通常会提供其他设备需要的数据，Central 通常利用通过 Peripheral 获取的信息来完成特定的任务，如图所示，心率监视器 提供数据给 Mac 或 iOS APP，然后来显示用户的心率数据。 Central 搜索和连接正在广播数据的 PeripheralPeripheral 以广播数据包的形式广播服务中的数据，广播数据包指的是包含 Peripheral 有用信息的一个较小数据包，比如 Peripheral 的名字和主要功能数据。比如，一个数字室温计广播的数据中可能包括当前室温，对于 BLE，广播是显示它们存在的主要方式。 如图，对于一个 Central 来说，它能够搜索和获取到它想要的 Peripheral 的广播信息。 Peripheral 是如何组织数据的连接 Peripheral 的目的就是和 Peripheral 提供的数据进行交互，在你理解这一点后，可以更好的明白 Peripheral 的数据组成结构。 Peripheral 包含一个或多个 Service(服务)和连接信号强度的有用信息。Service 可以理解成是一个完成指定功能的数据集合。举个例子，一个心率监测服务的功能就是可能就是从心率传感器中读取心率数据。 Service 是由 Characteristic（特征） 组成的，Characteristic 为 Peripheral 的 Service 提供更详细的信息，举个例子，心率服务可能包含一个测量不同体位的心率数据的 Characteristic 和一个传输心率数据的 Characteristic，下图所示的是一个心率监测设备的数据组成结构。 Central 与 Peripheral 的数据交互当 Central 与 Peripheral 建立成功的连接后，Central 可以发现 Peripheral 提供的全系列的 Service 和 Characteristic，广播数据包中的数据仅仅是可用服务的一小部分而已。 Central 可以通过读取或写入 Service Characteristic 值的方式与 Service 进行交互。你的 APP 也许需要从数字室温计中获取当前室内的温度或者设置一个温度值到数字室温计中。 如何表示 Central、Peripheral和 Peripheral 数据BLE 通信过程中涉及到的主要角色和数据处理已经简单的集成到 CoreBluetooth 框架中了。 Central 方面的对象当你通过本地 Central 与周围 Peripheral 进行交互时，你只需要调用 Central 方面的方法就可以了，除非你设置一个本地 Peripheral，并用它来响应其他的 Central 的交互请求，实际运用中，你的蓝牙处理大部分会在 Central 方面。 Local（本地） Central 和 Remote（远程） Peripheral在 Central 方面，用 CBCentralManager 对象来表示一个Local Central 设备，这个对象被用来管理 Remote Peripheral 设备（用 CBPeripheral 对象来表示），包括搜索和连接正在广播数据的 Peripheral。如图所示的是 CoreBluetooth 框架中如何表示 Local Central 和 Remote Peripheral。 用 CBService 和 CBCharacteristic 对象来表示 Peripheral 中的服务数据当你与 Remote Peripheral 进行数据交互时，你将处理它的 Service 和 Characteristic，在 CoreBluetooth 框架中，用 CBService 对象来表示 Peripheral 中的服务，同样地，用 CBCharacteristic 对象来表示 Service 中的特征。下图所示的是 Remote Peripheral 的服务特征结构树。 Peripheral 方面的对象对于 macOS 10.9 和 iOS 6， Mac 和 iOS 设备可以实现 BLE Peripheral 的功能，如为其他设备（包括 Mac，iPhone，和 iPad）提供数据。当你遵循 Peripheral 的开发规范时，就可以调用 BLE 通信的 Peripheral 方面的方法。 Local（本地） Peripheral 和 Remote（远程） Central在 Peripheral 方面，一个 Local Peripheral 可以用 CBPeripheralManager 对象来表示，这个对象被用来管理发布包含的服务，包括组织构建 Peripheral 的数据结构以及向中心设备广播数据，Peripheral Manager 也对 Remote Central的读写交互请求做出响应。如图所示的是一个 Local Peripheral 和 Remote Central。 用 CBMutableService 和 CBMutableCharacteristic 对象表示 LocalPeripheral 的数据当你设置并与 Local Peripheral 进行数据交互时，你处理的是它的可变的 Service 和 Characteristic，在 CoreBluetooth 框架中，用 CBMutableService 对象来表示 Local Peripheral 中的服务，同样地，用 CBMutableCharacteristic 对象来表示Local Peripheral 服务中的特征。下图表示的是一个 Local Peripheral 中的服务特征结构树。 参考文献1、About Core Bluetooth 2、CoreBluetoothOverview 结束语欢迎在本文下面留言一起交流心得… 如果本文能给你带来一定的帮助，在自己有能力的情况下，不妨赞助一下，表示对博主辛勤耕作的支持！","tags":[{"name":"BLE","slug":"BLE","permalink":"http://yoursite.com/tags/BLE/"}]},{"title":"Mac 的使用技巧","date":"2017-03-24T09:27:21.000Z","path":"2017/03/24/Mac/","text":"版权声明：本文为 muhlenXi 原创文章，欢迎转载，转载请注明来源。 详情简介： 本文记录的是一些关于 Mac 的使用技巧。如果我们能深入的了解 Mac，然后熟练的使用 Mac，将会为我们的生活带来很大便捷！ 学习贵在记录和总结！ Mac 组合键 修饰键许多应用程序菜单在某些菜单选项旁边显示组合键，如 ⌘N。组合键中的符号表示特殊的键盘按键，称为修饰键。 详情请看 修饰键 符号详情 传送门。 Mac 键盘快捷键常用快捷键如下图所示，详情请看 快捷键详情 传送门。","tags":[{"name":"Mac","slug":"Mac","permalink":"http://yoursite.com/tags/Mac/"}]},{"title":"AppCode skills","date":"2017-03-22T07:25:58.000Z","path":"2017/03/22/AppCode/","text":"版权声明：本文为 muhlenXi 原创文章，欢迎转载，转载请注明来源。 详情简介： 本文主要记录的是 JetBrains 公司的 IDE 的使用技巧，包括 AppCode、IntelliJ IDEA 等。 纸上得来终觉浅，绝知此事要躬行！ AppCode快捷键： Command + O 根据类名跳转文件 Command + 4 打开或关闭调试窗口 Command + Option + O 根据文件名快速跳转 Shift 双击 全局搜索 Command + E 最近编辑的文件 Shift + esc 关闭下边调试窗口 Command + ➡️ 光标跳到当前行代码末尾 Command + ⬅️ 光标跳转到当前行代码开始 Control + Shift + R 运行 配置篇设置编辑时代码自动换行Command + ， 打开 Preference 界面，如图设置即可。","tags":[{"name":"Xcode","slug":"Xcode","permalink":"http://yoursite.com/tags/Xcode/"}]},{"title":"Xcode skills","date":"2017-03-21T07:25:58.000Z","path":"2017/03/21/Xcode-skills/","text":"版权声明：本文为 muhlenXi 原创文章，欢迎转载，转载请注明来源。 详情简介： 本文记录的是 Xcode 软件的使用技巧。 学习贵在记录和总结！ Xcode技巧篇Xcode 快捷键 详细说明： Command + F 当前文件中查找 Command + Option + F 当前文件中查找和替换 Command + Shift + F 项目中查找 Command + Shift + Option + F 项目中查找和替换 Command + 0 显示或隐藏左边导航栏 Command + 1 - 8 选择左边导航栏中的选项 Command + Option + 0 显示或隐藏右边的导航栏 Command + Option + 1 - 9 选择右边导航栏中的选项 Command + Option + / 给函数添加注释 Command + B 编译 Command + R 运行 Command + . 停止运行 Command + Shift + K 清理缓存 Command + Shift + Y 显示或隐藏控制台 Command + K 清理控制台内容 Command + Option + Return 打开 Xib 相关联的 ViewController Command + Return 关闭 Xib 相关联的文件 Command + [ 左移选中的代码块 Command + ] 右移选中的代码块 Command + \\ 注释或取消注释 代码块 Command + Option + [ 上移代码块 Command + Option + ] 下移代码块 Command + Shift + O 根据文件名快速切换文件 Command + Control + space 呼出 emoji 表情输入 Control + A 光标移到本行 行首 Control + E 光标移到本行 行尾 Control + N 光标跳到 下一行 Control + P 光标跳到 上一行 Command + 方向左键 光标移到本行代码开头 Command + 方向 → 光标移到本行代码结尾 Command + L 快速跳到某一行 Xcode 快捷键图示 配置篇Provisioning Profiles 文件目录如图：/用户/yangxi/资源库/MobileDevice/Provisioning Profiles/ Xcode 代码块 文件目录如图：/用户/yangxi/资源库/Developer/Xcode/UserData/CodeSnippets/ 查找项目中的中文字符串如图所示：点击放大镜并切换到 Find &gt; Regular Expression 模式下，输入 `@”[^”][\\u4E00-\\u9FA5]+[^”\\n]?”`回车即可！Swift则要去掉@符号。 导出 本地化语言配置 xiff 文件如图所示：1、选中项目后，然后点击 Editor,选择 红色方框 中的选项，然后执行步骤2。 2、填入文件名和路径，勾选要导出的语言，保存就可以了。。 Objective-C 调用 Swift【1】确保将项目的Target的 Build Setting -&gt; Packaging -&gt; Defines Module 设置为 YES。【2】修改Build Setting 中的 Product Module Name 为 项目名。【3】在调用的地方 导入 #import &lt;项目名-Swift.h&gt;即可。 pch文件路径$(SRCROOT)/项目名称/pch文件名 Xcode8控制台输出信息过多解决方法Product -&gt; Scheme -&gt; Edit Scheme… -&gt; Run -&gt; Arguments, 在Environment Variables里边添加 OS_ACTIVITY_MODE ＝ disable","tags":[{"name":"Xcode","slug":"Xcode","permalink":"http://yoursite.com/tags/Xcode/"}]},{"title":"iOS Add PCH File","date":"2017-03-09T08:23:38.000Z","path":"2017/03/09/iOS-Add-PCH-File/","text":"版权声明：本文为 muhlenXi 原创文章，欢迎转载，转载请注明来源。 导语： pch 文件是APP项目中的一个头文件，该文件中的内容能被项目中的其他源文件共享和访问，是一个预编译文件。 软件版本：Xcode 8.2.1 pch文件的作用 存放一些全局的宏定义。 import 整个项目常用的头文件。 pch文件的添加步骤按顺序执行下面的4个小步骤就可以了。 创建pch头文件步骤一：在项目中 选中 Supporting Files 分类然后 Command+N ，在打开的窗口中往下滚动，选择一个 PCH File 的文件，点 Next ，输入 文件名（建议用项目名）并确定。 配置pch头文件的路径步骤二：选择TARGETS -&gt; Build Settings ，在 查找框中输入 Prefix 回车进行查找。如图： 步骤三：查找结果如下图，将 Precompile Prefix Header 的值改为 Yes ，用以缓存编译后的pch文件，提高编译效率。然后在Prefix Header 中输入 $(SRCROOT)/项目名/项目名.pch,然后回车即可。 重新编译项目步骤四：在项目中，使用 Command+B 即可。 后记感谢阅读，有什么问题可以给我留言。","tags":[{"name":"PCH File","slug":"PCH-File","permalink":"http://yoursite.com/tags/PCH-File/"}]},{"title":"iOS 跳转系统设置和打开其他 APP","date":"2017-03-07T09:04:01.000Z","path":"2017/03/07/System-Settings/","text":"版权声明：本文为 muhlenXi 原创文章，欢迎转载，转载请注明来源。 导语： 在项目中，有时需要跳转到系统设置的某一个界面让用户去设置相关属性。比如一个蓝牙的APP需要检测用户是否打开了蓝牙，否则需要提醒用户并跳转到蓝牙设置界面让用户去打开蓝牙。有时需要打开自带或第三方APP去操作。比如，打开微信、支付宝等。 本文 已更新到 Xcode8.0 Swift3.0 关于适配通过一张图，我们可以查看到 2017-2-20 号用户的系统版本的分布比例，所以我们只要是配到 9.0 和 9.0 以上就可以满足大部分用户了。最新系统版本分布图传送门 跳转到系统设置由于在iOS 10 以上 和 iOS 10 以下分别是通过不同的方法打开URL的，所以我们要对系统版本做判断操作！ 举例1：跳转到 系统蓝牙设置 界面 123456789let urlStr = \"App-Prefs:root=Bluetooth\"if let url = URL(string:urlStr) &#123; if #available(iOS 10.0, *) &#123; UIApplication.shared.open(url, options: Dictionary(), completionHandler: nil) &#125; else &#123; // Fallback on earlier versions UIApplication.shared.openURL(url) &#125;&#125; 打开其他APP举例2：打开 App Store 应用 123456789let urlStr = \"itms-apps://\"if let url = URL(string:urlStr) &#123; if #available(iOS 10.0, *) &#123; UIApplication.shared.open(url, options: Dictionary(), completionHandler: nil) &#125; else &#123; // Fallback on earlier versions UIApplication.shared.openURL(url) &#125;&#125; 常用的第三方应用都定义了不同的 URL Scheme，我们通过 UIApplication.shared.open() 方法打开相应的URL，即可跳转到对应的 App 中。iOS10 以下的系统则是使用 UIApplication.shared.openURL() 方法） 举例3：打开 微信 应用 123456789let urlStr = \"weixin://\"if let url = URL(string:urlStr) &#123; if #available(iOS 10.0, *) &#123; UIApplication.shared.open(url, options: Dictionary(), completionHandler: nil) &#125; else &#123; // Fallback on earlier versions UIApplication.shared.openURL(url) &#125;&#125; 了解更多详情，请下载本文 demo 研究！本文的 Demo 在 10.2.1 和 9.3.2 的真机上都测试过，相关操作均能正常执行！ 本文demoGitHub传送 亲测可以正常使用的 URL Scheme系统设置 要跳转的设置界面 URL String 备注 WIFI App-Prefs:root=WIFI Bluetooth App-Prefs:root=Bluetooth 蜂窝移动网络 App-Prefs:root=MOBILE_DATA_SETTINGS_ID 个人热点 App-Prefs:root=INTERNET_TETHERING VPN App-Prefs:root=VPN 运营商 App-Prefs:root=Carrier 通知 App-Prefs:root=NOTIFICATIONS_ID 定位服务 App-Prefs:root=Privacy&amp;path=LOCATION 通用 App-Prefs:root=General 关于本机 App-Prefs:root=General&amp;path=About 键盘 App-Prefs:root=General&amp;path=Keyboard 辅助功能 App-Prefs:root=General&amp;path=ACCESSIBILITY 语言与地区 App-Prefs:root=General&amp;path=INTERNATIONAL 还原 App-Prefs:root=General&amp;path=Reset 墙纸 App-Prefs:root=Wallpaper Siri App-Prefs:root=SIRI 隐私 App-Prefs:root=Privacy Safari App-Prefs:root=SAFARI 音乐 App-Prefs:root=MUSIC 照相与照相机 App-Prefs:root=Photos FaceTime App-Prefs:root=FACETIME 电池电量 App-Prefs:root=BATTERY_USAGE 存储空间 App-Prefs:root=General&amp;path=STORAGE_ICLOUD_USAGE/DEVICE_STORAGE 显示与亮度 App-Prefs:root=DISPLAY 声音设置 App-Prefs:root=Sounds App Store App-Prefs:root=STORE iCloud App-Prefs:root=CASTLE 语言设置 App-Prefs:root=General&amp;path=INTERNATIONAL 自带 App 和第三方 App 要打开的APP URL Scheme Bundle Identifier 打10086 tel://10086 App Store itms-apps:// Safari http://muhlenxi.com/ Maps maps:// 备忘录 mobilenotes:// SMS sms:// Mail mailto:// iBooks ibooks:// Music music:// Videos videos:// QQ mqq:// 微信 weixin:// 淘宝 taobao:// 支付宝 alipay:// 新浪微博 sinaweibo:// 知乎 zhihu:// 后记感谢阅读，有什么问题可以给我留言。如果觉得不错的话，可以点个 Star 支持一下作者！本文不阶段更新中…","tags":[{"name":"system setting","slug":"system-setting","permalink":"http://yoursite.com/tags/system-setting/"}]},{"title":"App Frameworks 之 Swift Standard Library","date":"2017-02-15T03:20:19.000Z","path":"2017/02/15/About-SwiftStandardLibrary/","text":"版权声明：本文为 muhlenXi 原创文章，欢迎转载，转载请注明来源。 导语： 本文是关于 Swift Standard Library 的描述。 Swift 标准库用于解决复杂的问题和编写高性能，可读性性好的代码。传送门 Swift Standard Library综述Swift 标准库定义了编写 Swift 程序的基础功能层，包括： 基本数据类型，比如 Int,Double,和 String 常见数据结构，比如 Array,Dictionary,Set 全局函数，比如 print(_:separator:terminator:) 和 abs(_:) 用于描述常见的抽象的 Collection 和 Equatable 协议 自定义可用于所有类型的操作符的 CustomDebugStringConvertible 和 CustomReflectable 协议。 用于提供需要样板代码的实现的 OptionSet 协议。 探索标准库 通过可视化的实用例子来探索 Swift 标准库的类型和学习高级概念，学习 Swift 标准库是如何通过协议和泛型来表达强大的约束。下载下面的 playground 来开始吧。 Swift Standard Library 结束语欢迎在本文下面留言一起交流心得或错误指正… 如果本文能给你带来一定的帮助，在自己有能力的情况下，不妨赞助一下，表示对博主辛勤耕作的支持！","tags":[{"name":"Swift Standard Library","slug":"Swift-Standard-Library","permalink":"http://yoursite.com/tags/Swift-Standard-Library/"}]},{"title":"App Frameworks 之 UIKit 框架","date":"2017-02-01T03:20:19.000Z","path":"2017/02/01/About-UIKit/","text":"版权声明：本文为 muhlenXi 原创文章，欢迎转载，转载请注明来源。 导语： 本文是关于 UIKit 框架的描述。 如果你想要学 mac OS / iOS App 开发，你需要参考的第一手资料则是 Apple Developer Documentation,在这里，Apple 公司会不定期更新最新的 Kit(开发包)，包括 API reference（API 接口）、技术文章和示例代码等。 UIKitUIKit 用于为你的 iOS App 或者 tvOS App 用户交互界面的构建、绘制和事件驱动。 UIKit 框架为你的 iOS App 或者 tvOS App 提供必要的基础结构。比如，用于实现界面的 window 和 view 结构，用于多点触控的事件处理结构，还有一个 main run loop 来管理用户交互、系统和 App。除此之外还包括，动画支持，文件支持，绘制和打印支持，当前设备的信息，文本的管理和显示，搜索支持，可访问性（accessibility）支持，app 扩展支持和 资源管理。 切记： 大部分来说，只在主线程或主队列中使用 UIKit 的类对象。 该限制适用于 UIResponder 的派生类，或者涉及 app 用户的界面的任何操作。 UIKit 基础UIkit 管理 app 与系统之间的交互，提供用于管理 app 数据和资源的类。传送门 Core App用于管理 app 的数据模型和与系统的交互 。详情传送门 包括： class : UIApplication,UIDevice,UITraitCollection,UIDocument,UIManagedDocument, UIPasteboard, UIPasteConfiguration protocol : UIApplicationDelegate,UITraitEnvironment,UIAdaptPresentationControllerDelegate,UIPasteConfigurationSupporting, UIDataSourceModelAssociation,UIGuideAccessRestrictionDelegate Resource Management用于管理 image, string, storyboard 和 存储在主可执行文件之外的 nib 文件。详情传送门 包括： class : UIStoryboard,UIStoryboardSegue,UIStoryboardUnwindSegueSource,UIImageAsset, NSDataAsset,UINib App Extensions将 app 的基础功能扩展到系统的其他部分。详情传送门 包括： class : UIDocumentPickerExtensionViewController,NSFileProviderExtension,UIInputViewController,UILexicon,UILexiconEntry protocol : UITextDocumentProxy,UIInputViewAudioFeedback View 帮你显示屏幕内容和方便用户交互；view controller 帮你管理 view 和 界面的结构。 Views and Controls以特定的方式呈现屏幕内容，并定义与内容相关的交互。详情传送门 包括： \u0010class : UIView,UIStackView,UIScrollView,UIActivityIndicatorView,UIImageView, UIPickerView,UIProgressView,UIWebView,UIControl,UIButton, UIDatePicker,UIPageControl,UISegmentedControl,UISlider,UIStepper,UISwitch, UILabel,UITextField,UITextView,UIBarItem,UIBarButtonItem, UIBarButtonItemGroup,UINavigationBar,UISearchBar,UIToolbar,UITabBar, UITabBarItem,UIMenuController,UIMenuItem,UIVisualEffect,UIVisualEffectView, UIVibrancyEffect,UIBlurEffect Container : Collection Views, Table Views protocol : UIBarPositioning,UIBarPositioningDelegate,UIAppearance,UIAppearanceContainer struct : UIEdgeInsets,NSDirectionalEdgeInsets,UIOffset View management用 view controller 和 navigation 来显示不同的界面的内容。详情传送门 包括： class : UIViewController,UIPresentationController,UISplitViewController,UINavigationController, UINavigationItem,UINavigationBar,UIPageViewController,UITabbarController, UITabBar,UITabBarItem,UISearchContainerViewController,UISearchBar,UISearchController, NSLayoutConstraint,UILayoutGuide,NSLayoutAnchor,NSLayoutAnchor,NSLayoutDimension, NSLayoutXAxisAnchor,NSLayoutYAxisAnchor,UIFocusGuide,UIFocusSystem,UIFocusUpdateContext, UIFocusAnimationCoordinator,UIFocusDebugger protocol : UIContentContainer,UISearchBarDelegate,UISearchResultsUpdating,UILayoutSupport, UIFocusItem,UIFocusEnvironment,UIViewControllerRestoration,UIObjectRestoring System View Controller使用内建的 UIKit view controller 来挑选照片，编辑视频，分享内容，打印文件等等。详情传送门 包括： class : UIImagePickerController,UIVideoEditorController,UIDocumentBrowserViewController,UIDocumentBrowser, UIDocumentBrowserTransitionController,UIDocumentPickerViewController,UIDocumentInteractionController,UICloudSharingController, UIActivityViewController,UIActivity,UIActivityItemProvider,UIPrinterPickerController, UIReferenceLibraryViewController protocol : UIVideoEditorControllerDelegate,UIActivityItemSource,UIPrinterPickerControllerDelegate enum : UIDocumentBrowserError.Code let : UIDocumentBrowserErrorDomain Drag and Drop使用交互 API 为你的 view 添加 drag and drop 功能。详情传送门 包括： protocol : UIDragInteractionDelegate,UIDropInteractionDelegate,UIInateraction,UISpringLoadedInteractionBehavior, UISpringLoadedInteractionSupporting,UISpringLoadedInteractionContext,UISpringLoadedInteractionEffect,UIDragDropSession, UIDragSession,UIDragAnimating,UIDropSession,NSItemProviderReading,NSItemProviderWriting, UIPasteConfigurationSupporting class : UIDragInteraction,UIDropInteraction,UISpringLoadedInteraction,UIDragItem,UIDropProposal, NSItemProvider,UIPasteConfiguration,UIDragPreviewParameters,UIDragPreview,UIDragPreviewTarget, UITargetedDragPreview enum : UIDropOperation,UIDropSessionProgressIndicatorStyle Accessibility让残疾用户更容易的使用你的 app。详情传送门 包括： protocol : UIAccessibilityIdentification,UIAccessibilityReadingContent,UIAccessibilityContentSizeCategoryImageAdjusting, UIScrollViewAccessibilityDelegate,UIPickerViewAccessibilityDelegate,UIAccessibilityContainerDataTable, UIAccessibilityContainerDataTableCell class : UIAccessibilityCustomAction,UIAccessibilityElement,UIAccessibilityCustomRotor,UIAccessibilityCustomRotorItemResult, UIAccessibilityCustomRotorSearchPredicate,UIAccessibilityLocationDescriptor enum : UIAccessibilityContainerType struct : UIAccessibilityHearingDeviceEar Animation and Haptics使用基于 view 的动画和触觉向用户提供反馈。详情传送门 包括： class : UIFeedbackGenerator,UIImpactFeedbackGenetator,UINotificationFeedbackGenetator,UISelectionFeedbackFenerator Windows and Screens为你的 view 层次结构和其他内容提供容器。详情传送门 包括： class : UIWindow,UIPopoverPresentationController,UIPopoverBackgroundView,UIAlertController, UIAlertAction, UIScreen,UIScreenMode protocol : UICoordinateSpace,UIPopoverBackgroundViewMethods 结束语欢迎在本文下面留言一起交流心得或错误指正… 如果本文能给你带来一定的帮助，在自己有能力的情况下，不妨赞助一下，表示对博主辛勤耕作的支持！","tags":[{"name":"UIKit","slug":"UIKit","permalink":"http://yoursite.com/tags/UIKit/"}]},{"title":"App Frameworks 之 Foundation 框架","date":"2017-01-20T02:20:19.000Z","path":"2017/01/20/About-Foundation/","text":"版权声明：本文为 muhlenXi 原创文章，欢迎转载，转载请注明来源。 导语： 学习软件开发最好的方式就是去努力学好英语，然后去看官方的第一手资料 - 软件开发指南。本文是关于 Foundation 框架的描述。 如果你想要学 mac OS / iOS App 开发，你需要参考的第一手资料则是 Apple Developer Documentation,在这里，Apple 公司会不定期更新最新的 Kit(开发包)，包括 API reference（API 接口）、技术文章和示例代码等。 Apple 开发的基础框架Apple App 开发涉及到的（Framework）基础框架主要有 6 大部分，分别如下： AppKit Foundation Objective-C Swift Standard Library UIKit WatchKit 博客稍后会对每个类别做一个简介，不定时更新，如果感兴趣想深入了解，可以点击链接跳转到官网学习。 FoundationFoundation 是一个基础的框架，用于支持你的 App 的基础功能定义，比如基本数据类型、数据集合和操作系统服务的访问。 Foundation 框架为你的 App 和其他框架的基础功能提供支持，包括数据的保存和持久化存储，文本处理、日期和时间的计算、排序和过滤，网络等。mac OS，iOS，watchOS，以及 tvOS 的 SDK（软件开发包中）都有使用到 Foundation 框架中定义的类、协议和数据类型等。 Foundation 基础Numbers,Data,和 Basic Value这部分主要是包含 Cocoa 中使用的基础数据类型。详情传送门 包括： struct : Int,Double,Decimal,Data,URL, URLComponents,URLQueryItem,UUID,CGFloat,AffineTransform, NSEdgeInsets class : NumberFormatter, typealias : NSPoint,NSSize,NSRect,NSRange Strings 和 Text这部分主要包括 Unicode 字符串的创建和处理，使用正则表达式模式查找以及文本的自然语言分析。详情传送门 包括： struct : String,CharacterSet,Locale class : NSAttributedString,NSMutableAttributedString,NSLinguisticTagger,Scanner,NSRegularExpression, NSDataDetector,NSTextCheckingResult,NSSpellServer,NSOrthography typealias : UnicodeScalar let : NSNotFound protocol : NSSpellServerDelegate Collections这部分主要包括 array，set，dictionary 和 专用集合来存储和遍历集合中的对象或者值。详情传送门 包括： struct : Array,Dictionary,Set, IndexPath,IndexSet, NSFastEnumerationIterator,NSIndexSetIterator,NSEnumerationOptions,NSSortOptions class : NSCountedSet,NSOrderedSet,NSMutableOrderedSet,NSCache,NSPurgeableData, NSPointerArray,NSMapTable,NSHashTable,NSEnumerator,NSNull protocol : NSFastEnumeration let : NSNotFound Dates 和 Times这部分主要包括日期和时间的比较、日历和时间域的计算。详情传送门 struct : Date,DateInterval,DateComponents,Calendar,TimeZone,Locale typealias : TimeInterval \u0010class : DateFormatter,DateComponentsFormatter,DateIntervalFormatter,ISO8601DateFormatter Units 和 Measurement这部分主要是物理参数的测量和单位转换。详情传送门 struct : Measurement \u0010class Unit,Dimension,UnitConverter,UnitConverterLinear,UnitArea, UnitLength,UnitVolume,UnitAngle,UnitMass,UnitPressure, UnitAcceleration,UnitDuration,UnitFrequency,UnitSpeed,UnitEnergy, UnitPower,UnitTemperature,UnitIlluminance,UnitElectricCharge,UnitElectricCurrent, UnitElectricPotentialDifference,UnitElectricResistance,UnitConcentrationMass,UnitDispersion,UnitFuelEfficiency Data Formatting主要是 number, date, measurement 以及一些其他值的文本转换。详情传送门 class : NumberFormatter,PersonNameComponentFormatter,DateFormatter,DateComponentsFormatter,DateIntervalFormatter, ISO8601DateFormatter,ByteCountFormatter,MeasurementFormatter,Formatter,LengthFormatter, MassFormatter,EnergyFormatter struct : PersonNameComponents,Locale Filter 和 Sorting主要包含使用 predicate（谓词），expression（表达式）和 sort descriptors（排序描述）来过滤和排序集合中的元素。详情传送门 class : NSPredicate,NSExpression,NSComparisonPredicate,NSCompoundPredicate,NSSortDescriptor enum : ComparisonResult 结束语欢迎在本文下面留言一起交流心得或错误指正… 如果本文能给你带来一定的帮助，在自己有能力的情况下，不妨赞助一下，表示对博主辛勤耕作的支持！","tags":[{"name":"Foundation","slug":"Foundation","permalink":"http://yoursite.com/tags/Foundation/"}]},{"title":"大话设计模式---读书笔记","date":"2017-01-10T06:44:53.000Z","path":"2017/01/10/Dahua-Design-Pattern/","text":"版权声明：本文为 muhlenXi 原创文章，欢迎转载，转载请注明来源。 前言： 大话设计模式-设计模式的趣味解读，面向对象的深入剖析。在诙谐与温馨中做一次面向对象编程思维的体操。 对于程序猿来讲，精彩的代码时如何想出来的，要比看到精彩的代码更加令人期待！ 笔记内容 如果想成为一名更优秀的软件设计师，了解优秀软件设计的演变过程比学习优秀设计本身更有价值，因为设计的演变过程中蕴藏着大智慧。 通过封装、继承、多态把程序的耦合度降低。 用设计模式使得程序更加灵活，容易修改，并且易于复用。 让业务逻辑和界面逻辑分开，让他们之间的耦合度下降。只有分离开，才可以达到容易维护或扩展。 简单工厂模式简单工厂模式，考虑用一个单独的类来做这个创造实例的过程。这就是工厂。 UML类图类图分三层，第一层显示类的名称，如果是抽象类，则就用斜体表示。第二层是类的特性，通常就是字段和属性。第三层是类的操作，通常是方法或行为。“+”表示public，“-”表示private，“#”表示protected。 接口图的顶端有《interface》显示。第一行是接口名称，第二行是接口方法。接口还有一种棒棒糖表示法。 继承关系用空心三角形+实线来表示。 实现接口用空心三角形+虚线来表示。 当一个类知道另一个类时，可以用关联。关联关系用实线箭头表示。 聚合表示一种弱的拥有关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分。比如雁群和大雁的关系。聚合关系用空心的菱形+实线箭头表示。 合成（Composition）是一种强的拥有关系，体现了严格的部分与整体的关系。部分和整体的生命周期一样。如鸟和翅膀。用实心的菱形+实线箭头表示。 依赖关系（Dependency）用虚线箭头表示。 面向对象的编程，并不是类越多越好，类的划分是为了封装，但分类的基础是抽象，具有相同属性和功能的对象的抽象集合才是类。 策略模式策略模式（Strategy）：它定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的客户。 单一职责原则（SRP）：就一个类而言，应该仅有一个引起它变化的原因。 如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭受意想不到的破坏！ 开放-封闭原则，是说软件实体（类、模块。函数等等）应该可以扩展，但是不可修改。 对于扩展是开放的（Open for extension），对于更改是封闭的（Closed for modification）。 在我们最初编写代码时，假设变化不会发生。当变化发生时，我们就创建抽象来隔离以后发生的同类变化。 面对需求，对程序的改动是通过增加新代码进行的，而不是更改现有的代码。 我们希望的是在开发工作展开不久就知道可能发生的变化。查明可能发生的变化所等待的时间越长，要创建正确的抽象就越困难。 开放-封闭原则是面向对象设计的核心所在。遵循这个原则可以带来面向对象技术所声称的巨大好处，也就是可维护、可扩展、可复用、灵活性好。开发人员应该仅对程序中呈现出频繁变化的那些部分做出抽象，然而，对于应用程序中的每个部分都刻意地进行抽象同样不是一个好主意。拒绝不成熟的抽象和抽象本身一样重要。 依赖倒转原则，抽象不应该依赖细节，细节应该依赖于抽象。也就是要针对接口编程，而不是对实现编程。 依赖倒转原则： A、高层模块不应该依赖低层模块。两个都应该依赖抽象。 B、抽象不应该依赖细节。细节应该依赖抽象。 里氏代换原则（LSP）:子类型必须能够替换掉它们的父类型。 依赖倒转其实可以说是面向对象设计的标志。用哪种语言来编写不重要，如果编写时考虑的都是如何针对抽象编程而不是针对细节编程，即程序中所有依赖关系都是终止于抽象类或者接口，那就是面向对象的设计，反之那就是过程化的设计了。 装饰模式装饰模式（Decorator），动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活。 Component是定义一个对象的接口，可以给这些对象动态地添加职责。ConcreteComponent是定义一个具体的对象，也可以给这个对象添加一些职责。Decorator，装饰抽象类，继承了Component，从外类来扩展Component类的功能，但对于Component来说，是无需知道Decorator的存在的，至于ConcreteDecorator就是具体的装饰对象，起到了给Component添加职责的功能。 装饰模式是利用SetComponent来对对象进行包装的，这样每个装饰对象的实现就和如何使用这个对象分开了，每个装饰对象只关心自己的功能，不需要关心如何被添加到对象链当中。 如果只有一个ConcreteComponent类而没有抽象的Component类，那么Decorator类可以是ConcreteComponent类的一个子类。同样道理，如果只有一个ConcreteDecorator类，那么就没有必要新建一个单独的Decorator类，而可以把Decorator和ConcreteDecorator的责任合并成一个类。 代理模式代理模式，为其他对象提供一种代理以控制对这个对象的访问。 远程代理，也就是为一个对象在不同的地址空间提供局部代表，这样可以隐藏一个对象存在于不同地址空间的事实。 虚拟代理，是根据需要创建开销很大的对象。通过它来存放实例化需要很长时间的真实对象。 安全代理，用来控制真实对象访问时的权限。 智能指引，是指当调用真实的对象时，代理处理另外一些事。 工厂方法模式简单工厂模式的最大优点在于工厂类中包含了必要的逻辑判断，根据客户端的选择条件动态实例化相关的类，对于客户端来说，去除了与具体产品的依赖。 工厂方法模式（Factory Method），定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。 原型模式原型模式（prototype）,用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象。 原型模式其实就是从一个对象再创建另外一个可定制的对象，而且不需要知道任何创建的额细节。 浅复制，被复制对象的所有变量都含有与原来对象相同的值，而所有的对其他对象的引用都仍然指向原来的对象。 深复制，把引用对象的变量指向复制过的新对象，而不是原有被引用的对象。 模板方法模式模板方法模式，定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些步骤。 当我们要完成在某一细节层次一致的一个过程或一系列步骤，但其个别步骤在更详细的层次上的实现可能不同时，我们通常考虑用模板方法模式来处理。 模板方法模式是通过把不变行为搬移到超类，去除子类中的重复代码来体现它的优势。模板方法模式就是提供了一个很好的代码复用平台。 迪米特法则也叫最少知识原则迪米特法则（LOD），如果两个类不必彼此通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。 迪米特法则其根本思想是强调了类之间的松耦合，类之间的耦合越弱，越利于复用，一个处于弱耦合的类被修改，不会对有关系的类造成波及。在类的结构设计上，每一个类都应当降低成员的访问权限。 外观模式外观模式（Facade），为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。 外观模式使用场景如下： 在设计初期阶段，应该有意识的将不同的两个层分离，层与层之前建立外观Facade，这样可以为复杂的子系统提供简单的接口，使得耦合大大降低。 在开发阶段，子系统往往因为不断的重构演化而变得越来越复杂，大多数的模式使用时也会产生很多很小的类，这本是好事，但也给外部调用它们的用户程序带来了使用上的困难，增加外观Facade可以提供一个简单的接口，减少它们之间的依赖。 在维护一个遗留的大型系统时，可能这个系统已经非常难以维护和扩展了。但因为它包含非常重要的功能，新的需求开发必须依赖它。此时可以为新系统开发一个外观Facade类，来提供设计比较清晰的接口（粗糙或高度复杂的遗留代码的），让新系统与Facade对象交互，Facade与遗留代码交互所有复杂工作。 建造者模式建造者模式（Build），将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 建造者模式是在当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时适用的模式。 观察者模式观察者模式又叫发布-订阅（Publish/Subscribe）模式。 观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己。 将一个系统分割成一系列相互协作的类有一个很不好的副作用，那就是需要维护相关对象间的一致性。我们不希望为了维持一致性而使各类紧密耦合、这样会给维护、扩展和重用都带来不便。 抽象工厂模式抽象工厂模式（Abstract Factory），提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。","tags":[{"name":"大话设计模式","slug":"大话设计模式","permalink":"http://yoursite.com/tags/大话设计模式/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/tags/读书笔记/"}]},{"title":"Git学习笔记","date":"2016-12-15T02:20:19.000Z","path":"2016/12/15/About-Git/","text":"版权声明：本文为 muhlenXi 原创文章，欢迎转载，转载请注明来源。 导语：Git 是目前世界上最先进的分布式版本控制系统。 要有这样的理念：活到老，学到老，不要停止，一直保持前进！ 常见 git 本地仓库操作创建版本库 (repository) 并初始化mkdir zhangsan //创建zhangsan文件夹 cd zhangsan pwd //打印当前路径 git init //初始化git仓库 ls -ah //查看隐藏文件 Unix 的哲学是“没有消息就是好消息”，没有消息说明操作成功。 添加文件到版本库touch readme.text //创建readme文件 git add readme.text //添加文件 git commit -m &quot;这是标记信息&quot; //提交文件 git status //查看工作区的状态 git diff //查看修改了哪些内容 git log //查看历史提交日志记录 版本回退git reset --hard HEAD^ //回退到上一版本 git reset --hard commit_id(版本号) //回退到某一版本 git reflog //查看命令历史 cat readme.text //查看文件内容 撤销修改【场景1】：当你改乱了工作区的某个文件的内容，想直接丢弃工作区的修改时，用命令 git checkout -- filename。 【场景2】：当你不但改乱了工作区某个文件的内容，还添加到了暂存区，想丢弃修改，分两步走，第一步用命令 git reset HEAD file ,就回到了【场景1】，第二步按【场景1】的操作。 【场景3】：已经提交了不合适的修改到版本库时，想要撤销本次修改，参考 版本回退，不过前提是还没有推送到远程库。 删除文件git rm readme.text //只删除工作区中的文件 git rm readme.text //从版本库中删除该文件 git commit -m &quot;remove readme.text&quot; //恢复误删的文件，前提是没有从版本库中删除该文件 git checkout -- readme.text git远程仓库操作 本地 Git 仓库和 GitHub 仓库之间的传输是通过 ssh 加密的，所以要设置 ssh。 【1】创建 SSHkey ssh-keygen -t rsa -C &quot;你注册的邮箱地址&quot; 提示：1、创建完成后，会在主目录中生成 .ssh 目录，里面有 id_rsa（秘钥）和id_rsa.pub（公钥）。 2、cd 到 .ssh 目录下，用命令 cat id_rsa.pub 查看公钥内容。 【2】登陆 GitHub，打开 Account setting , 在 SSH keys 界面 粘贴公钥里的内容。 关联远程仓库 在 GitHub 上创建一个新的仓库后，然后可以进行如下操作。 git remote add origin 仓库地址 //关联远程仓库 git push -u origin master //第一次推送Master分支的所有内容 git push origin master //以后推送最新修改 git clone 仓库地址 //克隆远程仓库到本地 git 分支管理分支操作git branch //查看分支 git branch 分支名 //创建分支 git checkout 分支名 //切换分支 git checkout -b 分支名 //创建并切换分支 git merge 分支名 //合并某分支到当前分支 git branch -d 分支名 //删除分支 注意：合并分支时，如有冲突，需要先解决冲突，然后再add和commit。 git log --graph //查看分支合并图 合并分支时，如果有可能，git会用 Fast forward 模式，在该模式下，删除分支后，会丢失分支信息。 强制禁用 Fast forward 模式，git会在merge时生成一个新的commit，这样从分支历史上就可以看出分支信息。 git merge --no-ff -m &quot;提示标记&quot; 分支名 分支策略 1、首先， master 分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活； 2、新建分支 dev，干活都是在 dev 分支上，也就是说 dev 分支是不稳定的，当发布新版本的时候，才把dev 分支合并到 master 上，在 master 上发布新版本。 3、不同的人干活，都新建 自己的分支，然后时不时往 dev 分支上合并就可以了。 通过 bug 分支来修复 buggit stash //保存当前工作现场 git stash list //查看工作现场保存记录 git stash apply //恢复工作现场 git stash drop //删除stash内容 git stash pop //恢复工作现场的同时删除stash内容 git stash apply stash@{0} //恢复指定的stash 每开发一个新功能的时候，最好新建一个功能分支！ git branch -D 分支名 //强行删除一个未合并的分支 标签的操作git tag v1.0 //给最新的commit版本打一个标签，v1.0为标签名 git tag //查看所有的标签 git log --pretty=oneline --abbrev-commit //查看历史提交的commit id git tag 标签名 commit_id //给指定的commit打标签 git show 标签名 //查看标签信息 git tag -a 标签名 -m “说明文字” commit_id //打带说明文字的标签 git tag -s 标签名 -m “说明文字” commit_id //打用PGP签名标签 git tag -d 标签名 //删除标签 git push origin 标签名 //推送某个标签到远程仓库 git push origin --tags //推送全部标签到远程仓库 git push origin :refs/tags/标签名 //删除远程标签，需先删除本地标签 多人协作工作模式 1、首先，试着用 git push origin 分支名 推送自己的修改； 2、如果推送失败，则因为远程分支比你的本地分支要新，需要先用 git pull 试图合并。 3、如果合并有冲突，则解决冲突，并在本地提交； 4、没有冲突或解决掉冲突后，再用 git push origin 分支名 推送，就能推送成功。 注意：如果 git pull 提示 “no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令 git branch --set-upstream 远程分支名 本地分支名 关于 GitHub 在 GitHub 上，可以任意 Fork 开源仓库； 自己拥有 Fork 后的仓库的读写权限 可以推送 pull request 给 开源项目 来贡献代码 配置别名【1】配置命令： git config --global alias.st status git config --global alias.co checkout git config --global alias.cm commit git config --global alias.br branch git config --global alias.last &apos;log -1&apos; //显示最近一次的提交 --global 参数是全局参数，也就是这些命令在这台电脑的所有 Git 仓库下都有用。 【2】配置文件的路径 每个仓库的Git配置文件都放在.git/config文件中： 用命令 cat .git/config 可以查看。 别名就在 [alias] 后面，要删除别名，直接把对应的行删掉即可。 当前用户的 Git 配置文件放在用户主目录下的一个隐藏文件 .gitconfig 中： 用命令 cat .gitconfig 可以查看。 结束语欢迎在本文下面留言一起交流心得… 如果本文能给你带来一定的帮助，在自己有能力的情况下，不妨赞助一下，表示对博主辛勤耕作的支持！","tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"},{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"Pragmatic Programmer - 学习笔记 ","date":"2016-11-17T01:53:15.000Z","path":"2016/11/17/The-Pragmatic-Programmer/","text":"版权声明：本文为 muhlenXi 原创文章，欢迎转载，转载请注明来源。 前言： 程序员修炼之道-从小工到专家，是一本初学者、中高级开发人员或软件项目经理都可以读的书。本书全面阐述了软件开发的许多不同方面的最佳实践和重大陷阱。 正文 频繁的高强度的外部刺激和有意识的反复提醒是加速内化的两个重要方法。 注重实效的程序员应该不断学习！ 能不能让正确的原则指导正确的行动本身，其实就是区分是否是高手的一个显著标志。 注重实效不应该局限于任何特定的技术，而是应该拥有足够广博的背景和经验基础，以让你能够在特定情况下选择好的解决方案。 你的背景源于对计算机科学的基本原理的理解。你的经验来自广泛的实际项目。理论与实践的结合使你强大起来。 注重实效的程序员的特征 1、早期的采纳者/快速的改编者。 2、好奇。 3、批判的思考者。 4、有现实感。 5、多才多艺。 Tip 1：Care About Your Craft如果你不在乎能否漂亮地开发出软件，你又为何要耗费生命去开发软件呢？ Tip 2：Think! About Your Work在你做某件事情的时候思考你在做什么。 Tip 3：Provide Options, Don’t Make Lame Excuses要提供各种选择，而不是找借口。不要说事情做不到；要说明能够做什么来挽回局面。 Tip 4：Don’t Live with Broken Windows不要留着糟糕的代码不修，发现一个就修一个。实在来不及的话，先标记后维修。 Tip 5: Be a Catalyst for Change设计出你可以合理要求的东西，好好开发它。一旦完成，就拿给大家看，让他们大吃一惊，然后说：“要是我们增加…可能就会更好。” 假装那并不重要。坐回椅子上，等着他们开始要你增加你本来就想要的功能。 Tip 6: Remember the Big Picture要持续不断地观察周围发生的事情，而不是你自己正在做的事情。 Tip 7： Make Quality a Requirements Issue如果你给用户某样东西，让他们及早使用，他们的反馈常常会把你引向更好的最终解决方案。 Tip 8： Invest Regularly in Your Knowledge Portfolio就像金融投资一样，你必须定期为你的知识资产投资。即使投资量很小，习惯自身也和总量一样重要。 Tip 9：Critically Analyze What You Read and Hear你需要确保你的资产中的知识是准确的，并且没有受到供应商或媒体炒作的影响。 Tip 10：It‘s Both What You Say and the Way You Say It如果你不能有效地向他人传达你了不起的想法，这些想法就毫无用处。 Tip 11：DRY - Don’t Repeat Yourself发挥一点聪明才智，你通常能够消除重复的需要。 Tip 12： Make It Easy to Reuse如果复用很容易，人们就会去复用。努力去营造一个支持复用的环境。 Tip 13：Eliminate Effects Between Unrelated Things如果你编写正交的系统，你将得到两个主要的好处：提高生产率与降低风险。 Tip 14：There Are No Final Decisions 没有决策是浇筑在石头上的，相反，要把每项决策都视为写在沙滩上的，并为可能出现的意外事件做好准备。 Tip 15：Use Tracer Bullets to Find the Target曳光弹行之有效，是因为它们与真正的子弹在相同的环境、相同的约束下工作。从实践的角度看，这样的解决方案也更便宜。 Tip 16：Prototype to Learn 原型制作是一种学习经验。其价值并不在于所产生的代码，而在于所学到的经验教训。那才是原型制作的要点所在。 原型制作生成用过就扔的代码。曳光代码虽然简约，但却是完整的，并且构成了最终系统的骨架的一部分。 Tip 17：Program Close to the Problem domain语言的界限就是一个人的世界的界限。 通过在更高的抽象层面上编码，你获得了专心解决领域问题的自由，并且可以忽略琐碎的实现细节。 Tip 18：Estimate to Avoid Surprises通过学习估算，并将此技能发展到你对事物的数量级有直觉的程度，你就能展现出魔法般的能力，确定它们的可行性。 Tip 19：Iterate the Schedule with the Code增量开发 Tip 20：Keep Knowledge in Plain Text通过纯文本，你可以获得自描述的、不依赖于创建它的应用的数据流。 Tip 21：Use the Power of Command Shells去熟悉 shell， 你会发现自己的生产率迅速提高。 Tip 22： Use a Single Editor Well选一种编辑器，彻底了解它，并将其用于所有的编辑任务。 Tip 23：Always Use Source Code Control 源码控制是你的工作的时间机器 — 你能够回到过去。 Tip 24：Fix the Problem，Not the Blame调试就是解决问题，要据此发起进攻。 Tip 25： Don’t Panic 做一次深呼吸，思考什么可能是 bug 的原因。 Tip 26： “Select” Isn’t Brokenbug 有可能存在于 OS、编译器、或是第三方产品中 — 但这不应该是你的第一想法。有大得多的可能性是，bug 存在于正在开发的应用代码中。 Tip 27：Don’t Assume it - Prove It不要因为你 “知道” 它能工作而轻易放过与 bug 有牵连的例程或代码。证明它，用这些数据、这些边界条件、在这个语境中证明它。 Tip 28：Learn a Text Manipulation Language你用每天的很大一部分时间处理文本，为什么不让计算机替你完成部分工作呢？ Tip 29：Write Code That Writes Code代码生成器能提高你的生产率，并有助于避免重复。 Tip 30： You Can’t Write Perfect Software完美的软件不存在。 Tip 31：Design with contractsDBC 关注的是用文档约定软件模块的权利与责任，以确保程序正确性。 Tip 32：Crash Early许多时候，让你的程序崩溃是你的最佳选择。 Tip 33： If It Can’t Happen, Use Assertions to Ensure That It Won’t当你发现自己在思考 “那当然不可能发生”， 增加代码检查它。最容易的办法是使用断言。 Tip 34： Use Exceptions for Exceptional Problems异常应保留给意外事件。 Tip 35：Finish What You Start你分配资源、使用它，然后解除其分配。 Tip 36：Minimize Coupling Between Modules把你的代码组织成最小模块，并限制它们之间的交互。Law of Demeter Tip 37：Configure, Don’t Integrate用配置来代替集成。 Tip 38：Put Abstractions in Code, Details in MetadataTip 39：Analyze Workflow to Improve Concurrency可以使用 UML 图找出本来可以、但却没有并行执行的动作，是并行度最大化。 Tip 40：Design Using Services我们创建的不是组件，而是服务 — 位于定义良好的、一致的接口之后的独立、并发的对象。 Tip 41： Always Design for ConcurrencyTip 42：Separate Views from ModelsTip 43：Use Blackboards to Coordinate Workflow我们可以用黑板协调完全不同的事实和因素，同时又使各参与方保持独立、甚至隔离。 Tip 44： Don’t Program by CoincidenceTip 45：Estimate the Order of Your AlgorithmsTip 46：Test Your EstimatesTip 47： Refactor Early，Refactor oftenTip 48：Design to TestTip 49： Test Your Software,or Your Users WillTip 50：Don’t Use Wizard Code You Don’t Understand向导可以生成大量代码。在你把他们合并进你的项目之前，确保你全部理解这些代码。 Tip 51：Don’t Gather Requirements - Dig for ThemTip 52：Work with a User to Think Like a User找出用户为何要做特定事情的原因，而不只是他们目前做这件事情的方式，这很重要。 Tip 53：Abstractions Live Longer than DetailsTip 54：Use a Project GlossaryTip 55：Don’t Think Outside the Box - Find the Box面对棘手的问题时，列出所有在你面前可能途径。不要排除任何东西，不管它听起来有多无用或愚蠢。 Tip 56：Listen to Nagging Doubts - Start When You’re ReadyTip 57：Some Things Are Better Done than DescribedTip 58： Don’t Be a Slave to Formal Methods如果在仔细分析后，你觉得需要使用形式方法，那就采用它。但要记住谁是主人。不要变成方法学的奴隶。 Tip 59：Expensive Tools Do Not Produce Better DesignsTip 60：Organize Around Functionality, Not Job Functions质量只可能源于全体团队人员都做出自己的贡献。 Tip 61：Don’t Use Manual Procedures让计算机去做重复、平常的事情 — 它会做的比我们更好。我们有更重要、更困难的事情要做。 Tip 62：Test Early，Test More，Test Automatically编一点，测一点。bug 被发现得越早，进行修补的成本就越低。 Tip 63：Coding Ain’t Done Til All the Tests RunTip 64：User Saboteurs to Test Your Testing编写测试时，确保警报在应该响起时响起。 Tip 65： Test State Coverage，Not Code CoverageTip 66： Find Bugs Once一旦测试员找到一个bug，这应该是测试员最后一次找到它。此后自动测试应该对其进行检查。 Tip 67：Treat English as Just Another Programming LanguageTip 68：Build Documentation In，Don’t Bolt It On一般而言，注释应该讨论为何要做某事、它的目的和目标。 Tip 69：Gently Exceed Your Users’ Expectations项目的成功是由它在多大程度上满足了用户的期望来衡量的。 Tip 70：Sign Your Work过去时代的手艺人在能为他们的作品上签名而自豪 。你也应该如此。 结束语读完一本书不难。难得就是在生活中去践行书中的方法论，去验证是否说的有道理，希望自己在以后的生活和学习中能够慢一些、收获多一些。","tags":[{"name":"程序员修炼之道","slug":"程序员修炼之道","permalink":"http://yoursite.com/tags/程序员修炼之道/"}]},{"title":"关于集成极光推送","date":"2016-11-11T09:40:09.000Z","path":"2016/11/11/Jiguang-Push/","text":"版权声明：本文为 muhlenXi 原创文章，欢迎转载，转载请注明来源 前言： 通过极光推送服务，主动及时地向您的用户发起交互，向其发送聊天消息、日程提醒、活动预告、进度提示、动态更新等。 学习贵在记录和总结收获！点击阅读全文了解更多！ 基础篇（集成步骤） 1、生成CSR文件 钥匙串访问 -&gt; 证书助理 -&gt; 从证书颁发机构请求证书… 2、在 苹果开发者网站 登录后，创建 App ID Account -&gt; Certificates,Identifiers&amp;Profiles -&gt; App IDs -&gt; + 3、生成远程推送的测试证书 测试证书： Development -&gt; Apple Push Notification service SSL (Sandbox) 4、生成远程推送的生产证书 生产证书： Production -&gt; Apple Push Notification service SSL (Sandbox &amp; Production) 创建好后分别下载到电脑上，然后双击运行。 5、添加真机 Device （添加过的可以忽略） 6、创建配置文件 Provisioning Profiles 创建好后下载到电脑上，然后双击运行。 7、将推送证书导出并生成 .p12 文件 Apple Development IOS Push Services: 你项目的Bundle identifier 就是在测试环境下的推送证书。 Apple Push Services: 你项目的Bundle identifier 就是生产环境下的证书. 8、在极光开发者中心创建项目并上传刚生成的两个p12文件. 9、下载极光 SDK 并配置项目。 具体配置看iOS SDK 集成指南 提高篇感谢您的阅读，一起学习，一起成长，加油！","tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://yoursite.com/tags/Objective-C/"},{"name":"极光推送","slug":"极光推送","permalink":"http://yoursite.com/tags/极光推送/"}]},{"title":"Swift开发者必备Tips - 学习笔记","date":"2016-10-26T04:08:31.000Z","path":"2016/10/26/Swift-Tips/","text":"版权声明：本文为 muhlenXi 原创文章，欢迎转载，转载请注明来源。 前言： 这本书是王巍的关于Swift语言的知识点的集合，是作者学习和实践Swift的一些心得，作者以一个个的小技巧和知识点的形式，编写成了这本书，是中级开发人员的Swift进阶读本，该书涵盖了一个中高级开发人员需要知道的Swift语言的方方面面。 点击阅读全文来了解一下详情吧。 正文柯里化（Currying）就是把接收多个参数的方法进行一些变形，使其更加灵活的方法。 Swift的mutating关键字修饰方法是为了能在该方法中修改struct或enum的变量。 @autoclosure做的事情就是把一句表达式自动地封装成一个闭包（closure） ??操作符可以快速地对nil进行条件判断，当??左侧的值为nil时返回右侧的值，否则返回左侧的值。 1234let level:Int? = nillet startLevel = 1let currentLevel = level ?? startLevelprint(currentLevel) //output 1 Swift中我们可以定义一个接受函数作为参数的函数，而在调用时，使用闭包的方式来传递这个参数是常见手段。 函数中的参数（是函数）在异步线程中操作的时候，我们需要在block的类型前加上@escaping标记来表明这个闭包是会逃逸出该方法的。","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/tags/学习笔记/"},{"name":"Swift开发者必备Tips","slug":"Swift开发者必备Tips","permalink":"http://yoursite.com/tags/Swift开发者必备Tips/"}]},{"title":"关于 GCD","date":"2016-10-09T02:02:59.000Z","path":"2016/10/09/GCD/","text":"版权声明：本文为 muhlenXi 原创文章，欢迎转载，转载请注明来源。 前言： GCD 是 Grand Central Dispatch 的缩写。GCD 是一个底层框架，它可以通过操作系统来管理并发和异步执行任务。 学习贵在记录和总结收获！点击阅读全文了解更多！ 正文在主线程中执行1234dispatch_async(dispatch_get_main_queue(), ^&#123; NSLog(@\"主线程执行\");&#125;); 异步线程执行1234dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; NSLog(@\"异步执行\");&#125;); 一次线程执行1234static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; NSLog(@\"只执行一次\");&#125;); 延迟执行1234dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; NSLog(@\"延迟五秒执行\");&#125;); 在自定义线程中执行123456dispatch_queue_t my_que = dispatch_queue_create(\"blog.muhlenxi.com\", NULL);dispatch_async(my_que, ^&#123; NSLog(@\"自定义线程汇中执行\"); &#125;); 多线程并行执行12345678910111213141516171819202122232425dispatch_group_t group = dispatch_group_create(); dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; NSLog(@\"并行线程，下载图片1\"); sleep(1);&#125;); dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; NSLog(@\"并行线程，下载图片2\"); sleep(2);&#125;); dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; NSLog(@\"并行线程，下载图片3\"); sleep(3);&#125;); dispatch_group_notify(group, dispatch_get_global_queue(0, 0), ^&#123; NSLog(@\"这里汇总下载图片结果\"); &#125;); 感谢您的阅读，一起学习，一起成长，加油！","tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://yoursite.com/tags/Objective-C/"},{"name":"GCD","slug":"GCD","permalink":"http://yoursite.com/tags/GCD/"}]},{"title":"iOS开发图片那些事儿","date":"2016-09-30T06:17:09.000Z","path":"2016/09/30/About-Images/","text":"版权声明：本文为 muhlenXi 原创文章，欢迎转载，转载请注明来源。 前言： APP 开发中，一些 UI 界面的设计常常涉及到 UIImageView 的使用，这和图片是分不开的，随着开发的渐渐深入，要记住的东西越来越多，但我是一个懒人，暂且就把关于图片的知识就放这儿吧。。 点击阅读全文来了解一下详情吧。 iPhone 尺寸规格 设备(iPhone) 对角线(Diagonal) 逻辑分辨率(point) 设备分辨率(pixel) Scale Factor 3GS 3.5-inch 320x480 320x480 @1x 4/4S 3.5-inch 320x480 640x960 @2x 5/5S/5C 4-inch 320x568 640x1136 @2x 6/6S 4.7-inch 375x667 750x1334 @2x 6plus 5.5-inch 414x736 1242x2208 1080x1920 @3x App Logo 尺寸规格logo：适配 iOS7.0 and Later logo命名 图片规格 分辨率 logo20@2x.png @2x 40x40 logo20@3x.png @3x 60x60 logo29@2x.png @2x 58x58 logo29@3x.png @3x 87x87 logo40@2x.png @2x 80x80 logo40@3x.png @3x 120x120 logo60@2x.png @2x 120x120 logo60@3x.png @3x 180x180 logoAppstore@2x.png @2x 1024x1024 App LaunchImage 尺寸规格launchImage：适配 iOS7.0 and Later launchImage：适配 iOS8.0 and Later launchImage命名 图片规格 分辨率 launchImage960@2x.png @2x 640x960 launchImage1136@2x.png @2x 640x1136 launchImage1334@2x.png @2x 750x1334 launchImage2208@3x.png @3x 1242x2208 App 初次安装引导页 尺寸规格launchImage：适配 iOS7.0 and Later launchImage命名 图片规格 分辨率 guide4@2x.png @2x 640x960 guide5@2x.png @2x 640x1136 guide6@2x.png @2x 750x1334 guide6P@3x.png @3x 1242x2208 App 启动广告页 尺寸规格launchImage：适配 iOS7.0 and Later launchImage命名 图片规格 分辨率 ad4@2x.png @2x 640x960 ad5@2x.png @2x 640x1136 ad6@2x.png @2x 750x1334 ad6P@3x.png @3x 1242x2208 本文会不间断更新，如有问题，可以留言给我！最后谢谢阅读！","tags":[{"name":"iOS开发图片","slug":"iOS开发图片","permalink":"http://yoursite.com/tags/iOS开发图片/"}]},{"title":"UITabBarController 的详细运用","date":"2016-09-05T06:42:25.000Z","path":"2016/09/05/UITabBarController/","text":"版权声明：本文为 muhlenXi 原创文章，欢迎转载，转载请注明来源。 导语： iPhone 和 iPod touch 都可以使用 UITabBarController 类，令用户能够在多个视图控制器之间切换，并且能够定制屏幕底部的标签栏。用户只需点击一下屏幕，就能切换到其他视图，而且还可以通过 More 按钮来选择并编辑需要显示在屏幕底部标签栏里的标签（Tab）。 写个 demo 玩一下，实践是检验真理的唯一标准。 创建系统 Item【1】在 AppDelegate 的 didFinishLaunchingWithOptions 方法中,我们初始化一个UITabBarController 和 11个 UIViewController ：代码如下 1234567891011121314151617181920212223242526272829//1.初始化TabBarControllerUITabBarController * tabbarC = [[UITabBarController alloc] init];//2.初始化ViewControllersFirstViewController * firstVC = [[FirstViewController alloc] initWithNibName:@\"FirstViewController\" bundle:nil];UINavigationController * firstNav = [[UINavigationController alloc] initWithRootViewController:firstVC];SecondViewController * secondVC = [[SecondViewController alloc] initWithNibName:@\"SecondViewController\" bundle:nil];UINavigationController * secondNav = [[UINavigationController alloc] initWithRootViewController:secondVC];ThirdViewController * thirdVC = [[ThirdViewController alloc] initWithNibName:@\"ThirdViewController\" bundle:nil];UINavigationController * thirdNav = [[UINavigationController alloc] initWithRootViewController:thirdVC];FourthViewController * fourthVC = [[FourthViewController alloc] initWithNibName:@\"FourthViewController\" bundle:nil];UINavigationController * fourthNav = [[UINavigationController alloc] initWithRootViewController:fourthVC];FifthViewController * fifthVC = [[FifthViewController alloc] initWithNibName:@\"FifthViewController\" bundle:nil];UINavigationController * fifthNav = [[UINavigationController alloc] initWithRootViewController:fifthVC];SixthViewController * sixthVC = [[SixthViewController alloc] initWithNibName:@\"SixthViewController\" bundle:nil];UINavigationController * sixNav = [[UINavigationController alloc] initWithRootViewController:sixthVC];SeventhViewController * seventhVC = [[SeventhViewController alloc] initWithNibName:@\"SeventhViewController\" bundle:nil];UINavigationController * sevenNav = [[UINavigationController alloc] initWithRootViewController:seventhVC];EighthViewController * eighthVC = [[EighthViewController alloc] initWithNibName:@\"EighthViewController\" bundle:nil];UINavigationController * eightNav = [[UINavigationController alloc] initWithRootViewController:eighthVC];NinthViewController * ninthVC = [[NinthViewController alloc] initWithNibName:@\"NinthViewController\" bundle:nil];UINavigationController * nineNav = [[UINavigationController alloc] initWithRootViewController:ninthVC];TenthViewController * tenVC = [[TenthViewController alloc] initWithNibName:@\"TenthViewController\" bundle:nil];UINavigationController * tenNav = [[UINavigationController alloc] initWithRootViewController:tenVC];EleventhViewController * elevenVC = [[EleventhViewController alloc] initWithNibName:@\"EleventhViewController\" bundle:nil];UINavigationController * elevenNav = [[UINavigationController alloc] initWithRootViewController:elevenVC];//3.设置viewControllersNSArray * array = @[firstNav,secondNav,thirdNav,fourthNav,fifthNav,sixNav,sevenNav,eightNav,nineNav,tenNav,elevenNav];tabbarC.viewControllers = array; tabbarC.customizableViewControllers = array; //编辑模式 【2】分别在每个Controller的.m文件中重写 initWithNibName 方法，代码如下： 1234567891011- (instancetype)initWithNibName:(NSString *)nibNameOrNil bundle:(NSBundle *)nibBundleOrNil&#123; self = [super initWithNibName:nibNameOrNil bundle:nibBundleOrNil]; if (self) &#123; //创建系统TabBarItem并设置 UITabBarItem * item = [[UITabBarItem alloc] initWithTabBarSystemItem:UITabBarSystemItemMostViewed tag:0]; self.tabBarItem = item; &#125; return self;&#125; 注意：系统共有一下十二种样式的 TabbarItem 0 - UITabBarSystemItemMore, 1 - UITabBarSystemItemFavorites, 2 - UITabBarSystemItemFeatured, 3 - UITabBarSystemItemTopRated, 4 - UITabBarSystemItemRecents, 5 - UITabBarSystemItemContacts, 6 - UITabBarSystemItemHistory, 7 - UITabBarSystemItemBookmarks, 8 - UITabBarSystemItemSearch, 9 - UITabBarSystemItemDownloads, 10 - UITabBarSystemItemMostRecent, 11 - UITabBarSystemItemMostViewed, 编译并运行代码，会出现如下的界面： 如果视图控制器中的控制器的数量超过5个时，就会使用导航控制器管理剩余的视图控制器，并且将导航控制器作为第五个视图控制器。 设置 tabBarController 的代理。点击最后一个 More 标签，进入 More 界面，点击 Edit 后，长按拖动 Item，替换靠前的 Item，我们会发现，这时候 Tabbar 的 Item 的排列顺序发生了改变，记住此时的顺序。然后重新运行 APP，会发现则又恢复到了编辑前的顺序了，若要保存编辑的后顺序，我们需通过 NSUserDefaults 来保存排序后的数组。 【1】设置代理 1tabbarC.delegate = self; 【2】实现相应的代理方法 点击 选中 会触发这两个方法 1234567891011121314 - (BOOL)tabBarController:(UITabBarController *)tabBarController shouldSelectViewController:(UIViewController *)viewController&#123; NSLog(@\"tabBarController -- shouldSelectViewController\"); UINavigationController * nav = (UINavigationController *)viewController; if ([nav.topViewController isKindOfClass:[SecondViewController class]]) &#123; //第二个tabbarItem不能选中 return NO; &#125; return YES;&#125;- (void)tabBarController:(UITabBarController *)tabBarController didSelectViewController:(UIViewController *)viewController&#123; NSLog(@\"tabBarController --- didSelectViewController\");&#125; 点击 编辑 后会触发这个方法 1234- (void)tabBarController:(UITabBarController *)tabBarController willBeginCustomizingViewControllers:(NSArray&lt;__kindof UIViewController *&gt; *)viewControllers&#123; NSLog(@\"tabBarController --- willBeginCustomizingViewControllers\");&#125; 点击 完成 后会触发这两个方法 1234- (void)tabBarController:(UITabBarController *)tabBarController willEndCustomizingViewControllers:(NSArray&lt;__kindof UIViewController *&gt; *)viewControllers changed:(BOOL)changed&#123; NSLog(@\"tabBarController --- willEndCustomizingViewControllers\");&#125; 在这个方法中保存编辑后的 tabbarItem 的数组 123456789101112- (void)tabBarController:(UITabBarController *)tabBarController didEndCustomizingViewControllers:(NSArray&lt;__kindof UIViewController *&gt; *)viewControllers changed:(BOOL)changed&#123; NSLog(@\"tabBarController --- didEndCustomizingViewControllers\"); //获取并保存 NSMutableArray * endEditArray = [NSMutableArray array]; for (UINavigationController * nav in viewControllers) &#123; NSString * name = NSStringFromClass([nav.topViewController class]); [endEditArray addObject:name]; &#125; [[NSUserDefaults standardUserDefaults] setObject:endEditArray forKey:@\"ItemArray\"]; [[NSUserDefaults standardUserDefaults] synchronize]; &#125; 【3】在 didFinishLaunchingWithOptions 方法中，修改tabbarC.viewControllers的设置。 修改如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243UITabBarController * tabbarC = [[UITabBarController alloc] init]; tabbarC.delegate = self;NSMutableArray * getItemArray = [[NSUserDefaults standardUserDefaults] objectForKey:@\"ItemArray\"]; if (getItemArray == nil) &#123; FirstViewController * firstVC = [[FirstViewController alloc] initWithNibName:@\"FirstViewController\" bundle:nil]; UINavigationController * firstNav = [[UINavigationController alloc] initWithRootViewController:firstVC]; SecondViewController * secondVC = [[SecondViewController alloc] initWithNibName:@\"SecondViewController\" bundle:nil]; UINavigationController * secondNav = [[UINavigationController alloc] initWithRootViewController:secondVC]; ThirdViewController * thirdVC = [[ThirdViewController alloc] initWithNibName:@\"ThirdViewController\" bundle:nil]; UINavigationController * thirdNav = [[UINavigationController alloc] initWithRootViewController:thirdVC]; FourthViewController * fourthVC = [[FourthViewController alloc] initWithNibName:@\"FourthViewController\" bundle:nil]; UINavigationController * fourthNav = [[UINavigationController alloc] initWithRootViewController:fourthVC]; FifthViewController * fifthVC = [[FifthViewController alloc] initWithNibName:@\"FifthViewController\" bundle:nil]; UINavigationController * fifthNav = [[UINavigationController alloc] initWithRootViewController:fifthVC]; SixthViewController * sixthVC = [[SixthViewController alloc] initWithNibName:@\"SixthViewController\" bundle:nil]; UINavigationController * sixNav = [[UINavigationController alloc] initWithRootViewController:sixthVC]; SeventhViewController * seventhVC = [[SeventhViewController alloc] initWithNibName:@\"SeventhViewController\" bundle:nil]; UINavigationController * sevenNav = [[UINavigationController alloc] initWithRootViewController:seventhVC]; EighthViewController * eighthVC = [[EighthViewController alloc] initWithNibName:@\"EighthViewController\" bundle:nil]; UINavigationController * eightNav = [[UINavigationController alloc] initWithRootViewController:eighthVC]; NinthViewController * ninthVC = [[NinthViewController alloc] initWithNibName:@\"NinthViewController\" bundle:nil]; UINavigationController * nineNav = [[UINavigationController alloc] initWithRootViewController:ninthVC]; TenthViewController * tenVC = [[TenthViewController alloc] initWithNibName:@\"TenthViewController\" bundle:nil]; UINavigationController * tenNav = [[UINavigationController alloc] initWithRootViewController:tenVC]; EleventhViewController * elevenVC = [[EleventhViewController alloc] initWithNibName:@\"EleventhViewController\" bundle:nil]; UINavigationController * elevenNav = [[UINavigationController alloc] initWithRootViewController:elevenVC]; NSArray * array = @[firstNav,secondNav,thirdNav,fourthNav,fifthNav,sixNav,sevenNav,eightNav,nineNav,tenNav,elevenNav]; getItemArray = [NSMutableArray arrayWithArray:array]; &#125; else &#123; NSMutableArray * items = [NSMutableArray array]; for (NSString * name in getItemArray) &#123; //根据记录的类名创建 UIViewController *vc = [[NSClassFromString(name) alloc] init]; UINavigationController * nav = [[UINavigationController alloc] initWithRootViewController:vc]; [items addObject:nav]; &#125; getItemArray = [[NSMutableArray alloc] initWithArray:items]; &#125; tabbarC.viewControllers = getItemArray; tabbarC.customizableViewControllers = getItemArray; //编辑模式 运行代码后，编辑并保存后。关闭 APP，再打开，会发现是编辑后的顺序了 NavigationBar 和 Tabbar 的外观设置这里是 NavigationBa r的外观的全局设置 1234567891011 //设置状态栏的字体颜色 [[UIApplication sharedApplication] setStatusBarStyle:UIStatusBarStyleLightContent];//设置NavgationBar的字体大小和字体颜色 [[UINavigationBar appearance] setTitleTextAttributes: [NSDictionary dictionaryWithObjectsAndKeys: NavgationTitle_Color, NSForegroundColorAttributeName,S20Font, NSFontAttributeName, nil]]; //设置NavgationBar的背景颜色 [UINavigationBar appearance].barTintColor = NavgationBar_Color; //设置NavgationBar的Item的颜色 [[UINavigationBar appearance] setTintColor:NavgationTitle_Color]; //设置导航栏不透明 [UINavigationBar appearance].translucent = NO; 这里是 TabBar 的外观的全局设置 12345678//设置标题栏不透明[UITabBar appearance].translucent = NO;//设置标签栏的背景颜色[UITabBar appearance].barTintColor = TabBar_Color;//未选中字体颜色[[UITabBarItem appearance] setTitleTextAttributes:[NSDictionary dictionaryWithObjectsAndKeys:TabBarItem_DisselectedColor,NSForegroundColorAttributeName,S12Font,NSFontAttributeName, nil] forState:UIControlStateNormal];//选中字体颜色[[UITabBarItem appearance] setTitleTextAttributes:[NSDictionary dictionaryWithObjectsAndKeys:TabBarItem_SelectedColor,NSForegroundColorAttributeName,S12Font,NSFontAttributeName, nil] forState:UIControlStateSelected]; 一般TabbarItem 的创建【1】在AppDelegate的 didFinishLaunchingWithOptions 方法中,我们初始化一个UITabBarController 和4个 UIViewController,并做一些简单的设置就可以了，代码如下： \u0010\u0010123456789101112131415161718192021222324252627282930313233343536373839//oneOneViewController * oneVC = [[OneViewController alloc]init];UINavigationController * oneNav = [[UINavigationController alloc]initWithRootViewController:self.oneVC];//twoTwoViewController * twoVC = [[TwoViewController alloc]init];UINavigationController * twoNav = [[UINavigationController alloc]initWithRootViewController:self.twoVC];//threeThreeViewController * threeVC = [[ThreeViewController alloc]init];UINavigationController * threeNav = [[UINavigationController alloc]initWithRootViewController:self.threeVC];//fourFourViewController * fourVC = [[FourViewController alloc]init];UINavigationController *fourNav = [[UINavigationController alloc]initWithRootViewController:self.fourVC];//加TabBarControllerUITabBarController *tabBarController = [[UITabBarController alloc] init];tabBarController.viewControllers = @[oneNav,twoNav,threeNav,fourNav];//设置tabbar相关属性UITabBar *tabBar = tabBarController.tabBar;UITabBarItem *oneItem = [tabBar.items objectAtIndex:0];UITabBarItem *twoItem = [tabBar.items objectAtIndex:1];UITabBarItem *threeItem = [tabBar.items objectAtIndex:2];UITabBarItem *fourItem = [tabBar.items objectAtIndex:3];//设置标题oneItem.title = @\"One\";twoItem.title = @\"Two\";threeItem.title = @\"Three\";fourItem.title = @\"Four\";//设置图片//设置一般图片[oneItem setImage:[[UIImage imageNamed:@\"tabbar_contacts\"]imageWithRenderingMode:UIImageRenderingModeAlwaysOriginal ]];//设置选中照片[oneItem setSelectedImage:[[UIImage imageNamed:@\"tabbar_contactsHL\"] imageWithRenderingMode:UIImageRenderingModeAlwaysOriginal ]];[twoItem setImage:[[UIImage imageNamed:@\"tabbar_discover\"]imageWithRenderingMode:UIImageRenderingModeAlwaysOriginal]];[twoItem setSelectedImage:[[UIImage imageNamed:@\"tabbar_discoverHL\"]imageWithRenderingMode:UIImageRenderingModeAlwaysOriginal]];[threeItem setImage:[[UIImage imageNamed:@\"tabbar_mainframe\"]imageWithRenderingMode:UIImageRenderingModeAlwaysOriginal]];[threeItem setSelectedImage:[[UIImage imageNamed:@\"tabbar_mainframeHL\"]imageWithRenderingMode:UIImageRenderingModeAlwaysOriginal]];[fourItem setImage:[[UIImage imageNamed:@\"tabbar_me\"]imageWithRenderingMode:UIImageRenderingModeAlwaysOriginal]];[fourItem setSelectedImage:[[UIImage imageNamed:@\"tabbar_meHL\"]imageWithRenderingMode:UIImageRenderingModeAlwaysOriginal]];//设置window的跟视图控制器self.window.rootViewController = tabBarController; 编译并运行代码，会出现如下的界面： 自定义Tabbar【1】新建一个继承于 XYJTabBarController 的 XYJTabBarController 控制器： 打开.m文件，在类扩展中，定义一个 UIImageView 的属性 customTabbar,代码如下: 1@property (nonatomic,strong) UIImageView * customTabbar; //!&lt; 自定义Tabbar ImageView 【2】在 viewDidLoad 中初始化相关页面 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//创建要放在TabBarController中的视图控制器 //one OneViewController * oneVC = [[OneViewController alloc] init]; UINavigationController * oneNav = [[UINavigationController alloc] initWithRootViewController:oneVC]; //two TwoViewController * twoVC = [[TwoViewController alloc] init]; UINavigationController * twoNav = [[UINavigationController alloc] initWithRootViewController:twoVC]; //three ThreeViewController * threeVC = [[ThreeViewController alloc] init]; UINavigationController * threeNav = [[UINavigationController alloc] initWithRootViewController:threeVC]; //four FourViewController * fourVC = [[FourViewController alloc] init]; UINavigationController * fourNav = [[UINavigationController alloc] initWithRootViewController:fourVC]; //设置viewControllers self.viewControllers = @[oneNav,twoNav,threeNav,fourNav]; //自定义tabbar //1.隐藏系统的tabbar self.tabBar.hidden = YES; //2.初始化customTabbar self.customTabbar = [[UIImageView alloc] initWithFrame:CGRectMake(0, self.view.bounds.size.height-49, self.view.bounds.size.width, 49)]; self.customTabbar.image = [UIImage imageNamed:@\"tabbar_bg\"]; //打开用户交互 self.customTabbar.userInteractionEnabled = YES; [self.view addSubview:self.customTabbar]; //3.给tabbar添加按钮 CGFloat width = self.view.bounds.size.width / 4; //去沙盒读取状态选择 NSUserDefaults *userDefaults = [NSUserDefaults standardUserDefaults]; NSNumber *index = [userDefaults objectForKey:@\"tabbarSelectedIndex\"]; if (index == nil) &#123; //默认选中第一个Item index = @(0); &#125; for (int i = 0; i &lt; 4; i++) &#123; //创建按钮 UIButton *btn = [UIButton buttonWithType:UIButtonTypeCustom]; btn.frame = CGRectMake(width * i, 0, width, 49); //设置正常状态的图片 UIImage *image = [UIImage imageNamed:[NSString stringWithFormat:@\"tab%d_n@2x\", i+1]]; [btn setImage:image forState:UIControlStateNormal]; //设置选中状态的图片 UIImage *selectImage = [UIImage imageNamed:[NSString stringWithFormat:@\"tab%d_s@2x\", i+1]]; [btn setImage:selectImage forState:UIControlStateSelected]; if (i == index.integerValue) &#123; btn.selected = YES; //设置选中状态 &#125; //设置tag btn.tag = i + 100; //添加事件，改变选中状态 [btn addTarget:self action:@selector(btnAction:) forControlEvents:UIControlEventTouchUpInside]; [self.customTabbar addSubview:btn]; &#125; 【3】在AppDelegate的 didFinishLaunchingWithOptions 方法中,我们初始化自定义的TabBarController，并将其设置为 Window 的rootViewController：代码如下 12XYJTabBarController * tabbarController = [[XYJTabBarController alloc] init];self.window.rootViewController = tabbarController; 编译并运行代码，会出现如下的界面： 感谢阅读，TabarController的学习暂时到这里为止","tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://yoursite.com/tags/Objective-C/"},{"name":"UITabBarController","slug":"UITabBarController","permalink":"http://yoursite.com/tags/UITabBarController/"}]},{"title":"把你的英语用起来---读书笔记","date":"2016-08-26T03:00:55.000Z","path":"2016/08/26/Use-your-English/","text":"版权声明：本文为 muhlenXi 原创文章，欢迎转载，转载请注明来源。 导读 这是一本英语学习书。本书适合特别想提高自己的英语能力而不得的人。很多学了 6~10 年的英语的人还是不能阅读英文的资料。想找培训机构，发现针对考试的比较多，费用也很高。在网上跟着大家一起背单词，又枯燥又难以坚持，效果也不是很好。不停的想学英语，但总是拿起又放下，放下又拿起，断断续续，英语水平一直没有得到提高。 从阅读本书开始，真正的把你的英语用起来! 坚持的方法和策略 1、尽量杜绝社交网站的影响。 2、用记事本来监控自己的学习流程。 3、列计划的时候绝对不要自我期望过高。 4、养成立即行动的习惯。 5、要主动养成正面的自我激励模式。 6、养成早睡早起的习惯。 做记录的实用技巧: 首先列出整体的学习计划，然后记录完成多少或者有什么新想法。 记录时间以天为单位，也可以两三天记录一下。 要时刻记录下自己的收获，把自己的英语水平时时都记录下来。 完成重大突破时，可以去庆祝一下，达到自我激励的作用。 寻找闲余时间策略: 和电视剧说拜拜。 不要晚上学习，把学习时间调整到早上。 零碎时间和大块时间穿插创造奇迹。 透析法大战播讲类资料初级通关: 奶爸说：从听说入手，容易让大家有收获感，更能对英文感兴趣，这样越学越想学。 赖世雄 美语从头学 一套，包含以下七本 1.美语入门 2.美语音标 3.初级美语 上 4.初级美语 下 5.中级美语 上 6.中级美语 下 7.高级美语 使用播讲类资料 【1】英文听说透析法 【2】艾宾浩斯复习表格 环节一 攻克英语发音（2~3周）材料:《赖世雄美语音标》 方法：看书听CD，跟着录音大声模仿。 建议：2~3周内，本书至少学习2~3遍 环节二，ESLPOD,英语学习播客，（3~4个月）(English As a Second Language Podcast) 共六本教材： 1.Introduction to the United States 2.A Day in the Life of Jeff 3.A Day in the Life of Lucy 4.Interview Questions Answered 5.English for Business Meeting 6.Using English at Work 中国人的发音难点:基础篇 1. 美音的R怎么发 2. 发好L音和N音 3. 发好长短音/u/和/u:/ 4. 区分好/i/和/i:/ 进阶篇 1.失去爆破 凡是出现爆破音结尾的，不管下一个单词是什么音开头，统统不发出声音，只简单停顿0.1秒。 2.注意at的读法 3.美音中的音变，也就是所谓的浊化现象 T在末尾，如果要连续的话，即下一个单词以原因开头，那么绝大部分情况下，T是要浊化成D的。 T在中间，一般情况下也是读成D,准确来说，是读成近似于D的音。 H音的省略。 4.美音中的连读规则 中级修炼环节一 发音复习课2-3周 【1】American Pronunciation Workshop (美语发音教程) APW一共16个视频，每个视频在20分钟左右，每天一个视频可以看好多遍，请在两周内完成这个任务。 【2】爱荷华大学的口腔剖面 环节二 突破常速多口音的EnglishPod 一共有 365 期 附录2.1为精选100期 学习方法：deep learning narrow input (狭窄输入) 高级修炼: 警告：我们默认适合这本书的同学的基础大约是，要么完成100期的练习，要么可以较为流畅地听懂常速度的英文了。这本书语速很快，而且是全英文写成，对大部分同学来说，难度很大，绝不适合基础一般的同学学习，请确定自己基础达到了再尝试，否则事倍功半。 American Accent Training Ann Cook 即标准美语发音的13秘诀 学习方法：1、先扫一遍目录，诵读编排结构 2、一边看书，一边听CD，从头到尾反复听几遍。 3、一个个章节的重点突破，去做每个章节练习题。 4、模仿录音，矫正发音。 英语语法学习 《文法俱乐部》 旋元佑 英文文法是以句子为主要的研究单位。学文法的目的，就是要看懂英文句子，包括发杂的、难懂的句子，更进一步就能写出正确的，有变化的句子。 英文有声书 Audiobook推荐的英文有声书 audiobook: I Capture the Castle 我的秘密城堡 Never Let Me Go 别让我走 Where the Mountain Meets the Moon 月夜仙踪 Happy Prince 快乐王子 I,Robot 机械公敌 Percy Jackson 波西杰克逊 Artemis Fowl 精灵事件 Harry Potter 哈利波特 Neil Gaiman先生的所有图书 《Graveyard Book 坟场之书》《 Caroline 卡罗兰》 Nicholas Sparks 《Message in a Bottle 瓶中信》 Benedict Cumberbatch 《Casanova 卡萨诺瓦》 删节版 《Dear Joho 分手信》 有声书比较出名的演员: Anne Hathaway 安妮海瑟薇 《公主日记》 Benedict Cumberbatch 本尼迪克特康伯巴奇 《神探夏洛克》 Martin Freeman 马丁弗里曼 《银河漫游指南》 Stephen Fry 斯蒂芬弗雷 《Harry Potter》《维尼熊》《王尔德的一些短篇》《福克斯先生》 R alph Fiennes 拉尔夫范恩斯《The English Patient》 Dan Stevens 《战马》 David Tennant 《大卫田纳特》《Doctor Who 神秘博士》《How to Train Your Dragon 驯龙记》 Alan Rickman 艾伦里克曼 《还乡记》 Emilia Fox 艾米丽雅福克斯 《Pride and Prejudice 》《Never Let Me Go》 大师类作品 Scott Brick 《基地和机器人》 Juliet Stevenson Samule West Frank Muller 《The Dark Tower 黑暗塔》 John Lee 《三个火枪手》 《基督山伯爵》 透析法大战英文原著 伍老师说：把英语用起来，就是在真实的生活中使用这门语言，要求听、说、读、写全部实现英文原著化。 听：听实时的英语新闻，从BBC、CNN到AI Jazeera 说：就是用英语聊天，从身边的熟人到网络另一端的老外。 读：就读老外的英文版，从短信、邮件、到大部头的专著。 写：就写英文邮件、短信给亲友同事乃至生意上的伙伴。 常用的英文原著电子书免费下载网站： 【1】古登堡计划 【2】很多书 【3】feedbooks 【4】原版英语论坛 【5】七彩英语 【6】掌上书苑 注意：选定原著之后，需从一而终，一读到底，浅尝辄止是读书的大忌。 生词量:看首万词不重复词数 测量词汇量 蓝思值:句子复杂程度的科学测算 蓝思官网 核心操作:每两页查一个生词 在生词丛中抓住原著的大意。 每日复习原著生词不超过5分钟. 保证透析成功的训练计划 七天行动:必须义无反顾执行 1、置之死地而后生 2、欲速则不达 3、读到翻页之前绝不做其他事情 4、长期激励：承诺一年读10本原著 5、每读完一本书就写透析记录 一网打尽各种形式的英文原著 1、循序渐进，先打好长篇基础 2、进军短篇，读尽天下英语新闻 3、每月研究一个英文网站 4、每月研究一个英文台 5、透析英文歌，进驻全球乐坛 6、透析英文四暗影，进驻全球影坛 （1）不看字幕。 （2）大量的看。 （3）综合阅读。 推荐的英文原著： 小王子 麦田里的守望者 The Godfather 教父 The Hunt for Red October 猎杀红色十月 Steven Jobs Harry Potter Sherlock Holmes 福尔摩斯 Three Musketeers 三个火枪手 Lady Chatterley’s Lover 查泰莱夫人的情人 Tropic of Cancer 北回归线 商业小说 行业小说之王 Arthur Hailey 阿瑟黑利 The Moneychangers 钱商 商业励志书 Rich Dad,Poor Dad 商业教科书 Freakmics 《魔鬼经济学》 商业期刊 Fortune 《财富》 后记 生活中，我们每个人或许都懂一些大道理，也许仅仅是知道而已，有多少人去规规矩矩的实践呢，又有多少人，能不间断的坚持去做一件事情呢，即使是简单的按时吃饭，早睡早起。这个世界，存在雄鹰一样精英的人物，也存在蜗牛式默默不断前进的小人物。我或许是一只小蜗牛，但是，我不放弃，每天去坚持做几件小事，付出行动，知行统一，才能有所收获。愿不就的将来，你可以成为一个极速蜗牛！ PS:我最喜欢的一幅图","tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/tags/读书笔记/"},{"name":"把你的英语用起来","slug":"把你的英语用起来","permalink":"http://yoursite.com/tags/把你的英语用起来/"}]},{"title":"初识 Swift3","date":"2016-08-19T01:37:28.000Z","path":"2016/08/19/Swift3/","text":"版权声明：本文为 muhlenXi 原创文章，欢迎转载，转载请注明来源。 导语： Swift 是一个新的编程语言，使用它可以开发 iOS、macOS、watchOS 和 tvOS 等平台上的 APP ，它比 C 和 Objective-C 语言更好的胜任这项工作，Swift 采用安全的编程模式，它加入了一些现代的特色使得编程更加容易、更加灵活和更加有趣，Swift 基于成熟的受人喜爱的 Cocoa 和 CocoaTouch 框架，这是一个重新定义软件是如何开发的机会！Just enjoy it！。 点击阅读全文来了解一下详情吧。 Swift 之初体验单一变量在屏幕上打印 hello，world!1print(\"hello,world!\") 定义一个变量和改变变量的值12var myVariable = 42myVariable = 50 定义一个常量 1let myConstant = 38 我们定义常量和变量的时候可以不显示的声明常量或变量的数据类型，编译器会根据你设置的初始值去推测数据的类型。 带数据类型的常量的声明是这样的。 1let myWeight:Double = 54.0 字符串类型转换。123let label = \"the width is \"let width = 94let widthLabel = label + String(width) 还有个更简单的方式。 1234let apples = 3let oranges = 5let appleSummary = \"I hava \\(apples) apples\"let fruitSummary = \"I have \\(apples + oranges) pieces of fruit\" 定义一个不可变数组 1let animals = [\"猴子\",\"大象\",\"兔子\"] 定义一个可变数组 1234var fruitLists = [\"苹果汁\",\"香蕉\",\"梨\",\"葡萄\"]fruitLists[0] = \"苹果\" //修改 fruitLists.append(\"猕猴桃\") //增加 fruitLists.remove(at: 4) //删除 定义一个空的数组 1let animals = [String]() 定义一个不可变字典 1let wheelsOfCar = [\"独轮车\":1,\"自行车\":2,\"小汽车\":4] 定义一个空的字典 1let emptyDictionary = [String: NSInteger]() 定义一个可变字典 1234var wheelsOfCar = [\"独轮车\":1,\"自行车\":2,\"小汽车\":4]wheelsOfCar[\"三轮车\"] = 3 //增加或修改wheelsOfCar.removeValue(forKey: \"三轮车\") //删除print(\"\\(wheelsOfCar)\") 控制流 if - else 条件判断语句 12345678910let scores = [75,43,103,87]var count = 0 for score in scores &#123; if score &gt; 50 &#123; count += 1 &#125; else &#123; count += 0 &#125; &#125;print(\"分数大于零的科目个数：\\(count)\") if或else后面的（）可以省略，但是 {} 不能省略！ 可选值操作12345678let optionalName:String? = \"张三\"var greeting = \"hello!\"if let name = optionalName &#123; greeting = \"hello,\\(name)\" &#125;else &#123; greeting = \"optionalName is nil\" //当名字为nil时会执行这句 &#125;print(greeting) 我们也可以用操作符 ?? 给可选值设定一个默认值，当可选值为 nil 时会自动以默认值填充！ 1234let nickName:String? = nillet defaultName = \"李四\"let informalGreeting = \"Hi \\(nickName ?? defaultName)\"print(informalGreeting) switch - case 条件判断语句1234567891011let vegetable = \"土豆\"switch vegetable &#123;case \"辣椒\": print(\"辣椒吃多了容易上火。\")case \"红薯\", \"土豆\": print(\"这种蔬菜淀粉含量比较高。\")case let x where x.hasSuffix(\"瓜\"): print(\"\\(x) 属于瓜类的一种\")default: print(\"这种蔬菜的信息暂未获得。\")&#125; 通过 for - in 来遍历数组或字典12345678910111213let intersetingNumbers = [\"素数\":[2,3,5,7,11,13],\"斐波纳契数\":[1,1,2,3,5,8],\"平方数\":[1,4,9,16,25]]var largest = 0//找出这些数中的值最大的数for (_,numbers) in intersetingNumbers &#123; for number in numbers &#123; if number &gt; largest &#123; largest = number &#125; &#125;&#125;print(largest) 可以通过 for-in 来控制循环次数123456789101112131415//全闭区间var sum = 0for i in 0...4 &#123; sum = sum + i //循环5次&#125;print(sum) //半开半闭区间var sum1 = 0for i in 0..&lt;4 &#123; sum1 = sum1 + i //循环4次&#125;print(sum1) while 循环 和 repeat - while 循环 12345678910111213//先判断后执行var n = 2while n &lt; 100 &#123; n = n * 2&#125;print(n) //输出128//先执行后判断 var m = 2repeat &#123; m = m * 2&#125;while m &lt; 100print(m) //输出128 函数 和 闭包用 func 声明一个函数，()中是参数，-&gt;后面是返回值的类型1234func greet(person: String,day :String) -&gt; String &#123; return \"你好 \\(person),今天是 \\(day)。\"&#125; 函数的调用： 12let str:String = greet(person: \"张三\", day: \"星期天\") //调用函数print(str) 禁止设置默认参数名当我们声明函数时不指定参数的名字时，参数的名字默认为形式参数的名字，当然，我们可以通过_来禁止设置默认参数名 1234func greet(_ person:String, on day:String) -&gt; String &#123; return \"Hello \\(person),today is \\(day)\"&#125; 方法调用是这样： 1print(greet(\"Tom\", on: \"Monday\")) 使用元组 (tuple) 来创建复合值123456789101112131415161718func calculateStatistics(scores:[Int]) -&gt; (min:Int,max:Int,sum:Int) &#123; var min = scores[0] var max = scores[0] var sum = 0 for score in scores &#123; if score &gt; max &#123; max = score &#125; else if score &lt; min &#123; min = score &#125; sum += score &#125; return (min,max,sum)&#125; 函数调用时这样的： 1234let statistics = calculateStatistics(scores: [5,3,100,25,4])print(\"min = \\(statistics.min)\")print(\"max = \\(statistics.max)\")print(\"sum = \\(statistics.2)\") 函数的参数个数也可以是不确定的 12345678func sumOf(numbers:Int...) -&gt; Int &#123; var sum = 0 for num in numbers &#123; sum += num &#125; return sum&#125; 调用是这样的： 12print(sumOf()) //输出0print(sumOf(numbers: 100,200,50)) //输出350 函数可以嵌套，嵌套的函数可以读取或修改外部函数的变量的值。123456789101112//函数定义func returnFifteen() -&gt; Int &#123; var y = 10 func add() &#123; y += 5 &#125; add() return y;&#125;//函数调用：print(returnFifteen()) 函数的 返回值 也可以是函数。123456789101112//生成一个增量器func makeIncrementer() -&gt; ((Int) -&gt; Int) &#123; func addOne(number:Int) -&gt; Int &#123; return number + 1 &#125; return addOne;&#125;//方法调用let increment = makeIncrementer()print(increment(7)) 函数的 参数 也可以是函数。1234567891011121314151617func lessThanTen(number:Int) -&gt; Bool &#123; return number &lt; 10&#125; //检查数组中是否包含小于10的元素func checkArray(list:[Int],condition:(Int) -&gt; Bool) -&gt; Bool &#123; for item in list &#123; if condition(item) &#123; return true &#125; &#125; return false&#125; 函数调用是这样的： 123let numbers = [18,9,17,12]let ret = checkArray(list: numbers, condition: lessThanTen)print(ret) 函数是闭包的一种特殊形式,可以用{}实现一个闭包，在闭包中用in来分离参数和返回值类型 。123456789let numbers = [20,19,7,12]//将数组中的元素的值加倍let mappedNumbers = numbers.map(&#123;number in number * 2&#125;)print(mappedNumbers)//逆序排列数组中的元素let sortedNumbers = numbers.sorted&#123;$0 &gt; $1&#125;print(sortedNumbers) 对象 和 类用 class 来创建一个类，属性的声明和常量、变量的声明方式一样，方法和函数的声明方式也一样。可以通过 init 来生成一个 initializer 来初始化对象。 可以通过 deinit 来生成一个 deinitializer，当对象被释放时做一些清理工作。 类的声明如下： 12345678910111213141516//声明一个几何体class Shape &#123; var numberOfSides = 0 //边的个数 var name :String //几何体的名字 init(name:String) &#123; self.name = name &#125; //简单描述 func simpleDescription() -&gt; String &#123; return \"这个叫\\(name)的几何体有\\(numberOfSides)条边\" &#125;&#125; 类的对象的生成： 123let shape = Shape.init(name: \"七边形\")shape.numberOfSides = 7print(shape.simpleDescription()) 类的继承如果该类是继承某一父类的子类，则声明子类的时候要用 :+ 父类名 来表明其继承自什么类。当没有父类的时候，可以省略不写。 当子类要覆写父类的方法时，子类方法前要添加关键词 override 声明一个继承Shape的Square类 123456789101112131415161718192021222324//正方形class Square: Shape &#123; var sideLength:Double //边长 init(sideLength:Double,name:String) &#123; self.sideLength = sideLength super.init(name: name) numberOfSides = 4 &#125; override func simpleDescription() -&gt; String &#123; return \"这个叫\\(name)的几何体有\\(numberOfSides)条边,边长为\\(sideLength)cm\" &#125; //计算面积 func area() -&gt; Double &#123; return sideLength * sideLength &#125; &#125; 子类对象的创建: 123let square = Square.init(sideLength: 4, name: \"正方形\")print(\"面积是：\\(square.area())\")print(square.simpleDescription()) 类的属性，也可以自己生成 getter 和 setter 方法：12345678910111213141516171819202122232425//等边三角形class EquialateralTriangle: Shape &#123; var sideLenth :Double = 0 init(sideLength:Double,name:String) &#123; self.sideLenth = sideLength super.init(name: name) numberOfSides = 3 &#125; //周长 var perimeter:Double &#123; set &#123; sideLenth = newValue / 3.0 &#125; get &#123; return sideLenth * 3.0 &#125; &#125; override func simpleDescription() -&gt; String &#123; return \"这是一个边长为\\(sideLenth)的等边三角形\" &#125;&#125; 等边三角形对象的创建: 1234567let triangle = EquialateralTriangle.init(sideLength: 5, name: \"等边三角形\")//获取周长print(\"周长是：\\(triangle.perimeter)\")triangle.perimeter = 12//获取修改周长后的边长print(\"边长是：\\(triangle.sideLenth)\")print(triangle.simpleDescription()) 枚举 和 结构体用 enum 来声明一个枚举，枚举中也可以关联函数第一个枚举值默认是0，我们也可以指定第一个枚举值为我们想要的值。 举个 🌰 ： 12345678910111213141516171819enum Direction : NSInteger &#123; case up = 1, down, left, right func description() -&gt; String &#123; switch self &#123; case .up: return \"向上\" case .down: return \"向下\" case .left: return \"向左\" case .right: return \"向右\" &#125; &#125;&#125; 调用如下： 1234let direc = Direction.downprint(direc)print(direc.rawValue)print(direc.description()) 我们也可以通过 rawValue 来初始化一个枚举的选项，得到的是一个可能值。 12let direc = Direction(rawValue: 2)print(direc!.description()) 枚举中的选项还可以和不同的常量值关联，当我们创建一个枚举的实例时，就可以初始化不同的常量值。 1234enum ServerResponse &#123; case result(String,String) case failure(String)&#125; 用 struct 来声明一个结构体，枚举中也可以关联函数举个 🌰 ： 1234567891011121314151617//矩形类struct Rectangle &#123; var origin:CGPoint var width:Float var height:Float func area() -&gt; String &#123; let area = width * height return \"\\(area)\" &#125; func perimeter() -&gt; Float &#123; return (width + height) * 2 &#125;&#125; 简单运用 123let myRectangle = Rectangle(origin: CGPoint.init(x: 0, y: 0), width: 5, height: 6)print(\"周长：\\(myRectangle.perimeter())\")print(\"面积：\\(myRectangle.area())\") 协议 和 类扩展用 protocol 来声明一个协议。1234protocol TestProtocol &#123; var simpleDescription:String &#123; get &#125; mutating func adjust()&#125; 类、枚举和结构体都可以遵循协议 1234567891011121314151617class TestClass: TestProtocol &#123; var value:Int = 108 var simpleDescription: String = \"这是一个测试类\" func adjust() &#123; simpleDescription.append(\"+测试值是\\(value)\") &#125;&#125; struct TestStruct:TestProtocol &#123; var simpleDescription: String = \"一个测试结构体\" mutating func adjust() &#123; simpleDescription.append(\"+ 遵循协议\") &#125;&#125; 简单运用 1234567let test = TestClass()test.adjust()print(test.simpleDescription) var testStruct = TestStruct()testStruct.adjust()print(testStruct.simpleDescription) 用 extension 来声明一个类扩展，给存在的类增加一个方法或算值属性 。举个 🌰 ： 123456789101112extension Int&#123; //简介 算值属性 var simpleDescription:String &#123; return \"the number \\(self)\" &#125; //自增2 mutating func addTwo() &#123; self = self + 2 &#125; &#125; 简单使用 1234var num:Int = 8print(num.simpleDescription)num.addTwo()print(num) 用 extension 也可以让存在的类或数据类型遵循某项协议。 123456789101112131415161718protocol testProtocol &#123; var simpleDescription:String &#123; get &#125; mutating func adjust()&#125;extension Double: testProtocol&#123; var simpleDescription: String &#123; return \"Double value \\(self)\" &#125; mutating func adjust() &#123; self *= 2 &#125;&#125; 简单运用： 1234var pi:Double = 3.14print(pi.simpleDescription)pi.adjust()print(pi) 错误处理通过遵循错误协议 Error 来声明一个错误类型。 12345enum PrinterError:Error &#123; case outOfPaper case noToner case onFire&#125; 用 throw 来抛出错误和用 throws 来标记一个可以抛出错误的函数，当函数抛出错误时，函数会立即返回，并调用错误处理方法。 123456func send(job:Int, toPrinter printerName:String) throws -&gt;String &#123; if printerName == \"Nerver Has Toner\" &#123; throw PrinterError.noToner &#125; return \"Job sent\"&#125; 用 do-catch 来处理错误，在 do代码块 中，调用可抛出错误的函数时，前面需要用 try 来标记,而在 catch代码块 中，错误的默认名字是 error，除非设置了一个别名。 12345678do &#123; let printerResponse = try send(job: 1040, toPrinter: \"Nerver Has Toner\") print(printerResponse) &#125; catch &#123; print(error) &#125;&#125; 可以用多重 catch代码块 来详细处理错误 12345678910do &#123; let printerResponse = try send(job: 1040, toPrinter: \"Nerver Has Toner\") print(printerResponse) &#125; catch PrinterError.onFire &#123; print(\"打印机过热，休息一会儿再使用\") &#125; catch PrinterError.noToner&#123; print(\"打印机没墨了，请添加墨水\") &#125; catch &#123; print(\"纸张用完，请添加纸张\") &#125; 另一种处理错误是用 try? 将结果转换成一个可选值，如果函数抛出错误，这个错误将被丢弃，结果为nil，否则返回值是一个包含结果的可选值。 12let printerSuccess = try? send(job: 1884, toPrinter: \"hello world\")let printerFailure = try? send(job: 1884, toPrinter: \"Nerver Has Toner\") 使用defer代码块来声明函数返回前需要执行的语句，该语句不管函数是否抛出错误都会执行。 1234567891011121314var fridgeIsOpen = falselet fridgeContent = [\"milk\",\"eggs\",\"apple\"] func fridgeContains(food:String) -&gt; Bool &#123; fridgeIsOpen = true defer &#123; fridgeIsOpen = false &#125; let result = fridgeContent.contains(food) return result &#125; 简单运用 123let ret = fridgeContains(food: \"banana\")print(ret)print(fridgeIsOpen) 泛型用 &lt;name&gt; 声明一个泛型或泛型方法。123456789101112func makeArray&lt;Item&gt;(repeat item:Item, numberOfItems:Int) -&gt; [Item] &#123; var result = [Item]() for _ in 0..&lt;numberOfItems &#123; result.append(item) &#125; return result &#125;//函数调用print(makeArray(repeat: \"Apple\", numberOfItems: 7)) 函数、类、枚举、结构体等也可以声明成泛型的方式 123456789enum OptionalValue&lt;Wrapped&gt; &#123; case none case some(Wrapped)&#125;//简单调用var possibleValue:OptionalValue&lt;Int&gt; = .nonepossibleValue = .some(200)print(possibleValue) 在方法名后面来使用 where 指定对类型的需求—比如，需要都实现一个协议，需要两个对象的类型一样，或都用于共同的父类等 123456789101112//判断是否有共同元素 func anyCommonElements&lt;T: Sequence, U: Sequence&gt;(_ lhs: T, _ rhs: U) -&gt; Bool where T.Iterator.Element: Equatable, T.Iterator.Element == U.Iterator.Element &#123; for lhsItem in lhs &#123; for rhsItem in rhs &#123; if lhsItem == rhsItem &#123; return true &#125; &#125; &#125; return false&#125; 简单运用 12let ret = anyCommonElements([1,2,3], [5])print(ret) 结束语：在这里查阅Swift3官方文档 感谢阅读，有什么不对的地方可以给我留言，一起学习，一起进步！","tags":[{"name":"Swift3初体验","slug":"Swift3初体验","permalink":"http://yoursite.com/tags/Swift3初体验/"}]},{"title":"如何阅读一本书---读书笔记","date":"2016-07-26T03:00:32.000Z","path":"2016/07/26/How-to-read-a-book/","text":"版权声明：本文为 muhlenXi 原创文章，欢迎转载，转载请注明来源。 导读 《如何阅读一本书》是2004年在商务印书馆出版的图书，该书的作者是该书作者是[美] 莫提默·J. 艾德勒、查尔斯·范多伦。该书强调阅读是一种主动的活动。 阅读一般分为三种目的的阅读： 娱乐消遣、获取资讯、增进理解力。只有最后一种目的的阅读能帮助阅读者增长心智，不断成长! 本书是关于阅读的艺术，是为了增强理解力而写的。阅读，努力越多，效果越好。 读书，我们应保持金字塔模式，即基础厚实，顶端尖锐。读书太快或太慢，都将一无所获！ 基础阅读 阅读是什么？这是一个凭借着头脑运作，除了玩味读物中的一些字句之外，不假任何外助，以一己之力来提升自我的过程。你的头脑会从从粗浅的了解推进到深入的理解。而会产生这种结果的运作技巧，就是由许多不同活动所组合成的阅读的艺术。 阅读就是学习，蒙田曾说过，初学者的无知在于未学，而学者的无知在于学后。当我们在阅读的时候，我们应该在思索，这个句子在说什么呢？ 学习阅读的阶段可以分为四个： 1、阅读准备阶段，出生到六七岁为止。 2、会学习读一些简单的读物。 3、快速建立字汇的能力，根据上下文提供的线索，揭发不熟悉的字眼。 4、精练与增进前面所学的技巧。 检视阅读 这个层次的阅读，核心是，你要努力提出问题，然后尽可能地找出答案。我们应该思索的问题包括，这本书在谈些什么？这本书的架构如何？这本书包含哪些部分？这是哪一类的书-还是科学论文？ 检视阅读一：有系统的略读或粗读。 略读的步骤可以分为以下6步： 1、先看书名页，然后如果有序就先看序。 2、研究目录页，对这本书的基本架构做概括性的理解。 3、如果书中附有索引，也要检阅一下-大多数论说类的书籍都会有索引。 4、如果那是本包着书衣的新书，不妨读一下出版者的介绍。 5、从一本书的目录概略，挑几个跟主题相关的篇章来看，如有摘要说明则仔细阅读。 6、最后一步，东翻翻，西翻翻，把全书翻过一遍。 检视阅读二：粗浅的阅读。 当我们第一次阅读一本书时，我们应遵守这个规则：头一次面对一本难读的书的时候，从头到尾先读完一遍，碰到不懂的地方不要停下来查询或思索。,同时，阅读的过程避免逗留和倒退. 如何训练呢？手指顺着章节段落一动，强迫自己的眼睛跟着手部动作一动。继续练习，加快手的动作。我们要注意在阅读一本书的时候，慢不该慢到不值得，快不该快到有损于满足和理解。; 我们要提出这4个基本问题： 1、整体来说，这本书到底在谈些什么？ 2、作者细部说了什么？怎么说的？ 3、这本书说的有道理么？是全部有道理，还是部分有道理？ 4、这本书跟你有什么关系？ 要回答第一个问题，我们不妨参考以下规则： 【1】依照书本的种类与主题作分类。 【2】用最简短的句子说出整本书在谈些什么。 【3】按照顺序与关系，列出全书的重要部分。将全书的纲要拟出来之后，再将各个部分的纲要也一一列出。 【4】找出作者在问的问题，或作者想要解决的问题。 在阅读的过程中，我们可以做一下笔记，如结构笔记 、概念笔记、辩证笔记等。读书的艺术或技巧，只属于那个能养成习惯，而且能依照规则运作的人。这也是艺术家或任何领域的工匠与众不同之处。 分析阅读阶段一： 第一阶段，只需遵循这4个规则： 规则1、依照书本的种类与主题作分类。 规则2、用最简短的句子说出整本书在谈些什么。 规则3、按照顺序与关系，列出全书的重要部分。将全书的纲要拟出来之后，再将各个部分的纲要也一一列出。 规则4、找出作者在问的问题，或作者想要解决的问题。 阅读的过程中，我们会迷惑，这是一本哲学的书，还是一本科学的书，其实有个判断的小技巧。如果一本理论的书所强调的内容，超乎你日常、例行、正常生活的经验，那就是科学的书。否则就是一本哲学的书 。 阶段二： 你一定要利用上下文自己已经了解的所有字句，来推敲出你所不了解的那个字的意义。不论这个方法看起来多么像是在绕圈子，但却是唯一的方法。用你自己的话来说，是测验你懂不懂一个句子的主旨的最佳办法。 第二阶段，可以回答回答这本书的详细内容是什么？如何叙述的？同样需遵循4个规则： 规则5、诠释作者使用的关键字，与作者达成共识。 规则6、从最重要的句子中抓出作者的重要主旨。 规则7、找出作者的论述，重新架构这些论述的前因后果，以明白作者的主张。 规则8、确定作者已经解决了那些问题，还有哪些是未解决的。在未解决的问题中，确定哪些是作者认为自己无法解决的问题。 阶段三： 除非你看完一本书，否则不要看某个人的导读。这是很有必要的。 最后阶段的规则只有3个： 规则9、在你说出我同意、我不同意、或我暂缓评论之前，你一定要能肯定地说，我了解了。 规则10、当你不同意作者的观点时，要理性的表达自己的意见，不要无理地辩驳或争论。 规则11、尊重知识与个人观点的不同，在作任何评断之前，都要找出理论基础。 我们阅读的过程中，偶尔会与作者发生冲突，想要与作者辩论。理想化的辩论必须满足的条件: 【1】因为人有理性的一面，又有动物的一面，所以在争辩时就要注意你会带进去的情绪，或是在当场引发的脾气。 【2】你要把自己的前提或假设摊出来，你要知道你的偏见是什么-这也是你的预先判断。否则你就不容易接受对手也有不同假设的权利。 【3】派别之争几乎难以避免地会造成一些盲点，要化解这些盲点，应尽力尝试不偏不倚。 当我们对作者进行批评的时候，我们可以参考一下批评标准： 1、证明作者的知识不足。 2、证明作者的知识错误。。 3、证明作者不合逻辑。 4、证明作者的分析与理由是不完整的。 如何阅读其他类型的书？如何阅读实用型的书？ 我们只需问两个问题？ 1、作者的目的是什么？ 2、他建议用什么办法达到这个目的？ 规则四修改：找出作者想要你做什么 规则八修改：了解他要你这么做的目的。 如何阅读想象文学？ 阅读想象文学时，不要抗拒想象文学带给你的影响力。在想象文学中，不要去找共识、主旨或论述。那是逻辑的，不是诗的，二者完全不同。不要用适用于传递知识的，与真理一致的标准来批评小说。 小说的要素是插曲、事件、角色与他们的思想、言语、感觉及行动。其中小说的要素与整个表现的场景或背景有关，共识与主旨有关。如果说论述性作品中有任何活动，那就是论述的发展。由证据到理由到结构的一个逻辑性的演变。 只需注意以下即可： 【1】你必须将想象文学作品分类。 【2】你要能抓住整本书的大意。 【3】你不仅要能将整本书简化为大意，还要能发现整本书各个部分是如何架构起来的。 在你衷心感激作者试着为你创造的经验之前，不要批评一本想象的作品。一个好读者不会质疑作者所创造出来，然后在他自己心中又重新再创造一遍的世界。 懂得阅读方法的人，文学品位都很高。 阅读故事、戏剧与诗的一些建议 阅读故事书的建议： 快读，并且全心全意地读。 阅读希腊悲剧： 【1】记住悲剧的精髓在时间，或是说缺乏时间。 【2】我们确实知道在希腊的戏剧中，所有悲剧演员都穿一种高出地面几英寸的靴子，他们也戴面具。 阅读抒情书： 【1】不论你觉得自己懂不懂，都要一口气读完，不要停。 【2】重读一边-大声读出来。 【3】要了解一首诗，一定要去读它 - 一遍又一遍地读。 阅读历史书: 【1】对你感兴趣的事件或时期，尽可能阅读一种以上的历史书。 【2】阅读历史时，不知要关心在过去某个时间、地点真正发生了什么事，还要读懂在任何时空之中，尤其是现在，人们为什么会有如此这般行动的原因。 读者要擦亮眼睛！阅读科学著作时，你至少可以把一些比你想象的基础程度的数学读的更明白。 主题阅读 主题阅读就是能面面俱到，而自己并不预设立场。 在主题阅读中，遵循以下五个步骤可以帮助我们更好得阅读： 步骤1、找到相关的章节。 步骤2、带引作者与你达成共识。 步骤3、厘清问题。 步骤4、界定议题。 步骤5、分析讨论。 一、观察研究范围：主题阅读的准备阶段【1】针对你要研究的主题，设计一份试验性的数目。你可以参考图书馆目录、专家的建议与书中的书目索引。 【2】浏览这份书目上所有的书，确定哪些与你的主题相关，并就你的主题建立起清楚的概念。 二、主题阅读方法：阅读所有第一阶段收集到的书籍【1】浏览所有在第一阶段被认定与你主题相关的书，找出最相关的章节。 【2】根据主题创造出一套中立的词汇，带领作者与你达成共识—无论作者是否实际用到这些词汇，所有的作者， 或至少绝大部分的作者都可以用这套词汇来诠释。 【3】建立一个中立的主旨，列出一连串的问题—无论作者是否明白谈过这些问题，所有的作者，或者至少大多数 的作者都能够解读为针对这些问题提供了他们的回答。 【4】界定主要及次要的议题。然后将作者针对各个问题的不同意见整理陈列在各个议题之旁。你要记住，各个作 者之间或之中，不见得一定存在着某个议题。有时候，你需要针对一些不是作者主要关心范围的事情， 把他的观点解读，才能构造出这种议题。 【5】分析这些讨论。这得把问题和议题按顺序排列，以求突显主题。比较有共同性的议题，要放在比较没有共通性的议题之前。各个议题之间的关系也要清楚的界定出来。 注意：理想上，要一直保持对话式的疏离与客观。要做到这一点，每当你要解读某个作家对一个议题的观点时，必须从他自己的文章中引一段话来并列。 随着我们读书的数量增长和境界的提高，我们会发现： 1、当你成功的阅读了一本难读的好书之后，你的阅读技巧必然增进了。 2、一本好书能教你了解这个世界以及你自己。你不只懂得如何读的更好，还更懂得生命。你变得更有智慧，而不只是更有知识。你会成为一位智者，对人类生命中永恒的真理有更深刻的体认。 最后以一张特别形象的图来结束这篇读书笔记","tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/tags/读书笔记/"},{"name":"如何阅读一本书","slug":"如何阅读一本书","permalink":"http://yoursite.com/tags/如何阅读一本书/"}]},{"title":"iOS APP 多语言支持","date":"2016-07-07T08:47:19.000Z","path":"2016/07/07/Localized-Language/","text":"版权声明：本文为 muhlenXi 原创文章，欢迎转载，转载请注明来源 导语： APP 根据手机系统的语言进行显示。第二种是在 APP 内自行设置语言，也就是应用内切换语言，设置的是什么语言，就显示什么语言。 写个 Demo 玩一下，实践是检验真理的唯一标准。 基础文件配置: 1、首先是添加 APP 的本地化语言支持。方法：PROJECT -&gt; Info -&gt; Localizations -&gt; 点击 + 添加。 2、添加 APP 名称本地化文件文件的名字一定要是 InfoPlist！ 方法：File -&gt; New -&gt; File... -&gt; iOS-&gt; Resource -&gt; Strings File 3、设置 InfoPlist.strings 的 Localization方法：在项目中找到并选中 InfoPlist.strings 文件，在靠右边的窗口中，选择支持的语言类型。 本例中选择的是英语、简体中文、繁体中文 4、设置对应文件的 key-value 键值对点击 InfoPlist.strings 左边的三角形符号展开该文件，分别在对应的 strings 文件中设置对应的键值对。 4-1、在 InfoPlist.strings(English) 文件中输入： 1\"CFBundleDisplayName\" = \"EnglishName\"; 4-2、在 InfoPlist.strings(Chinese(Simplified)) 文件中输入： 1\"CFBundleDisplayName\" = \"CFBundleDisplayName\" = \"中文名字\"; 保存后编译并运行就可以了。 系统语言切换:创建 Localizable 字符串文件同样的步骤，执行2-3步骤，创建一个名字为 Localizable 的strings文件，然后设置 Localizable.strings 的 Localization 。 然后执行步骤4，设置不同语言中项目所需的字符串。 本例中，我们需要设置 Alarm clock、Medicine、Setings、Find Band、test words 等字符串。 也就是说： 1-在 Localizable.strings(English) 文件中输入： 123456\"Alarm clock\" = \"Alarm clock\";\"Medicine\" = \"Medicine\";\"Setings\" = \"Setings\";\"Find Band\" = \"Find Band\";\"test words\" = \"test words\"; 2-在 Localizable.strings(Chinese(Simplified)) 文件中输入： 123456\"Alarm clock\" = \"闹钟提醒\";\"Medicine\" = \"吃药提醒\";\"Setings\" = \"设置\";\"Find Band\" = \"寻找手环\";\"test words\" = \"测试语句\"; 调用 NSLocalizedString(key, comment)方法举例： 1self.descriptionLabel.text = NSLocalizedString(@\"test words\", @\"描述文字\"); 到这里第二部分的内容基本就完了。 应用内切换语言: 应用内切换语言的思路是：每当我们添加一种语言的支持后，系统就会在我们的项目中生成对应语言的.lproj 支持文件。我们将 NSUserDefaults 将用户的语言设置保存到本地中，保存的 String 的值和下图中的文件名一样。然后通过 NSBundle 根据 .lproj 支持文件生成 bundle，最后通过 NSLocalizedStringFromTableInBundle 方法获取对应的 String 的值。 具体的做法如下：为了方便使用，我们新建一个继承 NSObject 的 XYJLanguageTool 类，用来管理我们的语言。 XYJLanguageTool.h 中的代码如下：* 123456789101112131415161718#import &lt;Foundation/Foundation.h&gt;#define XYJGetStringWithKey(key) [[XYJLanguageTool sharedInstance] getStringForKey:key]@interface XYJLanguageTool : NSObject@property (nonatomic,strong,readonly) NSBundle * bundle;// 单例初始化方法+ (id) sharedInstance;// 根据key获取相应的String- (NSString *) getStringForKey:(NSString *) key;// 应用内设置新语言- (void) setNewLanguage:(NSString *) language;@end XYJLanguageTool.m ,中的代码如下：* 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#import \"XYJLanguageTool.h\"#define Language_Key @\"languageKey\"#define Chinese_Simple @\"zh-Hans\"#define Chinese_Traditional @\"zh-Hant\"#define English_US @\"en\"@implementation XYJLanguageTool+ (id)sharedInstance&#123; static dispatch_once_t onceToken; static XYJLanguageTool * languageTool; dispatch_once(&amp;onceToken, ^&#123; languageTool = [[XYJLanguageTool alloc] init]; &#125;); return languageTool;&#125;// 根据语言名获取bundle- (NSBundle *)bundle&#123; NSString * setLanguage = [[NSUserDefaults standardUserDefaults] objectForKey:Language_Key]; //默认是简体中文 if (setLanguage == nil) &#123; setLanguage = Chinese_Simple; &#125; NSString * bundlePath = [[NSBundle mainBundle] pathForResource:setLanguage ofType:@\"lproj\"]; return [NSBundle bundleWithPath:bundlePath];&#125;// 根据key获取value- (NSString *)getStringForKey:(NSString *)key&#123; NSBundle * bundle = [[XYJLanguageTool sharedInstance] bundle]; if (bundle) &#123; return NSLocalizedStringFromTableInBundle(key, @\"Localizable\", bundle, @\"HelloWord\"); &#125; return NSLocalizedString(key, @\"HelloWord\");&#125;- (void)setNewLanguage:(NSString *)language&#123; NSString * setLanguage = [[NSUserDefaults standardUserDefaults] objectForKey:Language_Key]; if ([language isEqualToString:setLanguage]) &#123; return; &#125; // 简体中文 else if ([language isEqualToString:Chinese_Simple]) &#123; [[NSUserDefaults standardUserDefaults] setObject:Chinese_Simple forKey:Language_Key]; [[NSUserDefaults standardUserDefaults] synchronize]; &#125; // 繁体中文 else if ([language isEqualToString:Chinese_Traditional]) &#123; [[NSUserDefaults standardUserDefaults] setObject:Chinese_Traditional forKey:Language_Key]; [[NSUserDefaults standardUserDefaults] synchronize]; &#125; // 英文 else if ([language isEqualToString:English_US]) &#123; [[NSUserDefaults standardUserDefaults] setObject:English_US forKey:Language_Key]; [[NSUserDefaults standardUserDefaults] synchronize]; &#125; // 发送更新语言的通知，用于重新设置Window的RootViewController [[NSNotificationCenter defaultCenter] postNotificationName:@\"UpDateLanguageUI\" object:nil];&#125; 使用方法如下（记得导入头文件）：通过调用 XYJGetStringWithKey 方法来获取相应的字符串。 举例如下： 1self.navigationItem.title = XYJGetStringWithKey(@\"Alarm clock\"); 最后的真机运行图如下:应用内切换为英语 应用内切换为简体中文 应用内切换为繁体中文 本例中的demo已经提交到Github上，点击这里下载，欢迎提出批评和指正，最后谢谢大家！","tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://yoursite.com/tags/Objective-C/"},{"name":"多语言","slug":"多语言","permalink":"http://yoursite.com/tags/多语言/"}]},{"title":"iOS实现应用外自带地图、高德地图、百度地图导航","date":"2016-05-19T02:42:54.000Z","path":"2016/05/19/Map-Guide/","text":"版权声明：本文为 muhlenXi 原创文章，欢迎转载，转载请注明来源。 导语： 在地图类应用开发中，我们经常有导航这个功能需求。根据导航方式可以分为应用内导航和应用外导航，其中应用内导航指的是使用第三方提供的地图 SDK（高德、百度等）将导航嵌入到我们开发的 APP 内部。应用外导航指的是以 URL Scheme 跳转的方式，跳转到对应的地图 APP 中，使用对方的导航功能。 点击阅读全文来了解一下详情吧。 本次开发的需求是，实现应用外导航。通过选项列表（UIAlertController、UIActionSheet）的方式提供用户选择，当用户既安装了高德地图和百度地图时，则弹出如下图所示的选项列表。否则用户安装了哪个地图，就增加哪个地图的选择项。 环境的配置在iOS 9 下涉及到平台客户端跳转，系统会自动到项目 info.plist 下检测是否设置平台 Scheme，对于需要配置的平台，如果没有配置，将无法正常跳转平台客户端，因此需要配置 Scheme 名单。本文我们需要添加百度地图和高德地图的 scheme 白名单。 具体方法：在项目的 info.plist 中添加 LSApplicationQueriesSchemes 字段，类型是 Array，然后添加两个 Item。 如图： 根据系统的版本号来初始化对应选项列表我们需要一个属性来记录导航目标的终点坐标 1@property (nonatomic,assign) CLLocationCoordinate2D coordinate; //!&lt; 要导航的坐标 在 viewDidLoad 中初始化该坐标值。 12//导航到深圳火车站self.coordinate = CLLocationCoordinate2DMake(22.53183, 114.117206); 我们再定义一个判断系统版本是否大于等于 8.0 的一个宏定义 12//系统版本号是否大于8.0#define IS_SystemVersionGreaterThanEight ([UIDevice currentDevice].systemVersion.doubleValue &gt;= 8.0) 在低于8.0的系统版本中使用 UIAlertController 会崩溃，所以我们要根据系统版本号来选择合适的选项列表。 在导航按钮的事件响应方法中，我们添加如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475//系统版本高于8.0，使用UIAlertController if (IS_SystemVersionGreaterThanEight) &#123; UIAlertController * alertController = [UIAlertController alertControllerWithTitle:@\"导航到设备\" message:nil preferredStyle:UIAlertControllerStyleActionSheet]; //自带地图 [alertController addAction:[UIAlertAction actionWithTitle:@\"自带地图\" style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) &#123; NSLog(@\"alertController -- 自带地图\"); //使用自带地图导航 MKMapItem *currentLocation =[MKMapItem mapItemForCurrentLocation]; MKMapItem *toLocation = [[MKMapItem alloc] initWithPlacemark:[[MKPlacemark alloc] initWithCoordinate:self.coordinate addressDictionary:nil]]; [MKMapItem openMapsWithItems:@[currentLocation,toLocation] launchOptions:@&#123;MKLaunchOptionsDirectionsModeKey:MKLaunchOptionsDirectionsModeDriving, MKLaunchOptionsShowsTrafficKey:[NSNumber numberWithBool:YES]&#125;]; &#125;]]; //判断是否安装了高德地图，如果安装了高德地图，则使用高德地图导航 if ( [[UIApplication sharedApplication] canOpenURL:[NSURL URLWithString:@\"iosamap://\"]]) &#123; [alertController addAction:[UIAlertAction actionWithTitle:@\"高德地图\" style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) &#123; NSLog(@\"alertController -- 高德地图\"); NSString *urlsting =[[NSString stringWithFormat:@\"iosamap://navi?sourceApplication= &amp;backScheme= &amp;lat=%f&amp;lon=%f&amp;dev=0&amp;style=2\",self.coordinate.latitude,self.coordinate.longitude]stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding]; [[UIApplication sharedApplication]openURL:[NSURL URLWithString:urlsting]]; &#125;]]; &#125; //判断是否安装了百度地图，如果安装了百度地图，则使用百度地图导航 if ([[UIApplication sharedApplication] canOpenURL:[NSURL URLWithString:@\"baidumap://\"]]) &#123; [alertController addAction:[UIAlertAction actionWithTitle:@\"百度地图\" style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) &#123; NSLog(@\"alertController -- 百度地图\"); NSString *urlsting =[[NSString stringWithFormat:@\"baidumap://map/direction?origin=&#123;&#123;我的位置&#125;&#125;&amp;destination=latlng:%f,%f|name=目的地&amp;mode=driving&amp;coord_type=gcj02\",self.coordinate.latitude,self.coordinate.longitude] stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding]; [[UIApplication sharedApplication] openURL:[NSURL URLWithString:urlsting]]; &#125;]]; &#125; //添加取消选项 [alertController addAction:[UIAlertAction actionWithTitle:@\"取消\" style:UIAlertActionStyleCancel handler:^(UIAlertAction * _Nonnull action) &#123; [alertController dismissViewControllerAnimated:YES completion:nil]; &#125;]]; //显示alertController [self presentViewController:alertController animated:YES completion:nil]; &#125; else &#123; //系统版本低于8.0，则使用UIActionSheet UIActionSheet * actionsheet = [[UIActionSheet alloc] initWithTitle:@\"导航到设备\" delegate:self cancelButtonTitle:@\"取消\" destructiveButtonTitle:nil otherButtonTitles:@\"自带地图\", nil]; //如果安装高德地图，则添加高德地图选项 if ( [[UIApplication sharedApplication] canOpenURL:[NSURL URLWithString:@\"iosamap://\"]]) &#123; [actionsheet addButtonWithTitle:@\"高德地图\"]; &#125; //如果安装百度地图，则添加百度地图选项 if ([[UIApplication sharedApplication] canOpenURL:[NSURL URLWithString:@\"baidumap://\"]]) &#123; [actionsheet addButtonWithTitle:@\"百度地图\"]; &#125; [actionsheet showInView:self.view]; &#125; 实现 UIActionSheetDelegate 代理方法当使用 UIActionSheet 时，需要设置 Delegate 为 self ,并且遵循 UIActionSheetDelegate 协议，实现相应代理方法。 当点击取消选项时，会触发该代理方法 1234567#pragma mark - UIActionSheetDelegate- (void)actionSheetCancel:(UIActionSheet *)actionSheet&#123; NSLog(@\"ActionSheet - 取消了\"); [actionSheet removeFromSuperview];&#125; 当点击其他选项是，则会触发下面的代理方法 使用自带地图导航时，需要用到 MKMapItem ,我们需要导入头文件 #import &lt;MapKit/MapKit.h&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960- (void)actionSheet:(UIActionSheet *)actionSheet clickedButtonAtIndex:(NSInteger)buttonIndex&#123; NSLog(@\"numberOfButtons == %ld\",actionSheet.numberOfButtons); NSLog(@\"buttonIndex == %ld\",buttonIndex); if (buttonIndex == 0) &#123; NSLog(@\"自带地图触发了\"); MKMapItem *currentLocation =[MKMapItem mapItemForCurrentLocation]; MKMapItem *toLocation = [[MKMapItem alloc] initWithPlacemark:[[MKPlacemark alloc] initWithCoordinate:self.coordinate addressDictionary:nil]]; [MKMapItem openMapsWithItems:@[currentLocation,toLocation] launchOptions:@&#123;MKLaunchOptionsDirectionsModeKey:MKLaunchOptionsDirectionsModeDriving, MKLaunchOptionsShowsTrafficKey:[NSNumber numberWithBool:YES]&#125;]; &#125; //既安装了高德地图，又安装了百度地图 if (actionSheet.numberOfButtons == 4) &#123; if (buttonIndex == 2) &#123; NSLog(@\"高德地图触发了\"); NSString *urlsting =[[NSString stringWithFormat:@\"iosamap://navi?sourceApplication= &amp;backScheme= &amp;lat=%f&amp;lon=%f&amp;dev=0&amp;style=2\",self.coordinate.latitude,self.coordinate.longitude]stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding]; [[UIApplication sharedApplication]openURL:[NSURL URLWithString:urlsting]]; &#125; if (buttonIndex == 3) &#123; NSLog(@\"百度地图触发了\"); NSString *urlsting =[[NSString stringWithFormat:@\"baidumap://map/direction?origin=&#123;&#123;我的位置&#125;&#125;&amp;destination=latlng:%f,%f|name=目的地&amp;mode=driving&amp;coord_type=gcj02\",self.coordinate.latitude,self.coordinate.longitude] stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding]; [[UIApplication sharedApplication] openURL:[NSURL URLWithString:urlsting]]; &#125; &#125; //安装了高德地图或安装了百度地图 if (actionSheet.numberOfButtons == 3) &#123; if (buttonIndex == 2) &#123; if ( [[UIApplication sharedApplication] canOpenURL:[NSURL URLWithString:@\"iosamap://\"]]) &#123; NSLog(@\"只安装的高德地图触发了\"); NSString *urlsting =[[NSString stringWithFormat:@\"iosamap://navi?sourceApplication= &amp;backScheme= &amp;lat=%f&amp;lon=%f&amp;dev=0&amp;style=2\",self.coordinate.latitude,self.coordinate.longitude]stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding]; [[UIApplication sharedApplication]openURL:[NSURL URLWithString:urlsting]]; &#125; if ([[UIApplication sharedApplication] canOpenURL:[NSURL URLWithString:@\"baidumap://\"]]) &#123; NSLog(@\"只安装的百度地图触发了\"); NSString *urlsting =[[NSString stringWithFormat:@\"baidumap://map/direction?origin=&#123;&#123;我的位置&#125;&#125;&amp;destination=latlng:%f,%f|name=目的地&amp;mode=driving&amp;coord_type=gcj02\",self.coordinate.latitude,self.coordinate.longitude] stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding]; [[UIApplication sharedApplication] openURL:[NSURL URLWithString:urlsting]]; &#125; &#125; &#125; &#125; 知识点补充【1】使用 canOpenURL 方法来检测该手机是否安装相应 APP。 该方法会返回一个 BOOL 值，当为 YES 时，表明已安装该 APP 1[[UIApplication sharedApplication] canOpenURL:[NSURL URLWithString:@\"iosamap://\"]] 常用的4个地图的 URL Scheme： 1、苹果自带地图（不需要检测，所以不需要URL Scheme） 2、百度地图 baidumap:// 3、高德地图 iosamap:// 4、谷歌地图 comgooglemaps:// 点击这里查看更多常用的URL Scheme 对URL Scheme不了解的点这里 如何自定义URL Scheme点这里 【2】wgs84，gcj-02,bd-09是什么? wgs84是国际标准，从GPS设备中取出的原始数据就是这个标准的数据，iOS的SDK中用到的坐标系统也是国际标准的坐标系统WGS-84； gcj-02是中国标准，行货GPS设备取出的原始数据是该标准的数据，根据规定，国内出版的各种地图系统，必须至少采用gcj-02对地理位置进行首次加密。网络上也称之为火星坐标。 bd-09是百度标准，百度SDK使用的就是这个标准。 如何进行转换点这里 运行结果图示以下是选择了不同的选项对应的结果图。 自带地图导航。 高德地图导航。 百度地图导航。 感谢阅读，有什么意见可以给我留言!","tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://yoursite.com/tags/Objective-C/"},{"name":"地图导航","slug":"地图导航","permalink":"http://yoursite.com/tags/地图导航/"}]},{"title":"高德 SDK 的正确打开方式","date":"2016-04-07T02:02:20.000Z","path":"2016/04/07/Gaode-Map/","text":"版权声明：本文为 muhlenXi 原创文章，欢迎转载，转载请注明来源。 导语： 高德地图 iOS SDK 是一套基于 iOS 6.0.0 及以上版本的地图应用程序开发接口，供开发者在自己的 iOS应用中加入地图相关的功能。通过 iOS SDK，开发者可以轻松地开发出地图显示与操作、兴趣点搜索、地理编码、路线规划等功能。 点击下载本文的demo研究，记得给star支持博主的努力哦！ 点击阅读全文来瞅瞅如何开发吧。 由于官方文档更新不及时，很多方法弃用了，新的方法只能自己摸索了。本文大部分是参考官方文档来做的。 点这里查看高德开发平台,在这里注册高德账号并成为开发者。 如果是第一次接触高德地图，可以大概看一下入门指南 高德地图SDK的部署由于我喜欢简单粗暴的部署方式，所以一直选择 CocoaPods 来安装和配置第三方库。 关于 CocoaPods,不了解的可以看一下我的另一篇博文，zsh的配置和CocoaPods的安装与使用。这里就不详细展开了。 方法就是，使用 终端cd 到你的项目所在的路径下，vim 一个 Podfile 文件，点击 字母i 进入编辑状态，在文件中输入： 123456platform:ios,'7.0'target 'gaodeMapDemo' dopod 'AMap2DMap', '~&gt; 3.3.0'pod 'AMapLocation', '~&gt; 1.2.0' #定位SDKpod 'AMapSearch' #搜索服务SDKend 然后按下 Esc，shift+：然后输入 wq ，最后 终端 输入 pod install --verbose --no-repo-update 安装即可。 高德地图SDK的打开方式点这里查看高德地图 iOS SDK。 配置好就可以正式干活了，我们先导入高德地图的头文件 #import &lt;MAMapKit/MAMapKit.h&gt; 先来一个屏幕宽和高的宏定义吧。 12#define kScreenWidth [UIScreen mainScreen].bounds.size.width#define kScreenHeight [UIScreen mainScreen].bounds.size.height 再声明一个 mapView 的属性。 1@property (nonatomic,strong) MAMapView * mapView; 添加地图自定义一个设置地图的方法 setupMap 1234567891011121314//设置高德地图- (void) setupMap&#123; [MAMapServices sharedServices].apiKey = gaode_key; self.mapView = [[MAMapView alloc] initWithFrame:CGRectMake(0, 0, kScreenWidth, kScreenHeight)]; [self.view addSubview:self.mapView]; //设置地图模式 // MAMapTypeSatellite // 卫星地图 // MAMapTypeStandard // 普通地图 self.mapView.mapType = MAMapTypeStandard; &#125; 在 viewDidLoad 中调用这个方法，然后 编译运行，看看添加的地图长啥样。 会发现基本长这样： 卫星地图 基本长这样： 显示实时路况，默认是不显示的 1self.mapView.showTraffic = YES; 不显示比例尺，默认是显示的,可以通过 compassOrigin 属性可改变指南针的显示位置。 123self.mapView.showsScale = NO;//设置比例尺位置self.mapView.scaleOrigin= CGPointMake(_mapView.scaleOrigin.x, 82); 不显示罗盘，默认是显示的,可以通过 scaleOrigin 属性可改变改变比例尺的显示位置 123self.mapView.showsCompass = NO;//设置指南针位置self.mapView.compassOrigin= CGPointMake(_mapView.compassOrigin.x, 82); 高德地图的 Logo 不能移除，可以通过 logoCenter 属性来调整 Logo 的显示位置。 12//显示logo在右下角self.mapView.logoCenter = CGPointMake(kScreenWidth-55, kScreenHeight-13); 设置地图的中心坐标和显示范围点这里坐标拾取器来获取经纬度吧。 写一个根据经纬度和跨度来设置地图显示范围的方法 12345678910- (void) setMapViewDisplayAreaWithLatitude:(double)lati andLongitude:(double) longi Span:(double) span_value&#123; CLLocationCoordinate2D center = &#123;lati,longi&#125;; MACoordinateSpan span = &#123;span_value,span_value&#125;; MACoordinateRegion region = &#123;center,span&#125;; [self.mapView setRegion:region animated:YES];&#125; 在 viewDidLoad 中调用这个方法。 1234//设置显示区域为深圳展滔科技大厦114.038072,22.639641 double lati = 22.639641; double longi = 114.038072; [self setMapViewDisplayAreaWithLatitude:lati andLongitude:longi Span:0.02]; 然后编译运行，结果如下。 添加系统样式的标注标注可以精确表示用户需要展示的位置信息，高德地图SDK提供的标注功能允许用户自定义图标和信息窗，同时提供了标注的点击、拖动事件的回调。 写一个根据经纬度添加系统样式标注的方法 12345678910//添加默认样式的点标记，即大头针- (void) addPointAnnotationWithLatitude:(double)lati andLongitude:(double) longi Title:(NSString *) title Subtitle:(NSString *) subtitle&#123; MAPointAnnotation * pointAnnotation = [[MAPointAnnotation alloc] init]; pointAnnotation.coordinate = CLLocationCoordinate2DMake(lati, longi); pointAnnotation.title = title; pointAnnotation.subtitle = subtitle; [self.mapView addAnnotation:pointAnnotation];&#125; 在 viewDidLoad 中添加标注 12//添加系统样式标注[self addPointAnnotationWithLatitude:lati andLongitude:longi Title:@\"展滔科技大厦\" Subtitle:@\"深圳市宝安区民治大道1079号\"]; 此时编译运行的话，地图上仅仅显示一个红色的大头针，点击大头针没任何反应 我们在软件开发中，设计到协议、代理、回调方法时，一定要切记这三步曲！ 第一步：遵循协议。 第二步：设置代理（这步千万不能忘）！ 第三步：实现相应代理方法。 第一步遵循 &lt;MAMapViewDelegate&gt; 协议。 1@interface RootViewController ()&lt;MAMapViewDelegate&gt; 第二步设置代理，在 setupMap 方法中加入如下代码。 12//设置地图的代理self.mapView.delegate = self; 第三步通过实现协议中的 mapView:viewForAnnotation: 回调函数，设置标注样式. 1234567891011121314151617181920212223242526#pragma mark - MAMapViewDelegate- (MAAnnotationView *)mapView:(MAMapView *)mapView viewForAnnotation:(id&lt;MAAnnotation&gt;)annotation&#123; if ([annotation isKindOfClass:[MAPointAnnotation class]]) &#123; //复用标识符 static NSString * pointReuseIndentifier = @\"pointReuseIndentifier\"; MAPinAnnotationView * annotationView = (MAPinAnnotationView*)[mapView dequeueReusableAnnotationViewWithIdentifier:pointReuseIndentifier]; if (annotationView == nil) &#123; annotationView = [[MAPinAnnotationView alloc] initWithAnnotation:annotation reuseIdentifier:pointReuseIndentifier]; &#125; //设置气泡可以弹出，默认为NO annotationView.canShowCallout= YES; //设置标注动画显示，默认为NO annotationView.animatesDrop = YES; //设置标注可以拖动，默认为NO annotationView.draggable = YES; //设置大头针的颜色，有MAPinAnnotationColorRed, MAPinAnnotationColorGreen, MAPinAnnotationColorPurple三种 annotationView.pinColor = MAPinAnnotationColorPurple; return annotationView; &#125; return nil;&#125; 此时编译并运行代码，地图上会显示一个紫色的大头针，点击大头针会弹出一个气泡，气泡中显示设置的标题和副标题。如图所示： 添加一组标注用这个方法 123//数组中存放的是MAPointAnnotation的对象NSArray * array = @[pointAnnotation];[self.mapView addAnnotations:array]; 删除一个标注 1[self.mapView removeAnnotation:pointAnnotation]; 删除一组标注 123//数组中存放的是要删除的标注，也是MAPointAnnotation的对象NSArray * array = @[pointAnnotation]; [self.mapView removeAnnotations:array]; 添加自定义样式的标注自定义标注的效果如图所示： 如果想实现这个效果，我们需要自定义两个 View。 1、CustomCalloutView : UIView //自定义的气泡 2、CustomAnnotationView : MAAnnotationView //自定义的标注View 新建我们的CustomCalloutView：在 CustomCalloutView.h 文件中声明我们需要的属性： 123@property (nonatomic,strong) UIImage * thumbnail; //!&lt; 缩略图片@property (nonatomic,copy) NSString * title; //!&lt; 标题@property (nonatomic,copy) NSString * address; //!&lt; 地址 在 CustomCalloutView.m 文件中 新建一个匿名类（类扩展） 声明我们需要的控件： 12345678@interface CustomCalloutView ()@property (nonatomic,strong) UIImageView * thumbnailImageView; //!&lt; 缩略图@property (nonatomic,strong) UILabel * titleLabel; //!&lt; 标题Label@property (nonatomic,strong) UILabel * addressLabel; //!&lt; 地址Label@end 重写 - (instancetype)initWithFrame:(CGRect)frame 方法，初始化我们的控件 1234567891011121314151617181920212223242526272829303132- (instancetype)initWithFrame:(CGRect)frame&#123; self = [super initWithFrame:frame]; if (self) &#123; //其他控件的初始化写在这里 self.backgroundColor = [UIColor clearColor]; //初始化缩略图 self.thumbnailImageView = [[UIImageView alloc] initWithFrame:CGRectMake(5, 5, 70, 50)]; self.thumbnailImageView.backgroundColor = [UIColor yellowColor]; [self addSubview:self.thumbnailImageView]; //初始化标题Label self.titleLabel = [[UILabel alloc] initWithFrame:CGRectMake(5+70+5, 5, 120-8, 20)]; self.titleLabel.font = [UIFont systemFontOfSize:14]; self.titleLabel.textColor = [UIColor whiteColor]; self.titleLabel.text = @\"title\"; [self addSubview:self.titleLabel]; //初始化地址Label self.addressLabel = [[UILabel alloc] initWithFrame:CGRectMake(5+70+5, 20, 120-8, 20*2)]; self.addressLabel.font = [UIFont systemFontOfSize:12]; self.addressLabel.numberOfLines = 0; self.addressLabel.textColor = [UIColor lightGrayColor]; self.addressLabel.text = @\"address\"; [self addSubview:self.addressLabel]; &#125; return self;&#125; 重写 CustomCalloutView.h 文件中声明的属性的 Setter 方法，方便我们给控件赋值： 1234567891011121314- (void)setTitle:(NSString *)title&#123; self.titleLabel.text = title;&#125;- (void)setAddress:(NSString *)address&#123; self.addressLabel.text = address;&#125;- (void)setThumbnail:(UIImage *)thumbnail&#123; self.thumbnailImageView.image = thumbnail;&#125; 最后重写 - (void)drawRect:(CGRect)rect 方法绘制我们气泡的背景和添加阴影效果： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859- (void)drawRect:(CGRect)rect&#123; //绘制曲线 CGContextRef contextRef = UIGraphicsGetCurrentContext(); CGContextSetLineWidth(contextRef, 2.0f); CGContextSetFillColorWithColor(contextRef, [UIColor colorWithRed:0.3 green:0.3 blue:0.3 alpha:0.8].CGColor); CGRect calloutRect = self.bounds; CGFloat radius = 6.0; CGFloat triangleHeight = 10; //倒三角的高度 CGFloat x = CGRectGetMinX(calloutRect); CGFloat midX = CGRectGetMidX(calloutRect); CGFloat width = CGRectGetMaxX(calloutRect); CGFloat y = CGRectGetMinY(calloutRect); CGFloat height = CGRectGetMaxY(calloutRect)-10; //用起始点开始 CGContextMoveToPoint(contextRef, x+radius, y); //画上面的直线 CGContextAddLineToPoint(contextRef, x+width-radius, y); //画右上角圆弧 CGContextAddArcToPoint(contextRef, x+width, y, x+width, y+radius, radius); //画右边的直线 CGContextAddLineToPoint(contextRef, x+width, y+height-radius); //画右下角弧线 CGContextAddArcToPoint(contextRef, x+width, y+height, x+width-radius, y+height, radius); //画倒三角靠右的下边的直线 CGContextAddLineToPoint(contextRef, midX+triangleHeight, y+height); //画倒三角 CGContextAddLineToPoint(contextRef, midX, y+height+triangleHeight); CGContextAddLineToPoint(contextRef, midX-triangleHeight, y+height); //画倒三角靠左的下边的直线 CGContextAddLineToPoint(contextRef, x+radius, y+height); //画左下角的弧线 CGContextAddArcToPoint(contextRef, x, y+height, x, y+height-radius, radius); //画左边的直线 CGContextAddLineToPoint(contextRef, x, y+radius); //画左上角的弧线 CGContextAddArcToPoint(contextRef, x, y, x+radius, y, radius); CGContextClosePath(contextRef); CGContextFillPath(contextRef); //添加阴影 self.layer.shadowColor = [[UIColor blackColor] CGColor]; //阴影的透明度 self.layer.shadowOpacity = 1.0f; //阴影的偏移 self.layer.shadowOffset = CGSizeMake(0, 0);&#125; 到这里我们的自定义气泡就大功告成了！ 新建我们的CustomAnnotationView：新建一个继承自 MAAnnotationView 的CustomAnnotationView，在 CustomAnnotationView.h文件中，导入前面的自定义气泡的头文件： #import &quot;CustomCalloutView.h&quot; 声明一个气泡的属性： 12@property (nonatomic,strong) CustomCalloutView * calloutView;\u0010 在 CustomAnnotationView.m 文件中重写标注选中的方法 - (void)setSelected:(BOOL)selected animated:(BOOL)animated: 1234567891011121314151617181920212223242526272829303132//重写选中方法setSelected- (void)setSelected:(BOOL)selected animated:(BOOL)animated&#123; if (self.selected == selected) &#123; return; &#125; if (selected == YES) &#123; //如果气泡为空则初始化气泡 if (self.calloutView == nil) &#123; self.calloutView = [[CustomCalloutView alloc] initWithFrame:CGRectMake(0, 0, 200, 70)]; //设置气泡的中心点 CGFloat center_x = self.bounds.size.width/2; CGFloat center_y = -self.bounds.size.height; self.calloutView.center = CGPointMake(center_x, center_y); &#125; //给calloutView赋值 self.calloutView.thumbnail = [UIImage imageNamed:@\"zhantao\"]; self.calloutView.title = self.annotation.title; self.calloutView.address = self.annotation.subtitle; [self addSubview:self.calloutView]; &#125; else &#123; //移除气泡 [self.calloutView removeFromSuperview]; &#125; [super setSelected:selected animated:animated];&#125; 到这里我们的自定义标注View也完成了，接下来就能使用了 在我们的地图的标注回调函数 mapView: viewForAnnotation: 中设置我们的CustomAnnotationView： 1234567891011121314151617181920212223- (MAAnnotationView *)mapView:(MAMapView *)mapView viewForAnnotation:(id&lt;MAAnnotation&gt;)annotation&#123; if ([annotation isKindOfClass:[MAPointAnnotation class]]) &#123; static NSString * reuseIndetifier = @\"annotationReuseIndetifier\"; CustomAnnotationView * annotationView = (CustomAnnotationView *)[mapView dequeueReusableAnnotationViewWithIdentifier:reuseIndetifier]; if (annotationView == nil) &#123; annotationView = [[CustomAnnotationView alloc] initWithAnnotation:annotation reuseIdentifier:reuseIndetifier]; annotationView.image = [UIImage imageNamed:@\"dingfen\"]; ///设置中心点偏移，使得标注底部中间点成为经纬度对应点 annotationView.centerOffset = CGPointMake(0, -15); return annotationView; &#125; &#125; return nil;&#125; 如果没问题的话，运行的结果会和前面提到的效果图一致的！ 标注移动的回调处理当我们长按住大头针时会移动大头针在地图上的位置。高德地图会回调如下方法 123456789101112131415//移动标注会调用这个方法- (void)mapView:(MAMapView *)mapView annotationView:(MAAnnotationView *)view didChangeDragState:(MAAnnotationViewDragState)newState fromOldState:(MAAnnotationViewDragState)oldState&#123; //标注停止移动时 if (newState == MAAnnotationViewDragStateEnding) &#123; //获取标注新的位置所在的经纬度坐标 CGPoint endPoint = view.centerOffset; CLLocationCoordinate2D coo = [mapView convertPoint:endPoint toCoordinateFromView:view]; NSLog(@\"移动后大头针的经纬度：latitude = %f longitude = %f\",coo.latitude,coo.longitude); &#125;&#125; 在地图上移动大头针后，会输出如下结果： 2016-09-27 16:49:35.255 gaodeMapDemo[5930:2794113] 移动后大头针的经纬度：latitude = 22.646707 longitude = 114.035228 添加折线官网中指导的代理回调方法已经弃用了，还未做出更新！ 自定义一个绘制折线的方法，代码中的坐标需要根据实际项目需求调整 123456789101112131415161718192021222324252627282930313233//绘制折线- (void) addPolyLineOnMap&#123; NSInteger count = 5; CLLocationCoordinate2D commonPolylineCoords[count]; //起点：展滔科技大厦 commonPolylineCoords[0].latitude = 22.639641; commonPolylineCoords[0].longitude = 114.038072; //北站114.02887,22.609235 commonPolylineCoords[1].latitude = 22.609235; commonPolylineCoords[1].longitude = 114.02887; //民乐地铁站114.048809,22.594144 commonPolylineCoords[2].latitude = 22.594144; commonPolylineCoords[2].longitude = 114.048809; //东站114.119699,22.60225 commonPolylineCoords[3].latitude = 22.60225; commonPolylineCoords[3].longitude = 114.119699; //终点：坂田114.06942,22.634804 commonPolylineCoords[4].latitude = 22.634804; commonPolylineCoords[4].longitude = 114.06942; //构造折线对象 MAPolyline *commonPolyline = [MAPolyline polylineWithCoordinates:commonPolylineCoords count:count]; //在地图上添加折线对象 [self.mapView addOverlay: commonPolyline];&#125; 实现协议中的 mapView:rendererForOverlay: 回调函数，设置折线样式。 12345678910111213141516171819202122- (MAOverlayRenderer *)mapView:(MAMapView *)mapView rendererForOverlay:(id&lt;MAOverlay&gt;)overlay&#123; if ([overlay isKindOfClass:[MAPolyline class]]) &#123; NSLog(@\" MAPolylineRenderer 调用了\"); MAPolylineRenderer * lineRenderer = [[ MAPolylineRenderer alloc] initWithOverlay:overlay]; //折线宽度 lineRenderer.lineWidth = 5.0f; //折线的颜色 lineRenderer.strokeColor = [UIColor blueColor]; //折线起始点类型 lineRenderer.lineJoin = kCGLineJoinBevel; //折线终点类型 lineRenderer.lineCap = kCGLineJoinBevel; return lineRenderer; &#125; return nil;&#125; 在ViewDidLoad中调用该方法添加折线： 12//添加折线[self addPolyLineOnMap]; 编译并运行代码，会出现一条蓝色的折线。如图所示： 删除折线 12//commonPolyline是要删除的折线，是MAPolyline的对象[self.mapView removeOverlay:commonPolyline]; 添加圆形覆盖物首先，在 viewDidLoad 中添加如下代码来添加圆圈: 123//添加圆形覆盖物，radius指的是圆圈的半径MACircle *Circle1 = [MACircle circleWithCenterCoordinate:CLLocationCoordinate2DMake(lati, longi) radius:500];[self.mapView addOverlay:Circle1]; 然后，在协议中的 mapView:rendererForOverlay: 回调函数，中添加代码来设置圆圈样式。 将下面的代码加到 return nil; 的前面！ 12345678910111213141516//如果是圆形覆盖物if ( [overlay isKindOfClass:[MACircle class]]) &#123; NSLog(@\" MACircleRenderer 调用了\"); MACircleRenderer * circleRenderer = [[MACircleRenderer alloc] initWithOverlay:overlay]; //设置圆圈的圆边的宽度 circleRenderer.lineWidth = 3.0f; //圆边的颜色 circleRenderer.strokeColor = [UIColor colorWithRed:236/255.0 green:65/255.0 blue:110/255.0 alpha:0.8]; //设置圆圈的填充颜色 circleRenderer.fillColor = [UIColor colorWithRed:236/255.0 green:65/255.0 blue:110/255.0 alpha:0.3]; return circleRenderer; &#125; 编译运行代码，刚添加的圆圈如下所示： 如果想在移动标注的时候删除圈圈，然后在新的标注点添加圆圈，需要修改 didChangeDragState 代理方法中的代码！，修改如下： 123456789101112131415161718192021222324252627282930313233343536373839//移动标注会调用这个方法- (void)mapView:(MAMapView *)mapView annotationView:(MAAnnotationView *)view didChangeDragState:(MAAnnotationViewDragState)newState fromOldState:(MAAnnotationViewDragState)oldState&#123; //标注移动时 if (newState == MAAnnotationViewDragStateStarting) &#123; NSArray * overlays = mapView.overlays; MACircle * cicle = [[MACircle alloc] init]; for (NSInteger i = 0; i &lt; overlays.count; i++) &#123; //如果是圈圈则删除 if ([overlays[i] isKindOfClass:[cicle class]]) &#123; [mapView removeOverlay:overlays[i]]; &#125; &#125; &#125; //标注停止移动时 if (newState == MAAnnotationViewDragStateEnding) &#123; //获取标注新的位置所在的经纬度坐标 CGPoint endPoint = view.centerOffset; //修正一下位置 endPoint.x = endPoint.x + 22; endPoint.y = endPoint.y + 36; CLLocationCoordinate2D coo = [mapView convertPoint:endPoint toCoordinateFromView:view]; NSLog(@\"移动后大头针的经纬度：latitude = %f longitude = %f\",coo.latitude,coo.longitude); //添加新的圈圈 MACircle * Circle1 = [MACircle circleWithCenterCoordinate:coo radius:500]; [mapView addOverlay:Circle1]; &#125;&#125; 编译运行代码，移动标注后，新添加的圆圈如下所示： 高德地图的地图 SDK 到这里就告一段落了 定位SDK的打开方式点这里查看 iOS 定位 SDK. 导航 SDK 的打开方式点这里查看 iOS 导航 SDK . 关于导航，可以参考我的这篇博文。 iOS实现应用外自带地图、高德地图、百度地图导航 室内地图SDK的打开方式点这里查看 iOS 室内地图SDK 室内定位SDK的打开方式点这里查看 iOS 室内定位SDK 结束语本文会阶段性的持续更新的！欢迎大家批评和指正！ 点击下载 本文的demo，记得给 star 支持博主的努力哦！ 感谢阅读，有什么意见可以给我留言!","tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://yoursite.com/tags/Objective-C/"},{"name":"高德地图SDK","slug":"高德地图SDK","permalink":"http://yoursite.com/tags/高德地图SDK/"}]},{"title":"使用 FMDB 管理 SQLite 数据库","date":"2016-03-17T03:06:46.000Z","path":"2016/03/17/FMDB/","text":"版权声明：本文为 muhlenXi 原创文章，欢迎转载，转载请注明来源。 导语： FMDB 是一个面向对象的管理数据库的轻量级框架，它用 Obective-C 语言对数据库 SQLite 的 C 语言API 进行了封装，并且它对多线程的并发操作进行了处理，是线程安全的! 点击阅读全文来深入了解 FMDB 的如何使用。 本文，我会以一个小 demo (同学录)的方式讲在项目中如何使用FMDB的。假如我们有一个老师，他要保存一个班级的所有同学的个人信息，他可以添加学生、删除学生、根据条件查找学生，比如性别、名字等 和 修改学生信息。 如图所示： 下载完整 Demo 一起交流学习，记得给 star 支持博主的努力哦！ FMDB的安装 方式一：使用 CocoaPods 安装。 方式二：直接去 GitHub 下载，拖入到项目中使用。 FMDB 传送梦 注意，如果使用第二种方式，需要导入系统依赖库 sqlite3.0.tbd 后，才能使用。 FMDB 的使用(线程安全的)在一个项目中，我们往往是通过单例的模式去管理数据库中的，也就是说整个项目中只有一个数据库管理员(DatabaseManager)。 首先我们要创建要管理的对象 (Model)，本文中是人 (Person)。 创建人的模型 （XYJPerson）新建一个继承自 NSObject 的 XYJPerson 的类，用来保存人的相关信息。 在XYJPerson.h中，声明我们所需要的信息。 12345678@property (nonatomic,copy) NSString * name; //!&lt; 姓名@property (nonatomic,assign) NSInteger age; //!&lt; 年龄@property (nonatomic,copy) NSString * sex; //!&lt; 性别@property (nonatomic,copy) NSString * QQnumber; //!&lt; qq号@property (nonatomic,copy) NSString * phoneNumber; //!&lt; 手机号@property (nonatomic,copy) NSString * weixinNumber; //!&lt; 微信号@property (nonatomic,copy) NSString * headImagePath; //!&lt; 头像@property (nonatomic,assign) NSTimeInterval updateDate; //!&lt; 添加的时间 在 XYJPerson.m 中覆写 description 方法，可以方便我们查看 Person 的详细信息。 12345- (NSString *)description&#123; return [NSString stringWithFormat:@\"name == %@ \\n age == %ld \\n sex == %@ \\n QQnumber == %@ \\n phoneNumber == %@ \\n weixinNumber == %@ \\n headImagePath == %@ \\n updateDate == %f\",self.name,self.age,self.sex,self.QQnumber,self.phoneNumber,self.weixinNumber,self.headImagePath,self.updateDate]; &#125; 其次，我们要新建一个 XYJDatabaseManage r用来管理数据库中 Perso n数据的 增、删、改、查。 创建 （XYJDatabaseManager）新建一个继承自 NSObject 的 XYJDatabaseManager 的类不是很难。 第一步：在 XYJDatabaseManager.h 文件中导入FMDB的头文件，声明相关属性和单例入口 1#import &lt;FMDB/FMDB.h&gt; 12345@property (nonatomic,strong,readonly) FMDatabaseQueue * databaseQueue; //!&lt; 用户数据库操作的队列，线程安全的/** * 单例入口 */+ (instancetype) shareManager; 第二步：在 XYJDatabaseManager.m 文件中创建数据库和实现单例。 单例方法的实现： 12345678910+ (instancetype)shareManager&#123;static XYJDatabaseManager * manager; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; manager = [[XYJDatabaseManager alloc] init]; &#125;); return manager;&#125; 覆写 init 方法，在 init 方法中创建数据库和表 1234567891011121314151617181920212223242526272829303132333435363738- (instancetype)init&#123; if (self = [super init]) &#123; //数据库存放路径 NSString * libDirPath = [NSSearchPathForDirectoriesInDomains(NSLibraryDirectory, NSUserDomainMask, YES) firstObject]; NSString * dbPath = [libDirPath stringByAppendingPathComponent:@\"databaseDemo.sqlite\"]; NSLog(@\"dbpath == %@\",dbPath); //创建数据库 _databaseQueue = [FMDatabaseQueue databaseQueueWithPath:dbPath]; if (_databaseQueue == nil) &#123; NSLog(@\"数据库创建失败\"); [NSException raise:NSInternalInconsistencyException format:@\"数据库创建异常\"]; &#125; else &#123; //创建一个表 NSString *createTablSQL = @\"CREATE TABLE IF NOT EXISTS T_PersonList (name text PRIMARY KEY NOT NULL, age integer NOT NULL,sex text,qqNumber text,phoneNumber text,weixinNumber text,headImagePath text,updateDate double)\"; [_databaseQueue inDatabase:^(FMDatabase *db) &#123; BOOL ret = [db executeUpdate:createTablSQL]; if (ret) &#123; NSLog(@\"创建T_PersonList 表成功\"); &#125; else &#123; NSLog(@\"创建T_PersonList 表失败\"); &#125; &#125;]; &#125; &#125; return self;&#125; 在 XYJDatabaseManager.m 中也可以写对 Model（Person）数据的增、删、改、查方法，但是为了更加方便一些，我们创建一个 Person 的类别，在这个类别中一次实现上述方法。 创建的XYJPerson类别 （XYJPerson+database）创建方法：Xcode -&gt; File -&gt; New -&gt; File…选择iOS Source Objective-C File -&gt; Next 然后Next下去就好了。 在 XYJPerson+database.h 中声明常用对象的操作方法。 首先得导入#import &quot;XYJDatabaseManager.h&quot;文件。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * 添加或更新 一条数据到数据库中 * * @return 成功或失败 */- (BOOL) saveToDataBase;/** * 插入一条数据到数据库中 * * @return 成功或失败 */- (BOOL) insertToDataBase;/** * 根据名字修改数据库中的那条数据 * * @param lastName 修改之前的名字 * * @return 成功或失败 */- (BOOL) updateToDataBaseWithName:(NSString *) lastName;/** * 从数据库中读出所有的人的信息 * * @return 所有的人数组 */+ (NSArray *) getAllPersonFromDataBase;/** * 根据名字从数据库中查找人的信息 * * @param name 名字 * * @return 人的数组 */+ (NSArray *) getPersonFromDataBasewithName:(NSString *) name;/** * 根据性别从数据库中查找人的信息 * * @param sex 性别 * * @return 人的数组 */+ (NSArray *) getPersonFromDataBasewithSex:(NSString *) sex;/** * 根据名字从数据库中删除信息 * * @param name 要删除的名字 * * @return 成功或失败 */+ (BOOL) deleteFromDataBaseByName:(NSString *) name; 接着是去 XYJPerson+database.m 中文件中实现前面声明的方法： 增加记录将对象保存到数据库的表中，每个对象都是表中的一条记录！注意执行语句的关键词 REPLACE INTO 如果表中存在这条数据，就将这条数据替换掉，如果没有，则把这条数据加入到表中。 12345678910111213- (BOOL)saveToDataBase&#123; NSString * replaceSQl = @\"REPLACE INTO T_PersonList(name, age, sex, qqNumber, phoneNumber, weixinNumber, headImagePath ,updateDate) VALUES(?, ?, ?, ?, ?, ?, ?, ?)\"; __block BOOL ret = NO; [[XYJDatabaseManager shareManager].databaseQueue inDatabase:^(FMDatabase *db) &#123; ret = [db executeUpdate:replaceSQl,self.name,@(self.age),self.sex,self.QQnumber,self.phoneNumber,self.weixinNumber,self.headImagePath,@(self.updateDate)]; &#125;]; return ret;&#125; 插入一条数据到数据库的表中;注意执行语句的关键词 INSERT INTO 1234567891011121314- (BOOL)insertToDataBase&#123; NSString * replaceSQl = @\"INSERT INTO T_PersonList(name, age, sex, qqNumber, phoneNumber, weixinNumber, headImagePath ,updateDate) VALUES(?, ?, ?, ?, ?, ?, ?, ?)\"; __block BOOL ret = NO; [[XYJDatabaseManager shareManager].databaseQueue inDatabase:^(FMDatabase *db) &#123; ret = [db executeUpdate:replaceSQl,self.name,@(self.age),self.sex,self.QQnumber,self.phoneNumber,self.weixinNumber,self.headImagePath,@(self.updateDate)]; &#125;]; return ret;&#125; 删除记录删除根据名字查找到的那条数据;注意执行语句的关键词 DELETE FROM...WHERE 1234567891011121314+ (BOOL)deleteFromDataBaseByName:(NSString *) name&#123; NSString * deleteSQl = @\"DELETE FROM T_PersonList WHERE name = ?\"; __block BOOL ret = NO; [[XYJDatabaseManager shareManager].databaseQueue inDatabase:^(FMDatabase *db) &#123; ret = [db executeUpdate:deleteSQl,name]; &#125;]; return ret;&#125; 修改记录修改根据名字查找到的那条数据;注意执行语句的关键词 UPDATE...SET...WHERE 1234567891011121314- (BOOL)updateToDataBaseWithName:(NSString *)lastName&#123; NSString * replaceSQl = @\"UPDATE T_PersonList SET name = ?, age = ?, sex = ?, qqNumber = ?, phoneNumber = ?, weixinNumber = ?, headImagePath = ? ,updateDate= ? WHERE name = ?\"; __block BOOL ret = NO; [[XYJDatabaseManager shareManager].databaseQueue inDatabase:^(FMDatabase *db) &#123; ret = [db executeUpdate:replaceSQl,self.name,@(self.age),self.sex,self.QQnumber,self.phoneNumber,self.weixinNumber,self.headImagePath,@(self.updateDate),lastName]; &#125;]; return ret;&#125; 查询记录查询到的结果是放在一个 FMResultSet（结果集）中的，遍历这个结果集，将相关数据添加到 Person 对象中，最后以数组的方式返回。 根据名字查询数据;注意执行语句的关键词 `SELECT FROM…WHERE`* 12345678910111213141516171819202122232425262728293031+ (NSArray *)getPersonFromDataBasewithName:(NSString *)name&#123; NSString * querrySQL = @\"SELECT * FROM T_PersonList WHERE name = ?\"; NSMutableArray * result = [NSMutableArray array]; [[XYJDatabaseManager shareManager].databaseQueue inDatabase:^(FMDatabase *db) &#123; FMResultSet * rs = [db executeQuery:querrySQL,name]; while ([rs next]) &#123; XYJPerson * person = [[XYJPerson alloc] init]; //给模型赋值 person.name = [rs stringForColumn:@\"name\"]; person.age = [rs intForColumn:@\"age\"]; person.sex = [rs stringForColumn:@\"sex\"]; person.QQnumber = [rs stringForColumn:@\"qqNumber\"]; person.phoneNumber = [rs stringForColumn:@\"phoneNumber\"]; person.weixinNumber = [rs stringForColumn:@\"weixinNumber\"]; person.updateDate = [rs doubleForColumn:@\"updateDate\"]; person.headImagePath = [rs stringForColumn:@\"headImagePath\"]; [result addObject:person]; &#125; &#125;]; return result;&#125; 根据性别查询数据 123456789101112131415161718192021222324252627282930313233+ (NSArray *)getPersonFromDataBasewithSex:(NSString *)sex&#123; NSString * querrySQL = @\"SELECT * FROM T_PersonList WHERE sex = ?\"; NSMutableArray * result = [NSMutableArray array]; [[XYJDatabaseManager shareManager].databaseQueue inDatabase:^(FMDatabase *db) &#123; FMResultSet * rs = [db executeQuery:querrySQL,sex]; while ([rs next]) &#123; XYJPerson * person = [[XYJPerson alloc] init]; //给模型赋值 person.name = [rs stringForColumn:@\"name\"]; person.age = [rs intForColumn:@\"age\"]; person.sex = [rs stringForColumn:@\"sex\"]; person.QQnumber = [rs stringForColumn:@\"qqNumber\"]; person.phoneNumber = [rs stringForColumn:@\"phoneNumber\"]; person.weixinNumber = [rs stringForColumn:@\"weixinNumber\"]; person.updateDate = [rs doubleForColumn:@\"updateDate\"]; person.headImagePath = [rs stringForColumn:@\"headImagePath\"]; [result addObject:person]; &#125; &#125;]; return result;&#125; 查询表中的所有数据；并根据添加的时间先后顺序排序 123456789101112131415161718192021222324252627282930313233+ (NSArray *)getAllPersonFromDataBase&#123; //根据时间先后顺序排序 //ASC 升序 DESC 降序 NSString * querrySQL = @\"SELECT * FROM T_PersonList ORDER BY updateDate ASC\"; NSMutableArray * result = [NSMutableArray array]; [[XYJDatabaseManager shareManager].databaseQueue inDatabase:^(FMDatabase *db) &#123; FMResultSet * rs = [db executeQuery:querrySQL]; while ([rs next]) &#123; XYJPerson * person = [[XYJPerson alloc] init]; //给模型赋值 person.name = [rs stringForColumn:@\"name\"]; person.age = [rs intForColumn:@\"age\"]; person.sex = [rs stringForColumn:@\"sex\"]; person.QQnumber = [rs stringForColumn:@\"qqNumber\"]; person.phoneNumber = [rs stringForColumn:@\"phoneNumber\"]; person.weixinNumber = [rs stringForColumn:@\"weixinNumber\"]; person.updateDate = [rs doubleForColumn:@\"updateDate\"]; person.headImagePath = [rs stringForColumn:@\"headImagePath\"]; [result addObject:person]; &#125; &#125;]; return result;&#125; 到这里，我们基本的方法都已经写完了，接下来就剩下来调用了。搭建个简易的 UI 界面测试一下 FMDB 的测试搭建一个 Input 界面： 添加数据的调用方法： 12345678910BOOL ret = [person insertToDataBase]; //这样也可以//BOOL ret = [person saveToDataBase]; if (ret) &#123; NSLog(@\"插入数据 到数据库成功\"); &#125; else &#123; NSLog(@\"插入数据 到数据库失败\");&#125; 搭建一个修改信息的界面： 修改数据的调用方法： 1234567if ([person updateToDataBaseWithName:self.lastName]) &#123; NSLog(@\"更新数据 到数据库成功\");&#125;else&#123; NSLog(@\"更新数据 到数据库失败\");&#125; 将TableViewCell向左滑可以删除信息： 删除数据的调用方法： 12//删除数据库数据[XYJPerson deleteFromDataBaseByName:person.name]; 查询所有数据的调用方法 12//从数据库中取出所有的用户NSArray * allPerson = [XYJPerson getAllPersonFromDataBase ]; 一个根据性别查询信息的界面： 根据性别查找数据库的调用方法 1array = [XYJPerson getPersonFromDataBasewithSex:@\"女\"]; 一个根据名字查询信息的界面： 根据名字查找数据库的调用方法 1array = [XYJPerson getPersonFromDataBasewithName:@\"要查询的名字\"]; FMDB 的使用(线程不是安全的)这个暂未更新，后续会补上的…","tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://yoursite.com/tags/Objective-C/"},{"name":"FMDB","slug":"FMDB","permalink":"http://yoursite.com/tags/FMDB/"}]},{"title":"对 iOS 开发中 MVC 模式的理解","date":"2016-02-04T02:41:11.000Z","path":"2016/02/04/MVC/","text":"版权声明：本文为 muhlenXi 原创文章，欢迎转载，转载请注明来源。 前言： MVC，全名是 Model View Controller，是模型 (model)－视图 (view)－控制器 (controller) 的缩写，一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。 学习贵在记录和总结收获！点击阅读全文了解更多！ 正文：MVC 是什么？MVC 是一个基本机制，用于将程序中的所有对象拆分到三个阵营（三层）的一个阵营中。第一层是 Model，第二层是 View，第三层是 Controller。 Model = 你的应用是什么？ Controller = 控制 Model 如何显示在屏幕上。 View = 你的控制器的元素，用于构成界面。 MVC 是如何通信的？Controller -&gt; Model Controller 对 Model 有完全访问权限。 Model -&gt; Controller Model 通过 Notification &amp; KVO 的方式与 Controller 通信。 Controller -&gt; View Controller 对 View 也有完全的访问权限。如：Controller 拥有一个 outlet 属性，该属性指向View 中的对象。 View -&gt; Controller View 通过 action-target 的方式与 Controller 通信。如：button 的点击 View 还通过 Delegate 的方式与 Controller通信。 数据不能作为视图的内部属性。它是通过 data source delegate 的方式与 Controller 通信的。也就是说，Controller 从 Model 中获取数据然后传递给 View。 Model &lt;-&gt; View Model 和 View 不能相互通信。是完全独立的。 通过下图，我们可以很好的理解他们之间的通信方式。 多个MVC的协作MVC 的堆叠可以构成一个复杂的应用 如图所示： 感谢您的阅读，一起学习，一起成长，加油！","tags":[{"name":"MVC","slug":"MVC","permalink":"http://yoursite.com/tags/MVC/"}]},{"title":"关于 NSURLConnection 的使用","date":"2016-01-15T07:48:39.000Z","path":"2016/01/15/NSURLConnection/","text":"版权声明：本文为 muhlenXi 原创文章，欢迎转载，转载请注明来源。 前言： NSURLConnection 是 iOS7之前专门用来做数据请求的类。 学习贵在记录和总结收获！点击阅读全文了解更多！ 基础知识什么是 HTTP 请求？如图就是一个 HTTP 请求简介 一个 HTTP 请求包含URL（请求地址）、Method（请求方式）、Header（请求头）、Body（请求体）。 一个 HTTP 响应包含Header（响应头）、Body（响应体）。 什么是 URL？URL - 统一资源定位符 可以通过 NSURL class 来生成一个 URL： 1NSURL *url = [NSURL URLWithString:@\"http://10.0.8.8/sns/my/user_list.php\"]; 什么是 request？request - 数据请求 可以通过 NSURLRequest class 来生成一个 Request： 创建 Request： 1NSURLRequest *request = [NSURLRequest requestWithURL:url]; 创建带超时的 Request: 1NSURLRequest *request = [NSURLRequest requestWithURL:url cachePolicy:NSURLRequestUseProtocolCachePolicy timeoutInterval:30.0f] 创建可变的的 Request: （可以修改 Request 的属性，如 Method 等，POST 会用到。） 12345NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url];request.HTTPMethod = @\"POST\";//设置请求体NSString *paramStr = @\"username=st1508&amp;password=123456\";request.HTTPBody = [paramStr dataUsingEncoding:NSUTF8StringEncoding]; NSURLConnection 的应用NSURLConnection：负责发送请求，建立客户端和服务器的连接。发送 NSURLRequest 的数据给服务器，并收集来自服务器的响应数据。 发送请求的基本步骤： 发送请求的三个步骤： 1.设置请求路径 2.创建请求对象 3.发送请求（同步或异步请求） 发送同步请求（一直在等待服务器返回数据，这行代码会卡住，如果服务器，没有返回数据，那么在主线程UI会卡住不能继续执行操作）有返回值 发送异步请求：没有返回值 注意：任何 NSURLRequest 默认都是 Get 请求。 NSURLConnection 代码举例发送一个同步请求:1234567891011121314151617181920NSString *urlStr = @\"请求的地址\";NSURL * URL = [NSURL URLWithString:urlStr];NSURLRequest * request = [NSURLRequest requestWithURL:URL cachePolicy:NSURLRequestUseProtocolCachePolicy timeoutInterval:30.0]; //超时30sNSError * error = nil; //请求错误NSURLResponse *response = nil; //请求响应//请求响应的数据NSData * data = [NSURLConnection sendSynchronousRequest:request returningResponse:&amp;response error:&amp;error];//请求成功if (error == nil ) &#123; NSDictionary * jsonDic = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingMutableLeaves error:nil]; NSLog(@\"jsonDic == %@\",jsonDic); //在这里处理响应的数据 &#125;else&#123; NSLog(@\"请求失败：%@\",error.localizedDescription); //在这里处理请求失败的情况&#125; 发送一个异步请求: 默认是 Get方式一：请求的结果通过 Block 返回。 1234567891011121314151617NSURL *URL = [NSURL URLWithString:@\"请求的地址\"]; NSURLRequest *request = [NSURLRequest requestWithURL:URL]; // 发送一个异步请求，请求的结果是通过completionHandler这个Block返回的[NSURLConnection sendAsynchronousRequest:request queue:[NSOperationQueue mainQueue] completionHandler:^(NSURLResponse *response, NSData *data, NSError *connectionError) &#123; if (connectionError != nil) &#123; NSLog(@\"请求出错: %@\", connectionError); //在这里处理请求失败的情况 &#125; else &#123; NSLog(@\"请求成功，解析数据\"); id jsonObj = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingMutableContainers error:nil]; NSLog(@\"jsonObj == %@\",jsonObj); //在这里处理响应的数据 &#125;&#125;]; 方式二：请求的结果通过 Delegate 返回。 详情请看 NSURLConnectionWithDelegateDemo。 发送一个 POST 异步请求:1234567891011121314151617181920212223242526272829303132333435363738394041424344NSURL *url = [NSURL URLWithString:@\"http://10.0.8.8/sns/my/user_list.php\"]; // NSMutableURLRequest 可以修改请求的一些默认设置NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url]; // 如果有必要，可以设置请求头// [request setValue:@\"application/json\" forHTTPHeaderField:@\"Content-Type\"];// [request setValue:@\"2555\" forHTTPHeaderField:@\"Content-Length\"]; // 把请求的Method改成POST，默认是GET// GET请求的参数，是拼在URL的后面// POST请求参数，是放在请求体里面的request.HTTPMethod = @\"POST\"; // page=1&amp;number=5 默认NSString *paramStr = @\"page=1&amp;number=2\";// 把字符串转成二进制对象，NSString -&gt; NSDataNSData *paramData = [paramStr dataUsingEncoding:NSUTF8StringEncoding]; // 把二进制对象，转成字符串，NSData -&gt; NSString// [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding]; // 把参数放到请求体里面request.HTTPBody = paramData; // 如果接口要求参数是一个JSON，就这样写，在这里没办法测试// NSDictionary *dict = @&#123;@\"page\":@\"1\", @\"number\": @\"5\"&#125;;// NSData *paramData2 =[NSJSONSerialization dataWithJSONObject:dict options:NSJSONWritingPrettyPrinted error:nil];// request.HTTPBody = paramData;// 发送POST的异步请求[NSURLConnection sendAsynchronousRequest:request queue:[NSOperationQueue mainQueue] completionHandler:^(NSURLResponse *response, NSData *data, NSError *connectionError) &#123; if (connectionError == nil) &#123; id jsonObj = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingMutableContainers error:nil]; NSLog(@\"jsonObj == %@\",jsonObj); //在这里处理响应的数据 &#125; else &#123; NSLog(@\"请求失败: %@\", connectionError); &#125;&#125;]; 感谢您的阅读，一起学习，一起成长，加油！","tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://yoursite.com/tags/Objective-C/"},{"name":"NSURLConnection","slug":"NSURLConnection","permalink":"http://yoursite.com/tags/NSURLConnection/"}]},{"title":"iOS用户头像的获取与上传","date":"2015-12-01T02:03:45.000Z","path":"2015/12/01/Upload-images/","text":"版权声明：本文为 muhlenXi 原创文章，欢迎转载，转载请注明来源。 导语： 在 APP 的开发过程中，经常涉及到个人信息界面的开发，其中有一个常见的功能，就是用户头像的选择与上传。用户可以通过拍照或者在相册中选择一个已经存在的照片，然后设置为头像并上传到服务器中储存。我们来看看这个功能是怎么实现的。作为一个程序猿，生命不止，学习则不止。 点击阅读全文来了解一下详情吧。 本次开发的需求是，实现一个个人信息界面，用户可以通过两种不同的方式来选择头像并保存到服务器中。本次开发是通过 AFNetworking 这个框架来实现头像的上传功能，通过 SDWebImage 这个框架来实现图片的异步下载和缓存。 AFNetworking 传送门 SDWebImage 传送梦 类似于下面这样的界面： UI界面的搭建这里就忽略了。接下来开始办大事了 选项表的实现不会选项表的可以看这里，记得要设置代理和遵循 ‘UIActionSheetDelegate’ 协议啊,在需要弹出选项列表的事件响应方法中写入如下代码即可 123UIActionSheet * actionSheet = [[UIActionSheet alloc] initWithTitle:nil delegate:self cancelButtonTitle:@“取消” destructiveButtonTitle:nil otherButtonTitles:@“拍照”,@“从手机相册中选择”, nil];[actionSheet showInView:self.view]; 接下来实现代理方法 12345678910111213141516171819202122232425#pragma mark - UIActionSheetDelegate- (void)actionSheet:(UIActionSheet *)actionSheet clickedButtonAtIndex:(NSInteger)buttonIndex&#123; //NSLog(@\"buttonIndex == %ld\",buttonIndex); switch (buttonIndex) &#123; case 0: //照相机 &#123; [self presentCameraImagePicker]; &#125; break; case 1: //从相册获取 &#123; [self presentPhotoLibraryImagePicker]; &#125; break; case 2: &#123; NSLog(@\"取消了头像选择\"); &#125; break; default: break; &#125;&#125; 这里用到的方法，下面会详细介绍。 工欲善其事必先利其器这里详细介绍前面调用的的几个方法 拍照和从手机相册中选择功能需要用到UIImagePickerController,我们就从这个开始写起。 记得遵循 UIImagePickerControllerDelegate,UINavigationControllerDelegate 协议。 拍照【1】拍照 12345678910111213141516171819202122- (void) presentCameraImagePicker&#123; //首先判断该设备是否支持照相功能 if ([UIImagePickerController isSourceTypeAvailable:UIImagePickerControllerSourceTypeCamera]) &#123; UIImagePickerController * imagePicker = [[UIImagePickerController alloc] init]; imagePicker.delegate = self; imagePicker.allowsEditing = YES; //设置为图片的来源为拍照获取模式 imagePicker.sourceType = UIImagePickerControllerSourceTypeCamera; imagePicker.modalPresentationStyle = UIModalPresentationCurrentContext; [self presentViewController:imagePicker animated:YES completion:nil]; &#125; else &#123; NSLog(@\"该设备无摄像头\"); &#125; &#125; 从手机相册中选择照片【2】从手机相册中选择照片 12345678910- (void) presentPhotoLibraryImagePicker&#123; UIImagePickerController * imagePicker = [[UIImagePickerController alloc] init]; imagePicker.delegate = self; imagePicker.allowsEditing = YES; //选择图片的来源为从相册获取 imagePicker.sourceType = UIImagePickerControllerSourceTypePhotoLibrary; [self presentViewController:imagePicker animated:YES completion:nil];&#125; 保存照片到本地沙盒中【3】保存照片到本地沙盒中，并根据条件判断是否要上传到服务器中 12345678910111213141516171819202122232425262728293031323334353637383940- (void) saveImage:(UIImage *) image NeedUpload:(BOOL) upload&#123; NSFileManager * fileManager = [NSFileManager defaultManager]; NSError * error = nil; //照片的存储路径 NSString * imagePath = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES)[0]; //添加照片的名称 imagePath = [imagePath stringByAppendingPathComponent:@\"headImage.png\"]; NSLog(@\"imagePath == %@\",imagePath); //如果本地存在该照片则删除 if ([fileManager fileExistsAtPath:imagePath] == YES) &#123; BOOL ret = [fileManager removeItemAtPath:imagePath error:&amp;error]; if (ret) &#123; NSLog(@\"该路径存在该照片，已删除该文件\"); &#125; &#125; //根据项目要求实际需求改变照片的大小 //改变图像尺寸为120*120 CGSize size = CGSizeMake(120, 120); UIGraphicsBeginImageContext(size); [image drawInRect:CGRectMake(0, 0, size.width, size.height)]; UIImage * newImage = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); //将图片写入本地沙盒中 BOOL ret = [UIImageJPEGRepresentation(newImage, 1.0) writeToFile:imagePath atomically:YES]; if (ret == YES) &#123; NSLog(@\"保存头像图片到本地成功\"); if (upload == YES) &#123; //上传头像到服务器 [self uploadHeadImageToServer]; &#125; &#125; else &#123; NSLog(@\"保存头像图片到本地失败\"); &#125; &#125; 通过 AFNetworking 上传到服务器中【4】关键的一步，上传到服务器中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566- (void) uploadHeadImageToServer&#123; //以下的URL和参数需要根据项目的接口文档做调整 NSString * url = @“这里填写上传头像的URLString”; NSDictionary * dic2 = @“这里写具体的上传参数”; NSLog(@\"上传头像Parameters == %@\",dic2); //初始化AFHTTPSessionManager AFHTTPSessionManager *manager = [AFHTTPSessionManager manager]; // 设置二进制响应解析器 manager.responseSerializer = [AFHTTPResponseSerializer serializer]; // 设置二进制请求解析器 manager.requestSerializer = [AFJSONRequestSerializer serializer]; // 设置超时时间 [manager.requestSerializer willChangeValueForKey:@\"timeoutInterval\"]; manager.requestSerializer.timeoutInterval = 10.f; [manager.requestSerializer didChangeValueForKey:@\"timeoutInterval\"]; // AFNetworking进行multipart/form-data的请求方法 // constructingBodyWithBlock 是用来构造请求体的(HTTPBody) //Post请求上传数据 [manager POST:url parameters:dic2 constructingBodyWithBlock:^(id&lt;AFMultipartFormData&gt; _Nonnull formData) &#123; // 添加照片的文件流 NSError *error = nil; NSString * imagePath = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES)[0]; imagePath = [imagePath stringByAppendingPathComponent:@\"headImage.png\"]; [formData appendPartWithFileURL:[NSURL fileURLWithPath:imagePath] name:@\"headImage\" error:&amp;error]; if (error != nil) &#123; NSLog(@\"添加文件流出错: %@\", error); &#125;else &#123; NSLog(@\"添加文件流成功\"); &#125; &#125; progress:^(NSProgress * _Nonnull uploadProgress) &#123; &#125; success:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) &#123; NSLog(@\"上传头像数据请求成功\"); id jsonObj = [NSJSONSerialization JSONObjectWithData:responseObject options:NSJSONReadingMutableContainers error:nil]; NSLog(@\"%@\", jsonObj); //这里做数据的额后续处理，需根据实际需求操作 NSLog(@\"msg == %@\",jsonObj[@\"msg\"]); NSDictionary * result = jsonObj[@\"result\"]; //拼接图片网络URL NSString * headImageURL = [NSString stringWithFormat:@\"%@/%@\",FF_doname_uploadImage,result[@\"headImage\"]]; NSLog(@\"headImageURL == %@\",headImageURL); //将头像的网络URL保存到本地 [[NSUserDefaults standardUserDefaults] setObject:headImageURL forKey:@\"headImageURL\"]; [[NSUserDefaults standardUserDefaults] synchronize]; //设置头像 [self.headImageView sd_setImageWithURL:[NSURL URLWithString:headImageURL] placeholderImage:[UIImage imageNamed:@\"head60\"]]; &#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123; NSLog(@\"上传头像数据请求成功数据请求失败：%@\", error); &#125;]; &#125; 拍照或选择图片的事件处理 当拍照后，点击使用照片会触发这个代理方法。 当从相册中选择照片后，点击选取后会触发下面这个代理方法，在这个方法中，我们可以处理获取到的照片。 触发的代理方法如下 123456789101112#pragma mark - UIImagePickerControllerDelegate- (void)imagePickerController:(UIImagePickerController *)picker didFinishPickingMediaWithInfo:(NSDictionary&lt;NSString *,id&gt; *)info&#123; [picker dismissViewControllerAnimated:YES completion:nil]; //获取图片 UIImage * image = [info objectForKey:UIImagePickerControllerEditedImage]; [self saveImage:image NeedUpload:YES]; //保存图片到本地,并上传到服务器 &#125; 点击取消会触发这个方法，在这个方法中，我们要关闭照相页面 1234- (void)imagePickerControllerDidCancel:(UIImagePickerController *)picker&#123; [picker dismissViewControllerAnimated:YES completion:nil];&#125; 编译运行代码，如果没问题的话，效果如下: 是不是难度不是很大，恭喜您又学会一招，其实在开发过程中，看优秀的开源代码能然我们走的更远！ 上传多张照片到服务器：AFNetworking 3.0+ 上传多张图片 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//上传多张照片到服务器- (void) uploadPhotosToTheServer&#123; // 1、设置上传图片的接口路径 NSString *urlString = @\"上传图片的地址\"; NSMutableDictionary * paramDic = [NSMutableDictionary dictionary]; // 2、配置上传参数 //比如：paramDic[@\"date\"] = @\"2016-11-11\"; // 基于AFN3.0+ 封装的HTPPSession句柄 AFHTTPSessionManager *manager = [AFHTTPSessionManager manager]; manager.requestSerializer.timeoutInterval = 200; manager.responseSerializer.acceptableContentTypes = [NSSet setWithObjects:@\"text/plain\", @\"multipart/form-data\", @\"application/json\", @\"text/html\", @\"image/jpeg\", @\"image/png\", @\"application/octet-stream\", @\"text/json\", nil]; [manager POST:urlString parameters:paramDic constructingBodyWithBlock:^(id&lt;AFMultipartFormData&gt; _Nonnull formData) &#123; // formData: 专门用于拼接需要上传的数据,在此位置生成一个要上传的数据体 // self.photoArr：是你存放图片的数组,可以是图片，可以是保存在本地的图片路径 // 3、循环添加图片的数据 for (int i = 0; i &lt; self.photoArr.count; i++) &#123; UIImage *image = [UIImage imageWithContentsOfFile:self.self.photoArr[i]]; NSData *imageData = UIImageJPEGRepresentation(image, 0.5); // 在网络开发中，上传文件时，是文件不允许被覆盖，文件重名 // 要解决此问题， // 可以在上传时使用当前的系统事件时间字符串作为文件名 NSDateFormatter *formatter = [[NSDateFormatter alloc] init]; // 设置时间格式 [formatter setDateFormat:@\"yyyyMMddHHmmss\"]; NSString *dateString = [formatter stringFromDate:[NSDate date]]; NSString *fileName = [NSString stringWithFormat:@\"%@.jpg\", dateString]; /* *该方法的参数 1. appendPartWithFileData：要上传的照片[二进制流] 2. name：对应网站上[upload.php中]处理文件的字段（比如upload） 3. fileName：要保存在服务器上的文件名 4. mimeType：上传的文件的类型 */ [formData appendPartWithFileData:imageData name:@\"upload\" fileName:fileName mimeType:@\"image/jpeg\"]; // &#125; &#125; progress:^(NSProgress * _Nonnull uploadProgress) &#123; NSLog(@\"---上传进度--- %@\",uploadProgress); &#125; success:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) &#123; NSLog(@\"---上传成功--- %@\",responseObject); &#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123; NSLog(@\"---上传失败--- %@\", error); &#125;];&#125; 感谢阅读，有什么意见可以给我留言!","tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://yoursite.com/tags/Objective-C/"},{"name":"头像上传","slug":"头像上传","permalink":"http://yoursite.com/tags/头像上传/"}]},{"title":"Effective objective-C 2.0 学习笔记","date":"2015-11-10T06:52:41.000Z","path":"2015/11/10/Effective-objective-C-2-0/","text":"版权声明：本文为 muhlenXi 原创文章，欢迎转载，转载请注明来源。 前言： Effective objective-C,翻译过来是编写高质量 iOS 与 OS X 代码的52个有效方法，作者是 Matt Galloway ，本书是世界级 C++ 开发大师 Scott Meyers 亲自担当顾问编辑的 “Effective Software Development Series” 系列丛书中的新作，Amazon 全五星评价。全书从语法、接口与API设计、内存管理、框架等7大方面总结和探讨了 Objective-C 编程中 52 个鲜为人知的和容易被忽视的特性和陷阱！ 学习贵在记录和总结收获！点击阅读全文了解更多！ Objective-C 源自 Smalltalk ，是一门相当动态的语言，代码是在运行期（runtime）执行的！ 第1条：了解Objective-C语言的起源C++,Java等使用的是function calling ，运行所执行的代码由编译器来决定。如果调用的函数是多态的，那么在运行时就要按照 virtual table (虚方法表) 来查出应该执行哪个函数实现。 Objective-C语言使用的是动态绑定的 message structure (消息结构) ，其运行时所执行的代码由运行环境来决定；无论多态，总是在运行时才会去检查对象的类型和查找所要执行的方法。 Objective-C 语言中的对象是用来指示对象的。 举个🌰 ： 1NSString * str = @\"hello world\"; 对象所占的内存是分配在堆空间中！ 指向对象的指针变量分配在栈上！ 一般不含星号的变量也分配在栈上! 如 CGRect，CGSize… 第2条：在类的头文件中尽量少引用其他头文件 除非确有必要，否则不要引入头文件！使用前向声明！ 解决办法：在类的头文件中使用前向声明提到的类。并在.m文件中引入那些类的头文件。 好处：降低了类之间的耦合度，减少了编译时间， 1@class XYJMyMenuTVC; //前向声明语法 有时无法使用前向声明，比如要声明某个类遵循一项协议。此时，尽量把该类遵循某协议的声明已到匿名类中。如果不行的话，就把协议单独放在一个头文件中，然后将其引入。 第3条：多用字面量语法，少用与之等价的方法 应该使用字面量语法来创建字符串、数值、数组、字典。与创建此类对象的常规方法相比，这么做更加简明扼要。 应该通过取下标操作来访问数组下标或字典中键所对应的元素。 用字面量语法创建数组或字典，若值中有 nil，则会抛出异常。因此，务必确保值里不含 nil ！ 字面量语法举例： 举个🌰 ： 12345678910NSString * string = @\"hello world\"; NSNumber * intNumber = @1;NSNumber * floatNumber = @2.5f;NSNumber * doubleNumber = @3.14159;NSNumber * boolNumber = @YES;NSNumber * charNUmber = @'A'; NSArray * array = @[@\"1\",@\"2\"];NSDictionary * dic = @&#123;@\"keyone\":@\"1\",@\"keytwo\":@\"2\"&#125;; 不可变对象转为可变对象： 举个🌰 ： 123NSMutableArray * arrayM = [@[@\"1\",@\"2\"] mutableCopy];NSMutableString * strM = [@\"hello\" mutableCopy];NSMutableDictionary * dicM = [@&#123;@\"one\":@\"1\"&#125; mutableCopy]; 第4条：多用类型常量，少用#define预处理指令 不要用预处理指令定义常量。这样定义出来的常量不含类型信息，编译器只是会在编译前据此查找与替换操作。即使有人重新定义了常量值，编译器也不会产生警告信息，这将导致应用程序中的常量值不一致。 在实现文件中使用 static const 来定义 只在编译单元内可见的常量。由于此类常量不在全局符号表中，所以无须为其名称加前缀。 在头文件中使用 extern 来声明全局常量，并在相关实现文件中定义其值。这种常量会出现在全局符号表中，所以其名称应加以区隔，通常用与之相关的类名称做前缀。 常量名称的常用命名法是：若常量局限于某编译单元内，也就是实现文件之内，则在前面加字母 k ； 若不打算公开某个常量，则应将其定义在使用该常量的实现文件里 变量一定要同时用 static 与 const 来声明，如果试图修改由 const 修饰符所声明的变量，那么编译器就会报错！ 举个🌰 ： 1static const NSTimeInterval kAnimationDuration = 0.3; //定义一个类型为NSTimeInterval的时间常量 若常量在类之外可见，则通常以类名为前缀。 常量定义从右往左解读，注意 const 修饰符在常量类型中的位置。 举个🌰 ： 123extern NSString * const XYJLoginManagerDidLoginNotification; //在.h文件中声明NSString * const XYJLoginManagerDidLoginNotification = @\"XYJLoginManagerDidLoginNotification\"; //在.m文件中定义 第5条：用枚举表示状态、选项、状态码 应该用枚举来表示状态机的状态、传递给方法的选项以及状态码等值，给这些值起个易懂的名字吧。 如果把传递给某个方法的选项表示为枚举类型，而多个选项又可同时使用，那么就将各选项值定义为 2 的幂，以便通过按位或操作将其组合起来。 用 NS_ENUM与NS_OPTIONS 宏来定义枚举类型，并指明底层数据类型。这样做可以确保枚举是用开发者所选的底层数据类型实现出来的，而不会采用编译器所选的类型。 在处理枚举类型的 switch 语句中不要实现 default 分支，这样的话，加入新枚举之后，编译器就会提示开发者：switch 语句并未处理所有枚举。 凡是需要以 按位或 操作来组合的枚举都应使用 NS_OPTIONS 定义，若是枚举不需要互相组合，则应使用 NS_ENUM 来定义 举个🌰 ： 12345678910111213141516171819typedef enum : NSUInteger &#123; ConnectionStateDisconnected , ConnectionStateConnecting, ConnectionStateConnected,&#125; TCPConnectionState;typedef NS_ENUM (NSUInteger,UDPConnectionState) &#123; UDPConnectionStateDisconnected, UDPConnectionStateConnecting, UDPConnectionStateConnected,&#125;;typedef NS_OPTIONS(NSUInteger, PermittedDirection)&#123; PermittedDirectionUp = 1 &lt;&lt; 0, PermittedDirectionDown = 1 &lt;&lt; 1, PermittedDirectionLeft = 1 &lt;&lt; 2, PermittedDirectionRight = 1 &lt;&lt; 3, &#125;; 第6条：理解属性这一概念 可以用@property语法来定义对象中所封装的数据。 通过 “attribute（特质)” 来指定存储数据所需的正确语义。 在设置属性所对应的实例变量时，一定要遵从该属性所声明的语义。 开发 iOS 程序时应该使用 noatomic 属性，因为 atomic 属性会严重影响性能。 在对象之间传递数据并执行任务的过程就叫做”消息传递”（Messaging）。 当应用程序运行起来，为其提供相关支持的代码叫做 “Objective-C runtime”（运行期环境） 在类的的实现代码里可以通过 @synthesize 语法来指定实例变量的名字 举个🌰 ： 要写在@implementation的下面 1@synthesize firstName = _myFirstName; //将生成的实例变量命名为_myFirstName 在类的的实现代码里可以通过 @dynamic 语法来阻止编译器自动合成存取方法 举个🌰 ： 要写在 @implementation 的下面 1@dynamic firstName; 属性的特质： 1.原子性（atomic / noatomic） 2、读写权限 （readwrite / readonly） 3、内存管理语义（assign / strong / weak / unsafe_unretained / copy） 4、方法名 （setter = 名字 / getter = 名字） 第7条：在对象内部尽量直接访问实例变量 在对象内部 读取数据 时，应该直接通过 实例变量 来读，而在 写入数据时，则应通过 属性 来写。 在 初始化方法 和 dealloc 方法中，总是应该直接通过 实例变量 来读写数据。 有时候会使用 懒加载 配置某个数据，这种情况下，需要通过 属性 来读取数据。 第8条：理解 “对象等同性” 这一概念 若想检测的对象的等同性，请提供 isEqual: 和 hash 方法。 相同的对象必须具有相同的哈希码，但是两个哈希码相同的对象却未必相同。 不要盲目地逐个检测每条属性，而是依照具体需求来制定检测方案。 编写 hash 方法时，应该使用计算速度快而且哈希码碰撞几率低的算法。 第9条：以“类族模式” 隐藏实现细节 类族模式可以把实现细节隐藏在一套简单的公共接口后面。 系统框架中经常使用类族。 从类族的公共抽象基类中继承子类时要当心，若有开发文档，则应首先阅读。 需要向类族中新增实体子类，需要遵守的几条规则： 子类应该继承自类族的抽象基类。 子类应该定义自己的数据存储方式。 子类应当覆写超类文档中指明需要覆写的方法。 第10条：在既有类中使用关联对象存放自定义数据 可以通过“关联对象”机制来把两个对象关联起来。 定义关联对象时可指定内存管理语义，用以模仿定义属性时所采用的“拥有关系” 和 “非拥有关系”。 只有其他做法不可行时才应选用关联对象，因为这种做法通常会引入难以查找的bug。 对象关联类型： 关联对象 等效的@property属性 OBJC_ASSOCIATION_ASSIGN assign OBJC_ASSOCIATION_RETAIN_NONATOMIC nonatomic,retain OBJC_ASSOCIATION_COPY_NONATOMIC nonatomic,copy OBJC_ASSOCIATION_RETAIN retain OBJC_ASSOCIATION_COPY copy 管理关联对象的方法： 以给定的键和策略为某对象设置关联对象值 1objc_setAssociatedObject(id object, void *key, d value, objc_AssociationPolicy policy) 从某对象中根据键获取设置关联对象的值 1objc_getAssociatedObject(id object, const void *key) 移除指定对象的全部关联对象 1objc_removeAssociatedObjects(id object) 第11条：理解objc_msgSend的作用 消息由接收者、选择子及参数构成。给某对象发送消息（invoke a message）也就相当于在该对象上调用方法 (call a method)。 发给某对象的全部消息都要由”动态消息派发系统（dynamic message dispatch system）来处理，该系统会查出对应的方法，并执行其代码。” objc_msgSend 函数会依据接收者与选择子的类型来调用适当的方法。为了完成此操作，该方法需要在接收者所属的类中搜寻其”方法列表”（list of methods），如果能找到与选择子名称相符的方法，就跳至其实现代码。如果找不到，那就沿着继承体系继续向上查找，等找到合适的方法之后再跳转。如果做种还是找不到相符的方法，那就执行“消息转发” (message forwarding) 操作。 第12条：理解消息转发机制 \u0010若对象无法响应某个选择子，则进入消息转发流程。 通过运行期的动态方法解析功能，我们可以在需要用到某个方法时再将其加入类中。 对象可以把其无法解读的某些选择子转交给其他对象来处理。 经过上述两步之后，如果还是没办法处理选择子，那就启动完整的消息转发机制。 消息转发分为两大阶段： 第一阶段：先征询接收者所属的类，看其是否能动态添加方法，以处理这个未知的选择子 (unknow selector)，这叫做动态方法解析（dynamic selector resolution）。 第二阶段：(完整的消息转发机制 full forwarding mechanism ) 如果运行期系统已经把第一阶段执行完了，那么接收者自己就无法再以动态新增方法的手段来相应包含该选择子的消息了，这时，运行期系统会请求接收者以其他手段来处理与消息相关的方法调用。 第一步：如果有其他对象能够处理这条消息，则把消息转给那个对象，消息转发过程结束，一切如常。 第二步：如果没有（replacement receiver），则启动完整的消息转发机制，运行期系统会把与消息有关的全部细节都封装到 NSInvocation 对象中，再给接收者最后一次机会，令其设法解决当前还未处理的这条消息。 对象收到无法解读的消息后，首先会调用其所属类的类方法： 1+(BOOL)resolveInstanceMethod:(SEL)sel 第13条：用方法调配技术(method swizzling)调试黑盒方法 在运行期，可以向类中新增或替换选择子所对应的方法实现。 使用另一份实现来替换原有的方法实现，这道工序叫做”方法调配”，开发者常用此技术向原有实现中添加新功能。 一般来说，只有调试程序的时候才需要在运行期修改方法实现，这种做法不宜滥用。 交换方法实现，举个 🌰： 12345678//获取lowercaseString的方法实现Method originalMethod = class_getInstanceMethod([NSString class], @selector(lowercaseString));//获取自定义的xyj_myLowercaseString的方法实现Method swappedMethod = class_getInstanceMethod([NSString class], @selector(xyj_myLowercaseString));//交换两个方法的实现method_exchangeImplementations(originalMethod, swappedMethod); 第14条：理解”类对象”的用意 每个实例都有一个指向 Class 对象的指针，用以表明其类型，而这些 Class 对象则构成了类的继承体系。 如果对象的类型无法在编译期确定，那么就应该使用类型信息查询方法来探知。 尽量使用类型查询方法来确定对象类型，而不要直接比较类对象，因为某些对象可能实现了消息转发功能。 每个对象结构体的首个成员是Class类的变量，该变量定义了对象所属的类，通常称之为is a指针。 isMemberOfClass:判断对象是否为某个特定类的实例。 isKindOfClass:判断对象是否为某类或其派生类的实例。 第15条：用前缀避免命名空间冲突 选择与你的公司、应用程序或二者皆有关联之名称作为类名的前缀，并在所有代码中均使用这一前缀。 若自己所开发的程序库中用到了第三方库，则应为其中的名称加上前缀。 Apple宣称其保留使用所有“两字母前缀（two-letter prefix）”的权利，所以你自己选用的前缀应该是三个字母的！ 第16条：提供 “全能初始化方法（designed initializer）” 在类中提供一个全能初始化方法，并于文档中指明。其他初始化方法均应调用此方法。 若子类的全能初始化方法与超类不同，则需覆写超类中的对应方法。 如果超类的初始化方法不适用于子类，那么应该覆写这个超类方法，并在其中抛出异常。 全能初始化方法：指为对象提供必要信息以便其能完成工作的初始化方法。 如何抛异常 举个 🌰 ： 1@throw [NSException exceptionWithName:NSInternalInconsistencyException reason:@\"这里写异常原因\" userInfo:nil]; 第17条：实现description方法 实现 description 方法返回一个有意义的字符串，用以描述该实例。 如果想在description方法中输出很多互不相同的信息，那就借助NSDictionary类的description方法。 举个 🌰 ： 1234- (NSString *)description&#123; return [NSString stringWithFormat:@\"&lt;%@: %p %@&gt;\",[self class],self,@&#123;@\"title\":_title,@\"latitude\":@(_latitude),@\"longitude\":@(_longitude)&#125;];&#125; 若想在调试时打印出更详尽的对象描述信息，则应实现 debugDescription 方法。 debugDescription方法是开发者在调试器(debugger)中以控制台命令打印对象时才调用的。 LLDB 的 po 命令可以完成对象打印(print-object)工作！举个 🌰 ： 123456789- (NSString *)description&#123; return [NSString stringWithFormat:@\"%@ %@\",_firstName,_lastName];&#125;- (NSString *)debugDescription&#123; return [NSString stringWithFormat:@\"&lt;%@: %p \\\" %@ %@ \\\"&gt;\",[self class],self,_firstName,_lastName];&#125; 第18条：尽量使用不可变对象 尽量创建不可变的对象。 举个 🌰 ： 1@property (nonatomic,copy,readonly) NSString * firstName; //!&lt; 名字 若某属性仅用于对象内部修改，则在 “class-continuation分类” 中将 readonly 属性扩展为 readwrite 属性。 举个 🌰 ： 12345@interface XYJPerson ()@property (nonatomic,copy,readwrite) NSString * firstName;@end 不要把可变的 collection 作为属性公开，而应提供相应的方法，以此修改对象中的可变 collection。 举个 🌰 ： 12345678910111213141516171819202122232425262728293031323334353637383940//.h文件中的声明@property (nonatomic,strong,readonly) NSSet * friends;- (void) addFriends:(XYJPerson *) person;- (void) deleteFriends:(XYJPerson *) person;//.m文件中的实现&#123; NSMutableSet * _internalFriends;&#125;- (instancetype)initWithFirstName:(NSString *) first lastName:(NSString *) last&#123; self = [super init]; if (self) &#123; _firstName = [first copy]; _lastName = [last copy]; _internalFriends = [NSMutableSet new]; //注意初始化 &#125; return self;&#125;- (void)addFriends:(XYJPerson *)person&#123; [_internalFriends addObject:person];&#125;- (void) deleteFriends:(XYJPerson *)person&#123; [_internalFriends removeObject:person];&#125;//覆写friends的getter方法- (NSSet *)friends &#123; return [_internalFriends copy];&#125; 不要在返回的对象上查询类型以确定其是否可变。 开发者或许不宜从底层直接修改对象中的数据。 第19条：使用清晰而协调的命名方式 起名时应遵从标准的 Objective-C 命名规范，这样创建出来的接口更容易为开发者所理解。 方法名要言简意赅，从左至右读起来要像个日常用语中的句子才好。 方法名里不要使用缩略后的类型名称 给方法起名时的第一个要务就是确保风格与你自己的代码或所集成的框架相符。 变量与方法名使用 驼峰式大小命名法 — 以小写字母开头，其后每个单词首字母大写。类名也用驼峰命名法，不过其首字母要大写，前面通常还有三个前缀字母。 方法命名的注意事项： 如果方法的返回值是新创建的，那么方法名的首个词应该是返回值的类型，除非前面还有修饰语。属性的存取方法不遵循这种命名方式，因为一般认为这些方法不会创建新对象，即便有时返回内部对象的一份拷贝，我们也认为那相当于原有的对象。这些存取方法应该按照其所对应的属性来命名。 应该把表示参数类型的名词放在参数前面。 如：mutableString 如果方法要在当前对象上执行操作，那么就应该包含动词；若执行操作时还需要参数，则应该在动词后面加上一个或多个名词。 不要使用 str 这种简称，应该使用 string 这样的全称。 Boolean 属性应加 is 前缀。如果某方法返回非属性的 Boolean 值，那么应该根据其功能，选用 has 或 is 当前缀。 将 get 这个前缀留给那些借由“输出参数”来保存返回值的方法。 第20条：为私有方法名加前缀 给私有方法的名称加上前缀，这样可以很容易地将其同公共方法区别开。 不要单用一个下划线做私有方法的前缀，因为这种做法是预留给苹果公司用的。 第21条：理解Objective-C错误类型 \u0010只有发生了可使整个应用程序崩溃的严重错误时，才应使用异常。 在错误不那么严重的情况下，可以指派委托方法 (delegate method) 来处理错误，也可以把错误对象放到 NSError 对象里，经由输出参数返回给调用者。 第22条：理解 NSCopying协议 若想令自己所写的对象具有拷贝功能，则需实现 NSCopying 协议。 如果自定义的对象分为可变版本和不可变版本，那么需要同时实现 NSCopying 和 NSMutableCopying 协议。 复制对象时需决定采用深拷贝还是浅拷贝，一般情况下应该尽量执行浅拷贝。 如果你写的对象需要深拷贝，那么可考虑新增一个专门执行深拷贝的方法。 若想某个类支持拷贝功能，只需声明该类遵循NSCopying协议，并实现其中的 copyWithZone 这个方法。 举个 🌰 ： 12345- (id) copyWithZone:(NSZone *) zone&#123; XYJPerson * copy = [[[self class] allocWithZone:zone] initWithFirstName:_firstName andLastName:_lastName]; return copy;&#125; 在可变对象上调用 copy 方法会返回另外一个不可变类的实例。 深拷贝：在拷贝对象自身时，将其底层数据也一并复制过去。 浅拷贝：只拷贝容器对象本身，而不复制其中数据，浅拷贝之后的内容与原始内容均指向相同对象。 第23条：通过委托与数据源协议进行对象间通信 委托模式为对象提供了一套接口，使其可由此将相关事件告知其他对象。 将委托对象应该支持的接口定义成协议，在协议中把可能需要处理的事件定义成方法。 当某对象需要从另外一个对象中获取数据时，可以使用委托模式。这种情境下，该模式亦称“数据源协议（data source protocol）”。 若有必要，可实现含有位段的结构体，将委托对象是否能相应相关协议方法这一信息缓存至其中。 Objective-C不支持多重继承，因而我们把某个类应该实现的一系列方法定义在协议里面。协议最为常见的用途是实现委托模式。 类别（Category）使得我们无需继承子类即可直接为当前类添加方法。 委托模式（Delegate pattern）的主旨是： 定义一套接口，某对象若想接受另一个对象的委托，则需遵从此接口，以便成为其委托对象 （Delegate）。而另一个对象则可以给其委托对象回传一些信息，也可以在发生相关事件时通知委托对象。 被委托的对象的操作步骤： 1、定义一套协议，协议名通常是在相关类名后面加上 Delegate 一词，然后声明协议要实现的方法，一般是可选的，用 @optional 关键字标注。 2、在类中声明一个委托对象的属性，需用 weak 来修饰。 3、事件触发的时候调用声明的协议方法。 委托对象的操作步骤： 1、一般在 class-continuation 分类中声明遵守该委托协议。 2、设置被委托对象的 Delegate 为 self。 3、实现委托协议中的代理方法。 第24条：将类的实现代码分散到便于管理的数个分类（category）之中 使用分类机制把类的实现代码划分成易于管理的小块。 将应该视为“私有”的方法归入名为 Private 的分类中，以隐藏实现细节。 第25条：总是为第三方类的分类名称加前缀 向第三方类中添加分类时，总应给其名称加上你专用的前缀。 向第三方类中添加分类时，总应给其中的方法加上你专用的前缀。 第26条：勿在分类中声明属性 把封装数据所用的全部属性都定义在主接口里。 在“ class-continuation 分类”之外的其他分类中，可以定义存取方法，但尽量不要定义属性。 第27条：使用“class-continuation分类”隐藏实现细节 通过 class-continuation 分类向类中新增实例变量。 如果某属性在主接口中声明为 readonly ，而类的内部又要用设置方法修改此属性，那么就在 class-continuation分类 中将其扩展为 readwrite。 把私有方法的原型声明在 class-continuation 分类里面。 若想使类所遵循的协议不为人所知，则可于class-continuation 分类中声明。 第28条：通过协议提供匿名对象 协议可在某种程度上提供匿名类型。具体的对象类型可以淡化成遵从某协议的 id 类型，协议里规定了对象所应实现的方法。 使用匿名对象来隐藏类型名称（或类名）。 如果具体类型不重要，重要的是对象能够响应（定义在协议里的）特定方法，那么可以使用匿名对象来表示。 第29条：理解引用计数 引用计数机制通过可以递增递减的计数器来管理内存。对象创建好之后，其保留计数至少为 1。若保留计数为正，则对象继续存活。当保留计数降为 0 时，对象就销毁了。 在对象生命周期中，其余对象通过引用来保留或释放此对象。保留和释放操作分别会递增及递减保留计数。 autorelease 能延长对象生命周期，使其在跨越方法调用边界后依然可以存活一段时间。 第30条：以ARC简化引用计数 有 ARC 之后，程序员就无需担心内存管理问题了。使用 ARC 来编程，可省去类中的许多“样板代码”。 ARC 管理对象生命期的办法基本上就是：在合适的地方插入“保留”及“释放”操作，在ARC环境下，变量的内存语义可以通过修饰符指明，而原来则需要手工执行“保留”及“释放”操作。 由方法所返回的对象，其内存管理语义总是通过方法名来体现。ARC 将此确定为开发者必须遵守的原则。 ARC 只负责管理 Objective-C 对象的内存。尤其要注意：CoreFoundation 对象不归 ARC 管理，开发者必须适时调用 CFRetain / CFRelease。 第31条：在 dealloc 方法中只释放引用并解除监听 在 dealloc 方法里，应该做的事情就是释放指向其他对象的引用，并取消原来订阅的键值观测（KVO）或 NSNotificationCenter 等通知，不要做其他事情。 如果对象持有文件描述符等系统资源，那么应该专门编写一个方法来释放此种资源。这样的类要和其使用者约定：用完资源后必须调用 close 方法。 执行异步任务的方法不应在 dealloc 方法里调用；只能在正常状态下执行的那些方法也不应在 dealloc 里调用，因为此时对象已处于正在回收的状态了。 第32条：编写“异常安全代码”时留意内存管理问题 捕获异常时，一定要注意将 try 块内所创立的对象清理干净。 在默认情况下，ARC 不生成安全处理异常所需的清理代码。开启编译器标志后，可以生成这种代码，不过会导致应用程序变大，而且降低运行效率。 若使用ARC且必须捕获异常，则需打开编译器的 -fobjc-arc-exceptions 标志。 第33条：以若引用避免保留环 将某些应用设为 weak，可避免出现“保留环”。 weak 引用可以自动清空，也可以不自动清空。自动清空（ autoniling） 是随着 ARC 而引入的新特性，由运行期系统来实现。在具备自动清空功能的弱引用上，可以随意读取其数据，因为这种引用不会指向已经回收过的对象。 unsafe_unretained 一词表明，属性值可能不安全，而且不归此实例所拥有。weak 和 unsafe_unretained 的作用一样，唯一的不同是，只要系统把属性回收，属性值就会自动设置为 nil。但是 unsafe_unretained 属性仍然指向那个已经回收的实例。 第34条：以“自动释放池”降低内存峰值 自动释放池排布在栈中，对象收到 autorelease 消息后，系统将其放入最顶端的池里。 合理运用释放池，可降低应用程序的内存峰值。 @autoreleasepool 这种新式写法能创建出更为轻便的自动释放池。 自动释放池用于存放那些需要在稍后某个时刻释放的对象。清空自动释放池时，系统会向其中的对象发送release 消息。 内存峰值 （high-memory waterline） 是指应用程序在某个特定时间段内的最大内存用量 （highest memory footprint）。 第35条：用“僵尸对象”调试内存管理问题 系统在回收对象时，可以不将其真的回收，而是把它转化为僵尸对象。通过环境变量 NSZombieEnabled 可开启此功能。 系统会修改对象的 isa 指针，令其指向特殊的僵尸类，从而使该对象变为僵尸对象。僵尸类能够响应所有的选择子，响应方式为：打印一条包含消息内容及其接收者的消息，然后终止应用程序。 第36条：不要使用retainCount 对象的保留计数看似有用，实则不然，因为任何给定时间点上的”绝对保留计数”（absolute retain count）都无法反应对象生命期的全貌。 引入 ARC 之后，retainCount 方法就正式废止了，在 ARC 下调用该方法会导致编译器报错。 第37条：理解Block这一概念 块是 C、C++、Objective-C 中的词法闭包。 块可接收参数，也可返回值。 块可以分配在栈或堆上，也可以是全局的。分配在栈上的块可拷贝在堆里。这样的话，就和标准的Objective-C 对象一样，具备引用计数了。 块的语法结构如下： 1return_type (^block_name)(parameters) 举个 🌰 ： 123int (^addBlock) (int a, int b) = ^(int a, int b) &#123; return a+b;&#125; 块的强大之处：在声明它的范围内，所有变量都可以为其捕获。如果要修改捕获的变量，那么，声明变量的时候需要加上 __block 关键词。 第38条：为常用的Block类型创建typedef 以 typedef 重新定义块类型，可令块变量用起来更加简单。 定义新类型时应遵守现有的命名习惯，勿使其名称与别的类型相冲突。 不妨为同一个块签名定义多个类型别名。如果要重构的代码使用了块类型的某个别名，那么只需修改相应的typedef 中的块签名即可，无需改动其他 typedef。 typedef 关键字用于给类型起个易读的别名。* 1typedef double NSTimeInterval; Block 的 typedef: 1typedef int (^XYJSomeBlock) (BOOL flag, int value); 第39条：用handle块降低代码分散程度 在创建对象时，可以使用内联的 handle 块将相关逻辑一并声明。 在有多个实例需要监控时，如果采用委托模式，那么经常需要根据传入的对象来切换，而若改用 handle 块来实现，则可直接将块与相关对象放在一起。 设计 API 时如果用到了 handle 块，那么可以增加一个参数，使调用者可通过此参数来决定应该把块安排在哪个队列上。 第40条：用块引用其所属对象时不要出现保留环 如果块所捕获的对象直接或间接地保留了块本身，那么就得当心保留环问题。 一定要找个适当的时机解除保留环，而不能把责任推给 API 的调用者。 第41条：多用派发队列，少用同步锁 派发队列可用来表述同步语义（synchronize semantic），这种做法要比使用 @synchronized 块或NSLock 对象更简单。 将同步和异步派发结合起来，可以实现与普通加锁机制一样的同步行为，而这么做却不会阻塞执行异步派发的线程。 使用同步队列及栅栏块，可以令同步更加高效。 第42条：多用 GCD，少用 performSelector 系列方法 performSelector 系列方法在内存管理方面容易有疏失。它无法确定将要执行的选择子具体是什么，因而 ARC 编译器也就无法插入适当的内存管理方法。 performSelector 系列方法所能处理的选择子太过局限了，选择子的返回值类型及发送给方法的参数个数都受到限制。 如果想把任务放到另一个线程上执行，那么最好不要用 performSelector 方法，而是应该把任务封装在块里，然后调用 GCD 的相关方法来实现。 第43条：掌握 GCD 及操作队列的使用时机 在解决多线程与任务管理问题时，派发队列并非唯一方案。 操作队列提供了一套高层的 Objective-C API ,能实现纯 GCD 所具备的绝大部分功能，而且还能完成一些更为复杂的操作，那些操作若改用 GCD 来实现，则需另外编写代码。 GCD是纯C的API，而操作队列则是 Objective-C 的对象。 使用NSOperation和NSOperationQueue的好处： 1、取消某个操作。 2、指定操作间的依赖关系。 3、通过键值观察机制监控 NSOperation 对象的属性。 4、指定操作的优先级。 5、重用 NSOperation 对象。 第44条：通过 Dispatch Group 机制，根据系统资源状况来执行任务 1、一系列任务可归入一个 dispatch group 之中。开发者可以在这组任务执行完毕时获得通知。 2、通过 dispatch group，可以在并发式派发队列里同时执行多项任务。此时GCD会根据系统资源状况来调度这些并发执行的任务。开发者若自己来实现此功能，则需编写大量代码。 第45条：使用dispatch_once来执行只需运行一次的线程安全代码 1、经常需要编写“只需执行一次的线程安全的代码”（thread-safe single-code execution）。通过GCD 所提供的 dispatch_once 函数，很容易就能实现此功能。 2、标记应该声明在 static 或 global 作用域中，这样的话，在把只需执行一次的块传给dispatch_once 函数时，传进去的标记也是相同的。 单例的使用：举个 🌰 1234567891011+ (FFHttpRequestManager *)shareManager&#123; static FFHttpRequestManager *shareInstance = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; shareInstance = [[FFHttpRequestManager alloc]init]; &#125;); return shareInstance;&#125; 第46条：不要使用dispatch_get_current_queue dispatch_get_current_queue 函数的行为常常与开发者所预期的不同。此函数已经废弃，只应做调试只用。 由于派发队列是按层级来组织的，所以无法单用某个队列对象来描述“当前队列这一概念”。dispatch_get_current_queue 函数用于解决由不可重入的代码所引发的死锁，然而能用此函数解决的问题，通常也能改用“队列特定数据”来解决。 第47条：熟悉系统框架 许多系统框架都可以直接使用。其中最重要的是 Foundation 与 CoreFoundation，这两个框架提供了构建应用程序所需的许多核心功能。 很多常见任务都能用框架来做，例如音频与视频处理、网络通信、数据管理等。 请记住：用纯C写成的框架与用 Objective-C 写成的一样重要，若想成为优秀的 Objective-C 开发者，应该掌握 C 语言的核心概念。 第48条：多用块枚举，少用for循环 遍历 collection 有四种方式。最基本的是 for 循环，其次是 NSEnumerator 遍历法及快速遍历法，最新最先进的方式则是“块枚举法”。 “块枚举法”本身就能通过 GCD 来并发执行遍历操作，无须另行编写代码。而采用其他遍历方式则无法轻易实现这一点。 若提前知道待遍历的 collection 含有何种对象，则应修改块签名，指出对象的具体类型。 for 循环数组的遍历 123456NSArray * anArray = @[@\"one\",@\"two\",@\"three\"];for (int i = 0; i &lt; anArray.count; i++) &#123; id object = anArray[i]; // Do something with 'object'&#125; 字典的遍历 12345678NSDictionary * aDictionary = @&#123;@\"one\":@\"1\",@\"two\":@\"2\",@\"three\":@\"3\"&#125;;NSArray * keys = [aDictionary allKeys];for (int i = 0; i &lt; keys.count; i++) &#123; id key = keys[i]; id value = aDictionary[key]; // Do something with 'key' and 'value'&#125; Set 的遍历 123456NSSet * aSet = /* ... */;NSArray * objects = [aSet allObjects];for (int i = 0; i &lt; objects.count; i++) &#123; id object = objects[i]; // Do something with 'Object'&#125; NSEnumerator 来遍历数组的遍历 123456NSArray * array = @[@\"apple\",@\"banana\",@\"orange\"];NSEnumerator * enumerator = [array objectEnumerator];id object;while ((object = [enumerator nextObject]) != nil) &#123; //Do something with 'object'&#125; 数组的反向遍历 1234NSArray * array = @[@\"apple\",@\"banana\",@\"orange\"];for (id object in [array reverseObjectEnumerator]) &#123; // Do something with 'object'&#125; 字典的遍历 12345678NSDictionary * aDictionary = @&#123;@\"one\":@\"1\",@\"two\":@\"2\",@\"three\":@\"3\"&#125;;NSEnumerator * enumerator = [aDictionary keyEnumerator];id key;while ((key = [enumerator nextObject]) != nil) &#123; id value = aDictionary[key]; // Do something with 'key' and 'value'&#125; Set 的遍历 1234567NSSet * aSet = /* ... */;NSEnumerator * enumerator = [aSet objectEnumerator];id object;while ((object = [enumerator nextObject]) != nil) &#123; // Do something with 'object'&#125; for-in 快速遍历数组的遍历 12345NSArray * anArray = @[@\"one\",@\"two\",@\"three\"];for (id object in anArray) &#123; // Do something with 'object'&#125; 字典的遍历 123456NSDictionary * aDictionary = @&#123;@\"one\":@\"1\",@\"two\":@\"2\",@\"three\":@\"3\"&#125;;for (id key in aDictionary) &#123; id value = aDictionary[key]; // Do something with 'key' and 'value'&#125; Set 的遍历 12345NSSet * aSet = /* ... */;for (id object in aSet) &#123; // Do something with 'object'&#125; 基于块的遍历方式数组的遍历 123456789NSArray * array = @[@\"apple\",@\"banana\",@\"orange\"]; [array enumerateObjectsUsingBlock:^(id _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123; //Do something with 'obj' //if stop *stop = YES; &#125;]; 字典的遍历 123456789NSDictionary * aDictionary = @&#123;@\"one\":@\"1\",@\"two\":@\"2\",@\"three\":@\"3\"&#125;; [aDictionary enumerateKeysAndObjectsUsingBlock:^(id _Nonnull key, id _Nonnull obj, BOOL * _Nonnull stop) &#123; //Do something with 'key' and 'obj' //if stop *stop = YES; &#125;]; Set 的遍历 12345678NSSet * aSet = /* ... */; [aSet enumerateObjectsUsingBlock:^(id _Nonnull obj, BOOL * _Nonnull stop) &#123; //Do something with 'obj' //if stop *stop = YES;&#125;]; 第49条：对自定义其内存管理语义的collection使用无缝桥接（toll-free bridging） 通过无缝桥接技术，可以在 Foundation 框架中的 Objective-C 对象与 CoreFoundation 框架中的 C 语言结构之间来回转换。 在 CoreFoundation 层面创建 collection 时，可以指定许多回调函数，这些函数表示此 collection 应如何处理其元素。然后，可运用无缝桥接技术，将其转换成具备特殊内容管理语义的 Objective-C collection。 __bridge ARC 仍然具备这个 Objective-C 对象的所有权。__bridge_retained ARC 将交出对象的所有权。__bridge_transfer 类似于想把 CFArrayRef 转换为 NSArray ，并且想让 ARC 获得对象所有权。 第50条：构建缓存时选用 NSCache 而非 NSDictionary 实现缓存时应选用 NSCache 而非 NSDictionary 对象。因为 NSCache 可以优雅的自动删减功能，而且是线程安全的，此外，它与字典不同，并不会拷贝键。 可以给 NSCache 对象设置上限，用以限制缓存中的对象总个数及总成本，而这些尺寸则定义了缓存删减其中对象的时机。但是绝对不要把这些尺度当成可靠的“硬限制”，他们仅对 NSCache 起指导作用。 将 NSPurgeableData 与 NSCache 搭配使用，可实现自动清除数据的功能，也就是说，当NSPurgeableData 对象所占内存为系统所丢弃时，该对象自身也会从缓存中移除。 如果缓存使用得当，那么应用程序的响应速度就能提高。只有那种“重新计算起来很费事”的数据，才值得放入缓存，比如那些需要从网络获取或从磁盘读取的数据。 第51条：精简 initialize 与 load 的实现代码 在加载阶段，如果类实现了 load 方法，那么系统就会调用它。分类里也可以定义此方法，类的 load 方法要比分类中的先调用。与其他方法不同，load 方法不参与覆写机制。 首次使用某个类之前，系统会向其发送 initialize 消息。由于此方法遵从普通的覆写规则，所以通常应该在里面判断当前要初始化的是哪个类。 load 与 initialize 方法都应该精简一些，这有助于保持应用的响应能力，也能减少引入“依赖环”的几率。 无法在编译期设定的全局常量，可以放在 initialize 方法里初始化。 第52条：别忘了 NSTimer 会保留其目标对象 NSTimer 会保留其目标，直到计时器本身失效为止，调用 invalidate 方法可令计时器失效，另外，一次性的计时器在触发完任务之后也会失效。 反复执行任务的计时器，很容易引入保留环，如果这种计时器的目标对象又保留了计时器本身，那肯定会导致保留环。这种环状保留关系，可能是直接发生的，也可能是通过对象图里的其他对象间接发生的。 可以扩充 NSTimer 的功能，用块来打破保留环。不过除非NSTimer将来在公共接口里提供此功能，否则必须创建分类，将相关的代码加入其中。 感谢您的阅读，一起学习，一起成长，加油！","tags":[{"name":"编写高质量iOS与OS X代码的52个有效方法","slug":"编写高质量iOS与OS-X代码的52个有效方法","permalink":"http://yoursite.com/tags/编写高质量iOS与OS-X代码的52个有效方法/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/tags/学习笔记/"}]},{"title":"zsh 的配置和 CocoaPods 的安装与使用","date":"2015-10-05T08:17:11.000Z","path":"2015/10/05/zsh-and-CocoaPods/","text":"版权声明：本文为 muhlenXi 原创文章，欢迎转载，转载请注明来源。 导语： 对于一个爱折腾的人是闲不住的，最近经常和终端(terminal)打交道，看着这普普通通的界面，实在在是人不可忍了，有一次网上查资料的时候，了解到zsh可以配制出高逼格的用户界面，就是配置有些复杂。但是程序猿都是一群聪明的家伙，研究出oh-my-zsh这个开源项目，让zsh配置降到了零门槛，而且完全兼容bash。 废话不多说，开整吧！ 通过oh-my-zsh配置zsh配置步骤 打开我们亲爱的终端：输入命令：cat /etc/shells 可以看到Mac内置了6中shell 1、安装 oh-my-zsh ，它会自动读取你的环境并帮你设置zsh oh-my-zsh 的地址是：http://github.com/robbyrussell/oh-my-zsh 在终端内输入以下命令clone oh-my-zsh： git clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh 2、替换zshrc文件： cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc 3、切换到zsh模式： chsh -s /bin/zsh 4、关闭并重新打开终端后，会发现变成zsh了，接下来是选择一款高逼格的主题！ oh-my-zsh 主题的主题和对应截图在在这里！ 我选择的是ys主题，在终端中打开oh-my-zsh的配置文件，设置主题为ys： vim ~/.zshrc //打开.zshrc文件 按字母i进入编辑模式，修改ZSH_THEME=&quot;ys&quot;后，按esc退出编辑模式，再按shift + ：，输入wq,就是保存并退出的意思。 5、打开终端的偏好设置，设置如下，就和我的一样了： zsh的配置到这里就结束了。 附上我的zsh最终效果图： 终端常用的命令：1、clear 清除屏幕或窗口内容 2、ls 显示当前目录的内容 3、ls -ah 全部显示当前目录的内容（包含隐藏的） 4、mkdir 创建一个目录 如：mkdir helloword 5、rmdir 删除一个目录 6、mvdir 移动或重命名一个目录 7、cd 改变当前目录 8、pwd 显示当前目录的路径名 9、dircmp 比较两个目录的内容 10、killall -KILL Finder 重启Finder 11、cd .. 返回上一级目录 12、cd ~ 返回主目录 显示mac中隐藏文件\u0010(需重启Finder) defaults write com.apple.finder AppleShowAllFiles -bool true 隐藏mac中隐藏文件(需重启Finder) defaults write com.apple.finder AppleShowAllFiles -bool false 后续会陆续添加… CocoaPods的安装与使用CocoaPods的安装 CocoaPods是一个第三方库的依赖管理工具，可以自动更新第三方库，自动添加系统依赖库，自动设置编译选项，总的来说，就是能自动配置第三个方库的运行环境。他是一个命令行工具！ 打开终端如下操作 1、移除默认的ruby源 gem sources --remove https://rubygems.org/ 移除后会提示：https://rubygems.org/ removed from sources 2、添加 taobao 的源 gem sources -a https://ruby.taobao.org/ 目前源已经更新为：https://gems.ruby-china.org 2017-03-21 修正 1、如果曾经添加过淘宝的源，请执行如下操作，确保只有一个源。 gem sources --add https://gems.ruby-china.org/ --remove http://ruby.taobao.org/ 2、如果没有添加过 taobao 的源，可直接 安装 ruby-china 的源 gem sources --add https://gems.ruby-china.org/ 添加后会提示相应的源已经 added to sources。 3、查看当前的源 gem sources -l 显示结果如图：（该图已经过期，现在应该显示的是 https://gems.ruby-china.org/） 4、安装CocoaPods sudo gem install -n /usr/local/bin cocoapods 安装完成如下图： 终端输入gem list查看CocoaPods的版本 由图知，目前CocoaPods的版本是1.0.1 CocoaPods 添加第三方库1、查看一个库是不是支持CocoaPods 以AFNetworking为例 pod search AFNetworking 出现如图信息则表示支持 2、在Podfile文件添加相应版本的库 cd到你的Xcode项目的目录下： vim Podfile 在里面添加 说明： Podfile升级之后到1.0.0版本，Pod里的内容必须明确指出所用第三方库的target 所以在podfile文件需要明确： target “YOUR_TARGRT_NAME” do ... end 3、安装第三方库 pod install --verbose --no-repo-update 安装完成显示如图： 4、CocoaPods更新第三方库 当我们拿到别人的项目，或者自己的项目要添加新的第三方库，需要更新第三方库。 pod update --verbose --no-repo-update 感谢阅读，有什么问题可以给我留言。","tags":[{"name":"zsh","slug":"zsh","permalink":"http://yoursite.com/tags/zsh/"},{"name":"CocoaPods","slug":"CocoaPods","permalink":"http://yoursite.com/tags/CocoaPods/"}]},{"title":"我为什么要开始写博客？","date":"2015-09-02T03:00:32.000Z","path":"2015/09/02/The-reason-of-write-blog/","text":"想满足好奇心就进来看看吧。 古人云：一分耕耘一分收获 1、记录自己学习、不断的思考总结的过程； 2、分享我的故事、所得、感想、经验； 3、持续学习，积累更多的知识； 4、整理思路、固话知识，获得更多更好的想法！ 5、提高自己将事情讲清楚的能力； 6、记录成长，不断修正自己的错误，如果能指引志同道合的人避免走弯 路，更好； 7、培养自己默默地持续做一件事情的能力！如健身、读书… 8、培养一个业余爱好。 9、结交一些志同道合的朋友！互相鼓励！一路前行！ 10、为自己的人生留下一点痕迹！ 给自己的忠告： 就算你觉得没人会看你写的东西，也要坚持写下去！","tags":[{"name":"写博客起因","slug":"写博客起因","permalink":"http://yoursite.com/tags/写博客起因/"}]},{"title":"ASIHTTPRequest 的简介和使用","date":"2015-08-15T06:08:37.000Z","path":"2015/08/15/ASIHTTPRequest/","text":"版权声明：本文为 muhlenXi 原创文章，欢迎转载，转载请注明来源。 导语： ASIHttpRequest 是一款及其强劲的 HTTP 访问开源项目，让简单的 API 完成复杂的功能，如：异步请求、队列请求、GZIP 压缩、缓存、断点续传、进度跟踪、上传文件、HTTP 认证，同时加入了 Objective-C 闭包 Block 的支持，让我们的代码更加灵活。 由于 ASIHTTPRequest 是开源项目旧版本的库，没有适配 ARC 项目。所以对于目前之前 ARC 的工程来说，需要做适配。 ASIHTTPRequest 的环境配置下载 ASIHTTPRequest 库 点击ASIHTTPRequest下载ASIHTTPResent库。 添加 ASIHTTPRequest 库 到项目组中 找到 ASIHTTPRequest-master 目录，将目录中的 ASIHTTPRequest 文件夹内的所有文件添加到项目中。 添加 系统依赖库【1】选择工程 -&gt; TARGETS -&gt; Building Phases -&gt; Link Binary With Libraries 【2】点击 “+” 号搜索添加。 1、CFNetwork.framework 2、SystemConfiguration.framework 3、MobileCoreServices.framework 4、CoreGraphics.framework 5、libz.1.2.5.tbd 【3】编译运行，会报错。这是ARC使用非ARC库导致的。所以要适配非ARC库，也就是说要在费ARC文件中添加 -fno-objc-arc 字段 ARC 环境下适配非 ARC 文件【1】选择工程 -&gt; TARGETS -&gt; Building Phases -&gt; Compile Source 【2】双击其中的 .m 文件，添加 -fno-objc-arc 字段。 适配完如图所示： ASIHTTPRequest 的使用异步网络请求【1】导入头文件 #import &quot;ASIHTTPRequest.h&quot; 【2】创建并启动异步网络请求 NSString * urlstr = @&quot;http://app.careeach.com:80/action/json_201411/userdata.jsp?action=userdata&amp;userid=22115195&amp;waibao_id=0&quot;; NSURL * url = [NSURL URLWithString:urlstr]; ASIHTTPRequest * request = [ASIHTTPRequest requestWithURL:url]; request.delegate = self; [request startAsynchronous]; 【3】实现请求回调方法 #pragma mark - ASIHTTPRequest-delegate - (void)requestFinished:(ASIHTTPRequest *)request { NSString *respondStr = [request responseString]; NSLog(@&quot;获取个人信息成功&quot;); if(respondStr != nil) { NSError *error; NSData *data = [respondStr dataUsingEncoding:NSUTF8StringEncoding]; NSDictionary * infoDic = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingMutableLeaves error:&amp;error]; NSLog(@&quot;inforDic == %@&quot;,infoDic); } } - (void) requestFailed:(ASIHTTPRequest *)request { NSLog(@&quot;获取个人信息错误,error = %@&quot;,request.error); } 编译并运行项目后，结果如下： 未使用到的会后续补充…,谢谢！","tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://yoursite.com/tags/Objective-C/"},{"name":"ASIHttpRequest","slug":"ASIHttpRequest","permalink":"http://yoursite.com/tags/ASIHttpRequest/"}]},{"title":"在 Mac 上如何搭建 Hexo 个人博客","date":"2015-08-01T03:11:17.000Z","path":"2015/08/01/How-to-make-a-blog-by-Hexo/","text":"版权声明：本文为 muhlenXi 原创文章，欢迎转载，转载请注明来源。 导语： 在网上经常浏览技术牛人的博客来学习技术能力，突然有个念头闪现在脑海,为啥我不自己也弄个博客记录自己的学习收获和分享自己的掉坑经验，避免后来的人不像我一样掉坑，岂不更好！对于一个爱折腾的我，立马就开始各种搜索资料，各种踩坑。 更多详情请看我为什么开始写博客 对于不了解Hexo是什么的？可以去Hexo官网了解一下。Hexo简介 ,废话不扯了，开始正题! 安装Node.js（必须） 选择 Node.js 的安装的程序，进入到下载页面，选择 Download for OSX(x64),左边的版本是建议大多数用户使用的版本，右边的则是最新版本，我选择了左边的那个版本，然后，下载，安装即可。传送门 安装Git(必须) 由于我经常使用 Xcode 软件，所以这里不用安装 Git,Xcode 软件自带 Git,也许有些人不知道 Git 是什么以及怎么使用，可以看Git教程了解一下，这是我目前见到讲解的深入浅出的文章。 PS：后面需要配置站点和主题文件，需要打开其他格式的文本，个人建议用Xcode会好些。 Xcode for Mac 安装 Git 安装 注册Github账号（必须） 注册Github账号可以看Github的注册与使用（详细图解） 进一步想深入学习Github的可以看一下这个博客 从0开始学习Github系列汇总 Hexo 的安装与配置安装Hexo 以上三步，根据自己实际情况安装。安装完成后，可进行接下来这步。打开终端，cd到你想要存放Hexo配置的路径下进行如下操作： mkdir &quot;MyBlog&quot; //创建MyBlog文件夹 ls //查看当前目录下是否有MyBlog文件夹 cd cd MyBlog/ //进入到MyBlog目录下 npm install hexo-cli -g //安装Hexo hexo init //初始化Hexo 到这里为止，Hexo博客安装工作基本完成，MyBlog就是你博客的根目录，关于博客的所有操作均在MyBlog里面进行。 配置Github 【1】登录你的Github账号，创建一个Repository（仓库），仓库的名字必须是 你的github的用户名.github.io （这是固定写法） 在这里假设你的用户名是zhangsan，则你要创建的仓库名就是zhangsan.github.io 【2】用 终端 或者 Github Desktop软件 Clone zhangsan.github.io 仓库到本地你指定的目录下。 【3】进入到MyBlog文件夹，找到 _config.yml (站点配置文件)然后打开它，我用Xcode打开它，翻到最后面，进行如下操作 改成这个样子： deploy: type:git repository:git@github.com:zhangsan/zhangsan.github.io.git branch:master 【4】打开终端 输入 npm install hexo-deployer-git --save hexo generate 或 hexo g //生成静态界面 hexo server //本地启动 【5】打开浏览器 输入 http://localhost:4000/ 则可以看到你 本地生成的静态页面了 打开终端 使用快捷键 control + c 停止本地启动进程 【6】拷贝MyBlog目录下的Public文件夹里面的所有文件到你Clone到本地的zhangsan.github.io 文件夹 【7】使用 终端 或者 Github Desktop Commit、Push zhangsan.github.io 到远程Github仓库中 【8】使用 终端 进入到 MyBlog目录下，执行如下命令 hexo deploy //部署博客到Github 这样，就成功的将你的Hexo博客部署到了Github，你在浏览器中输入http://zhangsan.github.io 就可以了看到你的博客了。 常用的Hexo基本操作hexo clean //清理缓存 hexo generate //生成静态界面 hexo deploy //部署到Github hexo server //本地启动博客 hexo new “文章名” //新建一篇文章 hexo new page &quot;页面名&quot; //新建一个页面 hexo help //查看帮助 hexo version //查看Hexo的版本 给你的博客安装并配置 Next主题 Next主题的主旨在于简洁优雅并且易于使用，尤其是是精于心，简于形的里面深入我心，见到的第一眼，就深深的吸引住了，无法自拔。具体步骤如下： 【1】使用终端 进入到 MyBlog目录下，输入命令 git clone https://github.com/iissnan/hexo-theme-next themes/next 这样就把Next主题Clone到你的MyBlog/themes路径下了。 【2】进入到MyBlog文件夹，找到 _config.yml (站点配置文件)然后打开它，我用Xcode打开，找到theme字段，修改成 theme: next 【3】配置Next主题，进入到MyBlog/themes/next目录下，打开_config.yml (主题配置文件)然后打开它，我一般用Xcode打开，找到Schemes字段，next主题有三种形式，我中意Mist,修改如下 # Schemes #scheme: Muse scheme: Mist #scheme: Pisces 【4】打开终端进入到cd到MyBlog文件夹,输入命令 hexo clean hexo generate hexo server 这样，打开浏览器 输入 http://localhost:4000/ 就可以看到和我一样的主题了。 我的博客 mulenxi 更多的Next主题配置，可以参考Next官方文档。 搭建博客参考 1、购买域名，对域名解析和绑定Github，可以参考如何搭建一个独立博客 2、学习使用Markdown,可以参考认识与入门Markdown 3、Hexo搭建过程出现问题，可以参考Hexo—搭建","tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"},{"name":"Next","slug":"Next","permalink":"http://yoursite.com/tags/Next/"}]}]